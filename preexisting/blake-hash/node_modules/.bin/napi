#!/usr/bin/env node
import { createRequire } from "node:module";
import { Cli, Command, Option } from "clipanion";
import path, { dirname, isAbsolute, join, parse, resolve } from "node:path";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import rawDebug from "debug";
import { access, copyFile, mkdir, readFile, readdir, rename, stat, unlink, writeFile } from "node:fs/promises";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import fs, { existsSync, mkdirSync, promises, rmSync, statSync } from "node:fs";
import { isNil, merge, omit, omitBy, pick, sortBy } from "es-toolkit";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { parse as parse$1 } from "semver";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { Octokit } from "@octokit/rest";
import { checkbox, confirm, input, select } from "@inquirer/prompts";

//#region src/def/artifacts.ts
var BaseArtifactsCommand = class extends Command {
	static paths = [["artifacts"]];
	static usage = Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	buildOutputDir = Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
rawDebug.formatters.i = (v) => {
	return colors.green(v);
};
const debugFactory = (namespace) => {
	const debug$10 = rawDebug(`napi:${namespace}`);
	debug$10.info = (...args) => console.error(colors.black(colors.bgGreen(" INFO ")), ...args);
	debug$10.warn = (...args) => console.error(colors.black(colors.bgYellow(" WARNING ")), ...args);
	debug$10.error = (...args) => console.error(colors.white(colors.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$10;
};
const debug$9 = debugFactory("utils");

//#endregion
//#region package.json
var name = "@napi-rs/cli";
var version$1 = "3.4.1";
var description = "Cli tools for napi-rs";
var author = "LongYinan <lynweklm@gmail.com>";
var homepage = "https://github.com/napi-rs/napi-rs";
var license = "MIT";
var type = "module";
var engines = { "node": ">= 16" };
var bin = {
	"napi": "./dist/cli.js",
	"napi-raw": "./cli.mjs"
};
var main = "./dist/index.cjs";
var module = "./dist/index.js";
var types = "./dist/index.d.ts";
var exports = {
	".": {
		"import": "./dist/index.js",
		"require": "./dist/index.cjs"
	},
	"./package.json": "./package.json"
};
var files = [
	"dist",
	"src",
	"!__tests__"
];
var keywords = [
	"cli",
	"rust",
	"napi",
	"n-api",
	"node-api",
	"node-addon",
	"neon"
];
var maintainers = [{
	"name": "LongYinan",
	"email": "lynweklm@gmail.com",
	"homepage": "https://github.com/Brooooooklyn"
}, {
	"name": "forehalo",
	"homepage": "https://github.com/forehalo"
}];
var repository = {
	"type": "git",
	"url": "git+https://github.com/napi-rs/napi-rs.git"
};
var publishConfig = {
	"registry": "https://registry.npmjs.org/",
	"access": "public"
};
var bugs = { "url": "https://github.com/napi-rs/napi-rs/issues" };
var dependencies = {
	"@inquirer/prompts": "^7.8.4",
	"@napi-rs/cross-toolchain": "^1.0.3",
	"@napi-rs/wasm-tools": "^1.0.1",
	"@octokit/rest": "^22.0.0",
	"clipanion": "^4.0.0-rc.4",
	"colorette": "^2.0.20",
	"debug": "^4.4.1",
	"emnapi": "^1.5.0",
	"es-toolkit": "^1.39.10",
	"js-yaml": "^4.1.0",
	"semver": "^7.7.2",
	"typanion": "^3.14.0"
};
var devDependencies = {
	"@emnapi/runtime": "^1.5.0",
	"@oxc-node/core": "^0.0.32",
	"@std/toml": "npm:@jsr/std__toml@^1.0.10",
	"@types/debug": "^4.1.12",
	"@types/inquirer": "^9.0.9",
	"@types/js-yaml": "^4.0.9",
	"@types/node": "^24.3.1",
	"@types/semver": "^7.7.1",
	"ava": "^6.4.1",
	"empathic": "^2.0.0",
	"env-paths": "^3.0.0",
	"prettier": "^3.6.2",
	"tsdown": "^0.15.0",
	"tslib": "^2.8.1",
	"typescript": "^5.9.2"
};
var peerDependencies = { "@emnapi/runtime": "^1.5.0" };
var peerDependenciesMeta = {
	"@emnapi/runtime": { "optional": true },
	"emnapi": { "optional": true }
};
var funding = {
	"type": "github",
	"url": "https://github.com/sponsors/Brooooooklyn"
};
var scripts = {
	"codegen": "node --import @oxc-node/core/register ./codegen/index.ts",
	"build": "tsdown",
	"test": "node --import @oxc-node/core/register ../node_modules/ava/entrypoints/cli.mjs"
};
var ava = {
	"extensions": { "ts": "module" },
	"timeout": "2m",
	"workerThreads": false,
	"files": ["**/__tests__/**/*.spec.ts", "e2e/**/*.spec.ts"]
};
var package_default = {
	name,
	version: version$1,
	description,
	author,
	homepage,
	license,
	type,
	engines,
	bin,
	main,
	module,
	types,
	exports,
	files,
	keywords,
	maintainers,
	repository,
	publishConfig,
	bugs,
	dependencies,
	devDependencies,
	peerDependencies,
	peerDependenciesMeta,
	funding,
	scripts,
	ava
};

//#endregion
//#region src/utils/misc.ts
const readFileAsync = readFile;
const writeFileAsync = writeFile;
const unlinkAsync = unlink;
const copyFileAsync = copyFile;
const mkdirAsync = mkdir;
const statAsync = stat;
const readdirAsync = readdir;
function fileExists(path$1) {
	return access(path$1).then(() => true, () => false);
}
async function dirExistsAsync(path$1) {
	try {
		return (await statAsync(path$1)).isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	if (!await fileExists(path$1)) {
		debug$9(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = package_default.version;

//#endregion
//#region src/utils/target.ts
const SUB_SYSTEMS = new Set(["android", "ohos"]);
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-pc-windows-gnu",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"loongarch64-unknown-linux-gnu",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"loongarch64-unknown-linux-gnu": "loongarch64-linux-gnu-gcc-13",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	loongarch64: "loong64",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triples = (rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple).split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	if (abi && SUB_SYSTEMS.has(abi)) {
		sys = abi;
		abi = null;
	}
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host === null || host === void 0 ? void 0 : host.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, ["targets"]));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig === null || userNapiConfig === void 0 ? void 0 : userNapiConfig.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		var _userNapiConfig$tripl, _userNapiConfig$tripl2;
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if ((_userNapiConfig$tripl = userNapiConfig.triples) === null || _userNapiConfig$tripl === void 0 ? void 0 : _userNapiConfig$tripl.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if ((_userNapiConfig$tripl2 = userNapiConfig.triples) === null || _userNapiConfig$tripl2 === void 0 || (_userNapiConfig$tripl2 = _userNapiConfig$tripl2.additional) === null || _userNapiConfig$tripl2 === void 0 ? void 0 : _userNapiConfig$tripl2.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	if (new Set(targets).size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name$1, bin$1) {
	if (detectCargoBinary(bin$1)) {
		debug$9("Cargo binary already installed: %s", name$1);
		return;
	}
	try {
		debug$9("Installing cargo binary: %s", name$1);
		execSync(`cargo install ${name$1}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name$1}`, { cause: e });
	}
}
function detectCargoBinary(bin$1) {
	debug$9("Detecting cargo binary: %s", bin$1);
	try {
		execSync(`cargo help ${bin$1}`, { stdio: "ignore" });
		debug$9("Cargo binary detected: %s", bin$1);
		return true;
	} catch {
		debug$9("Cargo binary not detected: %s", bin$1);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Extends"] = "extends";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			const extendsDef = line.extends ? ` extends ${line.extends}` : "";
			if (line.extends) {
				const genericMatch = line.extends.match(/Iterator<(.+)>$/);
				if (genericMatch) {
					const [T, TResult, TNext] = genericMatch[1].split(",").map((p) => p.trim());
					line.def = line.def + `\nnext(value?: ${TNext}): IteratorResult<${T}, ${TResult}>`;
				}
			}
			s += `${exportDeclare(ambient)} class ${line.name}${extendsDef} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports$1 = [];
	const defs = await readIntermediateTypeFile(intermediateTypeFile);
	const groupedDefs = preprocessTypeDef(defs);
	return {
		dts: sortBy(Array.from(groupedDefs), [([namespace]) => namespace]).map(([namespace, defs$1]) => {
			if (namespace === TOP_LEVEL_NAMESPACE) return defs$1.map((def) => {
				switch (def.kind) {
					case TypeDefKind.Const:
					case TypeDefKind.Enum:
					case TypeDefKind.StringEnum:
					case TypeDefKind.Fn:
					case TypeDefKind.Struct:
						exports$1.push(def.name);
						if (def.original_name && def.original_name !== def.name) exports$1.push(def.original_name);
						break;
					default: break;
				}
				return prettyPrint(def, constEnum, 0);
			}).join("\n\n");
			else {
				exports$1.push(namespace);
				let declaration = "";
				declaration += `export declare namespace ${namespace} {\n`;
				for (const def of defs$1) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
				declaration += "}";
				return declaration;
			}
		}).join("\n\n") + "\n",
		exports: exports$1
	};
}
async function readIntermediateTypeFile(file) {
	return (await readFileAsync(file, "utf8")).split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	}).sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = /* @__PURE__ */ new Map();
	const classDefs = /* @__PURE__ */ new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Extends) {
			const classDef = classDefs.get(def.name);
			if (classDef) classDef.extends = def.def;
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	return src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		return `${" ".repeat(rightIndent)}${line}`;
	}).join("\n");
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	return await readNapiConfig(resolvePath(options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
}

//#endregion
//#region src/api/artifacts.ts
const debug$8 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const packageJsonPath = resolvePath(options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath, options.configPath ? resolvePath(options.configPath) : void 0);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => {
		var _UniArchsByPlatform$p;
		return (_UniArchsByPlatform$p = UniArchsByPlatform[p.platform]) === null || _UniArchsByPlatform$p === void 0 ? void 0 : _UniArchsByPlatform$p.map((a) => `${p.platform}-${a}`);
	}).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$8.info(`Read [${colors.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$8.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir$1 = distDirs.find((dir$2) => dir$2.includes(platformArchABI));
		if (!dir$1 && universalSourceBins.has(platformArchABI)) {
			debug$8.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir$1) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir$1, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$8.info(`Move wasi binding file [${colors.yellowBright(cjsFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$8.info(`Move wasi worker file [${colors.yellowBright(workerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$8.info(`Move wasi browser entry file [${colors.yellowBright(browserEntry)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$8.info(`Move wasi browser worker file [${colors.yellowBright(browserWorkerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files$1 = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files$1.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files$1.filter((file) => file.isDirectory());
	for (const dir$1 of dirs) if (dir$1.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir$1.name)));
	return nodeBinaries;
}

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents, packageVersion) {
	return `${bindingHeader}
${createCommonBinding(localName, pkgName, packageVersion)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents, packageVersion) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName, packageVersion)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName, packageVersion) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		const versionCheck = packageVersion ? `
${identLow}try {
${ident}const binding = require('${pkgName}-${tuple}')
${ident}const bindingPackageVersion = require('${pkgName}-${tuple}/package.json').version
${ident}if (bindingPackageVersion !== '${packageVersion}' && process.env.NAPI_RS_ENFORCE_VERSION_CHECK && process.env.NAPI_RS_ENFORCE_VERSION_CHECK !== '0') {
${ident}  throw new Error(\`Native binding package version mismatch, expected ${packageVersion} but got \${bindingPackageVersion}. You can reinstall dependencies to fix this issue.\`)
${ident}}
${ident}return binding
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}` : `
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`;
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}${versionCheck}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      return require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      if (process.config?.variables?.shlib_suffix === 'dll.a' || process.config?.variables?.node_target_type === 'shared_library') {
        ${requireTuple("win32-x64-gnu")}
      } else {
        ${requireTuple("win32-x64-msvc")}
      }
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'loong64') {
      if (isMusl()) {
        ${requireTuple("linux-loong64-musl", 10)}
      } else {
        ${requireTuple("linux-loong64-gnu", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("openharmony-arm64")}
    } else if (process.arch === 'x64') {
      ${requireTuple("openharmony-x64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("openharmony-arm")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  let wasiBinding = null
  let wasiBindingError = null
  try {
    wasiBinding = require('./${localName}.wasi.cjs')
    nativeBinding = wasiBinding
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      wasiBindingError = err
    }
  }
  if (!nativeBinding) {
    try {
      wasiBinding = require('${pkgName}-wasm32-wasi')
      nativeBinding = wasiBinding
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        wasiBindingError.cause = err
        loadErrors.push(err)
      }
    }
  }
  if (process.env.NAPI_RS_FORCE_WASI === 'error' && !wasiBinding) {
    const error = new Error('WASI binding not found and NAPI_RS_FORCE_WASI is set to error')
    error.cause = wasiBindingError
    throw error
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      {
        cause: loadErrors.reduce((err, cur) => {
          cur.cause = err
          return cur
        }),
      },
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fs$1 ? buffer ? `import { memfs, Buffer } from '@napi-rs/wasm-runtime/fs'` : `import { memfs } from '@napi-rs/wasm-runtime/fs'` : ""}
${buffer && !fs$1 ? `import { Buffer } from 'buffer'` : ""}
${fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${buffer ? "__emnapiContext.feature.Buffer = Buffer" : ""}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : ""}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	return `${fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
const debug$7 = debugFactory("build");
const require = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$7("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	const config = await readNapiConfig(resolvePath(options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
	return new Builder(metadata, crate, config, options).build();
}
var Builder = class {
	args = [];
	envs = {};
	outputs = [];
	target;
	crateDir;
	outputDir;
	targetDir;
	enableTypeDef = false;
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$7.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$7.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		var _this$crate$targets$f;
		return (_this$crate$targets$f = this.crate.targets.find((t) => t.crate_types.includes("cdylib"))) === null || _this$crate$targets$f === void 0 ? void 0 : _this$crate$targets$f.name;
	}
	get binName() {
		var _this$crate$targets$f2;
		return this.options.bin ?? (this.cdyLibName ? null : (_this$crate$targets$f2 = this.crate.targets.find((t) => t.crate_types.includes("bin"))) === null || _this$crate$targets$f2 === void 0 ? void 0 : _this$crate$targets$f2.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$7.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$7.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$7.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			var _process$env$TARGET_C, _process$env$CC, _process$env$CXX, _process$env$TARGET_C2;
			const { version: version$2, download } = require("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$7(`Toolchain ${toolchainPath} exists, skip extracting`);
			else download(process.arch, this.target.triple).unpack(toolchainPath);
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.setEnvIfNotExists(linkerEnv, join(toolchainPath, "bin", `${crossTargetName}-gcc`));
			this.setEnvIfNotExists("TARGET_SYSROOT", join(toolchainPath, crossTargetName, "sysroot"));
			this.setEnvIfNotExists("TARGET_AR", join(toolchainPath, "bin", `${crossTargetName}-ar`));
			this.setEnvIfNotExists("TARGET_RANLIB", join(toolchainPath, "bin", `${crossTargetName}-ranlib`));
			this.setEnvIfNotExists("TARGET_READELF", join(toolchainPath, "bin", `${crossTargetName}-readelf`));
			this.setEnvIfNotExists("TARGET_C_INCLUDE_PATH", join(toolchainPath, crossTargetName, "sysroot", "usr", "include/"));
			this.setEnvIfNotExists("TARGET_CC", join(toolchainPath, "bin", `${crossTargetName}-gcc`));
			this.setEnvIfNotExists("TARGET_CXX", join(toolchainPath, "bin", `${crossTargetName}-g++`));
			this.setEnvIfNotExists("BINDGEN_EXTRA_CLANG_ARGS", `--sysroot=${this.envs.TARGET_SYSROOT}}`);
			if (((_process$env$TARGET_C = process.env.TARGET_CC) === null || _process$env$TARGET_C === void 0 ? void 0 : _process$env$TARGET_C.startsWith("clang")) || ((_process$env$CC = process.env.CC) === null || _process$env$CC === void 0 ? void 0 : _process$env$CC.startsWith("clang")) && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (((_process$env$CXX = process.env.CXX) === null || _process$env$CXX === void 0 ? void 0 : _process$env$CXX.startsWith("clang++")) && !process.env.TARGET_CXX || ((_process$env$TARGET_C2 = process.env.TARGET_CXX) === null || _process$env$TARGET_C2 === void 0 ? void 0 : _process$env$TARGET_C2.startsWith("clang++"))) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$7.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$7(`Start building crate: ${this.crate.name}`);
		debug$7("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		return {
			task: new Promise((resolve$1, reject) => {
				var _buildProcess$stderr;
				if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
				const command = process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo");
				const buildProcess = spawn(command, this.args, {
					env: {
						...process.env,
						...this.envs
					},
					stdio: watch ? [
						"inherit",
						"inherit",
						"pipe"
					] : "inherit",
					cwd: this.options.cwd,
					signal: controller.signal
				});
				buildProcess.once("exit", (code) => {
					if (code === 0) {
						debug$7("%i", `Build crate ${this.crate.name} successfully!`);
						resolve$1();
					} else reject(/* @__PURE__ */ new Error(`Build failed with exit code ${code}`));
				});
				buildProcess.once("error", (e) => {
					reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
				});
				(_buildProcess$stderr = buildProcess.stderr) === null || _buildProcess$stderr === void 0 || _buildProcess$stderr.on("data", (data) => {
					const output = data.toString();
					console.error(output);
					if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
				});
			}).then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$7.warn("Watch mode is not supported in CI environment");
		else {
			debug$7("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$7.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && (function(abi) {
			var _process$report;
			const libc = ((_process$report = process.report) === null || _process$report === void 0 || (_process$report = _process$report.getReport()) === null || _process$report === void 0 || (_process$report = _process$report.header) === null || _process$report === void 0 ? void 0 : _process$report.glibcVersionRuntime) ? "gnu" : "musl";
			return abi === libc;
		})(this.target.abi)) debug$7.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$7.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$7("Set package flags: ");
			debug$7("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$7("Set compiling target to: ");
		debug$7("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		var _this$target$abi;
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (((_this$target$abi = this.target.abi) === null || _this$target$abi === void 0 ? void 0 : _this$target$abi.includes("musl")) && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$7("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$7("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$7.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_PATH}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$7.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$7("Set features flags: ");
		debug$7("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		var _this$options$cargoOp;
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if ((_this$options$cargoOp = this.options.cargoOptions) === null || _this$options$cargoOp === void 0 ? void 0 : _this$options$cargoOp.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$7(`Try to create output directory:`);
			debug$7("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$7(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$7(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$7("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$7("Copy artifact to:");
			debug$7("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$7("Generate debug wasm module");
				try {
					const debugWasmBinary = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src)).emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$7("Generate release wasm module");
					const releaseWasmBinary = new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary).emitWasm(false);
					await writeFileAsync(dest, releaseWasmBinary);
				} catch (e) {
					debug$7.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef) return [];
		const { exports: exports$1, dts } = await generateTypeDef({
			typeDefDir,
			noDtsHeader: this.options.noDtsHeader,
			dtsHeader: this.options.dtsHeader,
			configDtsHeader: this.config.dtsHeader,
			configDtsHeaderFile: this.config.dtsHeaderFile,
			constEnum: this.options.constEnum ?? this.config.constEnum,
			cwd: this.options.cwd
		});
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		try {
			debug$7("Writing type def to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
		} catch (e) {
			debug$7.error("Failed to write type def file");
			debug$7.error(e);
		}
		if (exports$1.length > 0) {
			const dest$1 = join(this.outputDir, this.options.dts ?? "index.d.ts");
			this.outputs.push({
				kind: "dts",
				path: dest$1
			});
		}
		return exports$1;
	}
	async writeJsBinding(idents) {
		return writeJsBinding({
			platform: this.options.platform,
			noJsBinding: this.options.noJsBinding,
			idents,
			jsBinding: this.options.jsBinding,
			esm: this.options.esm,
			binaryName: this.config.binaryName,
			packageName: this.config.packageName,
			version: process.env.npm_new_version ?? this.config.packageJson.version,
			outputDir: this.outputDir
		});
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			var _this$config$wasm, _this$config$wasm2, _this$config$wasm3, _this$config$wasm4, _this$config$wasm5, _this$config$wasm6, _this$config$wasm7, _this$config$wasm8;
			const { name: name$1, dir: dir$1 } = parse(distFileName);
			const bindingPath = join(dir$1, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir$1, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir$1, "wasi-worker.mjs");
			const browserWorkerPath = join(dir$1, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir$1, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name$1, this.config.packageName, (_this$config$wasm = this.config.wasm) === null || _this$config$wasm === void 0 ? void 0 : _this$config$wasm.initialMemory, (_this$config$wasm2 = this.config.wasm) === null || _this$config$wasm2 === void 0 ? void 0 : _this$config$wasm2.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name$1, (_this$config$wasm3 = this.config.wasm) === null || _this$config$wasm3 === void 0 ? void 0 : _this$config$wasm3.initialMemory, (_this$config$wasm4 = this.config.wasm) === null || _this$config$wasm4 === void 0 ? void 0 : _this$config$wasm4.maximumMemory, (_this$config$wasm5 = this.config.wasm) === null || _this$config$wasm5 === void 0 || (_this$config$wasm5 = _this$config$wasm5.browser) === null || _this$config$wasm5 === void 0 ? void 0 : _this$config$wasm5.fs, (_this$config$wasm6 = this.config.wasm) === null || _this$config$wasm6 === void 0 || (_this$config$wasm6 = _this$config$wasm6.browser) === null || _this$config$wasm6 === void 0 ? void 0 : _this$config$wasm6.asyncInit, (_this$config$wasm7 = this.config.wasm) === null || _this$config$wasm7 === void 0 || (_this$config$wasm7 = _this$config$wasm7.browser) === null || _this$config$wasm7 === void 0 ? void 0 : _this$config$wasm7.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(((_this$config$wasm8 = this.config.wasm) === null || _this$config$wasm8 === void 0 || (_this$config$wasm8 = _this$config$wasm8.browser) === null || _this$config$wasm8 === void 0 ? void 0 : _this$config$wasm8.fs) ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};
async function writeJsBinding(options) {
	if (!options.platform || options.noJsBinding || options.idents.length === 0) return;
	const name$1 = options.jsBinding ?? "index.js";
	const binding = (options.esm ? createEsmBinding : createCjsBinding)(options.binaryName, options.packageName, options.idents, options.version);
	try {
		const dest = join(options.outputDir, name$1);
		debug$7("Writing js binding to:");
		debug$7("  %i", dest);
		await writeFileAsync(dest, binding, "utf-8");
		return {
			kind: "js",
			path: dest
		};
	} catch (e) {
		throw new Error("Failed to write js binding file", { cause: e });
	}
}
async function generateTypeDef(options) {
	if (!await dirExistsAsync(options.typeDefDir)) return {
		exports: [],
		dts: ""
	};
	let header = "";
	let dts = "";
	let exports$1 = [];
	if (!options.noDtsHeader) {
		const dtsHeader = options.dtsHeader ?? options.configDtsHeader;
		if (options.configDtsHeaderFile) try {
			header = await readFileAsync(join(options.cwd, options.configDtsHeaderFile), "utf-8");
		} catch (e) {
			debug$7.warn(`Failed to read dts header file ${options.configDtsHeaderFile}`, e);
		}
		else if (dtsHeader) header = dtsHeader;
		else header = DEFAULT_TYPE_DEF_HEADER;
	}
	const files$1 = await readdirAsync(options.typeDefDir, { withFileTypes: true });
	if (!files$1.length) {
		debug$7("No type def files found. Skip generating dts file.");
		return {
			exports: [],
			dts: ""
		};
	}
	for (const file of files$1) {
		if (!file.isFile()) continue;
		const { dts: fileDts, exports: fileExports } = await processTypeDef(join(options.typeDefDir, file.name), options.constEnum ?? true);
		dts += fileDts;
		exports$1.push(...fileExports);
	}
	if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
	if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
	dts = header + dts;
	return {
		exports: exports$1,
		dts
	};
}

//#endregion
//#region src/def/create-npm-dirs.ts
var BaseCreateNpmDirsCommand = class extends Command {
	static paths = [["create-npm-dirs"]];
	static usage = Command.Usage({ description: "Create npm package dirs for different platforms" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$6 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir$1) {
		debug$6("Try to create dir: %i", dir$1);
		if (options.dryRun) return;
		await mkdirAsync(dir$1, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$6("Writing file %i", file);
		if (options.dryRun) {
			debug$6(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$6(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			var _scopedPackageJson$fi, _scopedPackageJson$en;
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			(_scopedPackageJson$fi = scopedPackageJson.files) === null || _scopedPackageJson$fi === void 0 || _scopedPackageJson$fi.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if ((_scopedPackageJson$en = scopedPackageJson.engines) === null || _scopedPackageJson$en === void 0 ? void 0 : _scopedPackageJson$en.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		const targetPackageJson = join(targetDir, "package.json");
		await writeFileAsync$1(targetPackageJson, JSON.stringify(scopedPackageJson, null, 2) + "\n");
		const targetReadme = join(targetDir, "README.md");
		await writeFileAsync$1(targetReadme, readme(packageName, target));
		debug$6.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/def/new.ts
var BaseNewCommand = class extends Command {
	static paths = [["new"]];
	static usage = Command.Usage({ description: "Create a new project with pre-configured boilerplate" });
	$$path = Option.String({ required: false });
	$$name = Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" });
	minNodeApiVersion = Option.String("--min-node-api,-v", "4", {
		validator: typanion.isNumber(),
		description: "The minimum Node-API version to support"
	});
	packageManager = Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." });
	license = Option.String("--license,-l", "MIT", { description: "License for open-sourced project" });
	targets = Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." });
	enableDefaultTargets = Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" });
	enableAllTargets = Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" });
	enableTypeDef = Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" });
	enableGithubActions = Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" });
	testFramework = Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" });
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@std/toml/stringify.js
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var Dumper = class {
	maxPad = 0;
	srcObject;
	output = [];
	#arrayTypeCache = /* @__PURE__ */ new Map();
	constructor(srcObjc) {
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = this.#printObject(this.srcObject);
		this.output = this.#format(fmtOptions);
		return this.output;
	}
	#printObject(obj, keys = []) {
		const out = [];
		const props = Object.keys(obj);
		const inlineProps = [];
		const multilineProps = [];
		for (const prop of props) if (this.#isSimplySerializable(obj[prop])) inlineProps.push(prop);
		else multilineProps.push(prop);
		const sortedProps = inlineProps.concat(multilineProps);
		for (const prop of sortedProps) {
			const value$1 = obj[prop];
			if (value$1 instanceof Date) out.push(this.#dateDeclaration([prop], value$1));
			else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push(this.#strDeclaration([prop], value$1.toString()));
			else if (typeof value$1 === "number") out.push(this.#numberDeclaration([prop], value$1));
			else if (typeof value$1 === "boolean") out.push(this.#boolDeclaration([prop], value$1));
			else if (value$1 instanceof Array) {
				const arrayType = this.#getTypeOfArray(value$1);
				if (arrayType === "ONLY_PRIMITIVE") out.push(this.#arrayDeclaration([prop], value$1));
				else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
					out.push("");
					out.push(this.#headerGroup([...keys, prop]));
					out.push(...this.#printObject(value$1[i], [...keys, prop]));
				}
				else {
					const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
					out.push(`${this.#declaration([prop])}[${str}]`);
				}
			} else if (typeof value$1 === "object") {
				out.push("");
				out.push(this.#header([...keys, prop]));
				if (value$1) {
					const toParse = value$1;
					out.push(...this.#printObject(toParse, [...keys, prop]));
				}
			}
		}
		out.push("");
		return out;
	}
	#isPrimitive(value$1) {
		return value$1 instanceof Date || value$1 instanceof RegExp || [
			"string",
			"number",
			"boolean"
		].includes(typeof value$1);
	}
	#getTypeOfArray(arr) {
		if (this.#arrayTypeCache.has(arr)) return this.#arrayTypeCache.get(arr);
		const type$1 = this.#doGetTypeOfArray(arr);
		this.#arrayTypeCache.set(arr, type$1);
		return type$1;
	}
	#doGetTypeOfArray(arr) {
		if (!arr.length) return "ONLY_PRIMITIVE";
		const onlyPrimitive = this.#isPrimitive(arr[0]);
		if (arr[0] instanceof Array) return "MIXED";
		for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== this.#isPrimitive(arr[i]) || arr[i] instanceof Array) return "MIXED";
		return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#printAsInlineValue(value$1) {
		if (value$1 instanceof Date) return `"${this.#printDate(value$1)}"`;
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
		else if (typeof value$1 === "number") return value$1;
		else if (typeof value$1 === "boolean") return value$1.toString();
		else if (value$1 instanceof Array) return `[${value$1.map((x) => this.#printAsInlineValue(x)).join(",")}]`;
		else if (typeof value$1 === "object") {
			if (!value$1) throw new Error("Should never reach");
			return `{${Object.keys(value$1).map((key) => {
				return `${joinKeys([key])} = ${this.#printAsInlineValue(value$1[key])}`;
			}).join(",")}}`;
		}
		throw new Error("Should never reach");
	}
	#isSimplySerializable(value$1) {
		return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && this.#getTypeOfArray(value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#header(keys) {
		return `[${joinKeys(keys)}]`;
	}
	#headerGroup(keys) {
		return `[[${joinKeys(keys)}]]`;
	}
	#declaration(keys) {
		const title = joinKeys(keys);
		if (title.length > this.maxPad) this.maxPad = title.length;
		return `${title} = `;
	}
	#arrayDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#strDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#numberDeclaration(keys, value$1) {
		if (Number.isNaN(value$1)) return `${this.#declaration(keys)}nan`;
		switch (value$1) {
			case Infinity: return `${this.#declaration(keys)}inf`;
			case -Infinity: return `${this.#declaration(keys)}-inf`;
			default: return `${this.#declaration(keys)}${value$1}`;
		}
	}
	#boolDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${value$1}`;
	}
	#printDate(value$1) {
		function dtPad(v, lPad = 2) {
			return v.padStart(lPad, "0");
		}
		const m = dtPad((value$1.getUTCMonth() + 1).toString());
		const d = dtPad(value$1.getUTCDate().toString());
		const h = dtPad(value$1.getUTCHours().toString());
		const min = dtPad(value$1.getUTCMinutes().toString());
		const s = dtPad(value$1.getUTCSeconds().toString());
		const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
		return `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
	}
	#dateDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${this.#printDate(value$1)}`;
	}
	#format(options = {}) {
		const { keyAlignment = false } = options;
		const rDeclaration = /^(\".*\"|[^=]*)\s=/;
		const out = [];
		for (let i = 0; i < this.output.length; i++) {
			const l = this.output[i];
			if (l[0] === "[" && l[1] !== "[") {
				var _this$output;
				if (this.output[i + 1] === "" && ((_this$output = this.output[i + 2]) === null || _this$output === void 0 ? void 0 : _this$output.slice(0, l.length)) === l.slice(0, -1) + ".") {
					i += 1;
					continue;
				}
				out.push(l);
			} else if (keyAlignment) {
				const m = rDeclaration.exec(l);
				if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
				else out.push(l);
			} else out.push(l);
		}
		const cleanedOutput = [];
		for (let i = 0; i < out.length; i++) {
			const l = out[i];
			if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
		}
		return cleanedOutput;
	}
};
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@std/toml/_parser.js
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var Scanner = class {
	#whitespace = /[ \t]/;
	#position = 0;
	#source;
	constructor(source) {
		this.#source = source;
	}
	get position() {
		return this.#position;
	}
	get source() {
		return this.#source;
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return this.#source[this.#position + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return this.#source.slice(this.#position + start, this.#position + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		this.#position += count;
	}
	skipWhitespaces() {
		while (this.#whitespace.test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = this.#position;
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if (this.#whitespace.test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return this.#position >= this.#source.length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return this.#source.startsWith(searchString, this.#position);
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = this.#position;
		return this.#source.match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = { __proto__: null }) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type: type$1, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		const last = currentValue.at(-1);
		deepAssign(last, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type: type$1, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		if (table$1.keys.length === 1) currentValue.push(value$1);
		else {
			const last = currentValue.at(-1);
			deepAssign(last, {
				type: table$1.type,
				keys: table$1.keys.slice(1),
				value: table$1.value
			});
		}
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type: type$1,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		if (!Separator(scanner).ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = { __proto__: null };
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	var _scanner$match;
	scanner.skipWhitespaces();
	const key = (_scanner$match = scanner.match(BARE_KEY_REGEXP)) === null || _scanner$match === void 0 ? void 0 : _scanner$match[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	return success(string === "true");
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const value$1 = INFINITY_MAP.get(string);
	return success(value$1);
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	return success(NaN);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	var _scanner$match2;
	scanner.skipWhitespaces();
	const match = (_scanner$match2 = scanner.match(BINARY_REGEXP)) === null || _scanner$match2 === void 0 ? void 0 : _scanner$match2[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	var _scanner$match3;
	scanner.skipWhitespaces();
	const match = (_scanner$match3 = scanner.match(OCTAL_REGEXP)) === null || _scanner$match3 === void 0 ? void 0 : _scanner$match3[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	var _scanner$match4;
	scanner.skipWhitespaces();
	const match = (_scanner$match4 = scanner.match(HEX_REGEXP)) === null || _scanner$match4 === void 0 ? void 0 : _scanner$match4[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	var _scanner$match5;
	scanner.skipWhitespaces();
	const match = (_scanner$match5 = scanner.match(INTEGER_REGEXP)) === null || _scanner$match5 === void 0 ? void 0 : _scanner$match5[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	return success(parseInt(value$1, 10));
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	var _scanner$match6;
	scanner.skipWhitespaces();
	const match = (_scanner$match6 = scanner.match(FLOAT_REGEXP)) === null || _scanner$match6 === void 0 ? void 0 : _scanner$match6[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	var _scanner$match7;
	scanner.skipWhitespaces();
	const match = (_scanner$match7 = scanner.match(LOCAL_TIME_REGEXP)) === null || _scanner$match7 === void 0 ? void 0 : _scanner$match7[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({ __proto__: null });
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = { __proto__: null };
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : { __proto__: null }
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : { __proto__: null }
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({ __proto__: null });
	const body = blocks.body.reduce(deepAssign, { __proto__: null });
	return success(body);
}
function createParseErrorMessage(scanner, message) {
	var _lines$at;
	const lines = scanner.source.slice(0, scanner.position).split("\n");
	const row = lines.length;
	const column = ((_lines$at = lines.at(-1)) === null || _lines$at === void 0 ? void 0 : _lines$at.length) ?? 0;
	return `Parse error on line ${row}, column ${column}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			throw new SyntaxError(createParseErrorMessage(scanner, "Invalid error type caught"));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region ../node_modules/empathic/resolve.mjs
/**
* Resolve an absolute path from {@link root}, but only
* if {@link input} isn't already absolute.
*
* @param input The path to resolve.
* @param root The base path; default = process.cwd()
* @returns The resolved absolute path.
*/
function absolute(input$1, root) {
	return isAbsolute(input$1) ? input$1 : resolve(root || ".", input$1);
}

//#endregion
//#region ../node_modules/empathic/walk.mjs
/**
* Get all parent directories of {@link base}.
* Stops after {@link Options['last']} is processed.
*
* @returns An array of absolute paths of all parent directories.
*/
function up(base, options) {
	let { last, cwd } = options || {};
	let tmp = absolute(base, cwd);
	let root = absolute(last || "/", cwd);
	let prev, arr = [];
	while (prev !== root) {
		arr.push(tmp);
		tmp = dirname(prev = tmp);
		if (tmp === prev) break;
	}
	return arr;
}

//#endregion
//#region ../node_modules/empathic/find.mjs
/**
* Find a directory by name, walking parent directories until found.
*
* > [NOTE]
* > This function only returns a value for directory matches.
* > A file match with the same name will be ignored.
*
* @param name The directory name to find.
* @returns The absolute path to the file, if found.
*/
function dir(name$1, options) {
	let dir$1, tmp;
	let start = options && options.cwd || "";
	for (dir$1 of up(start, options)) try {
		tmp = join(dir$1, name$1);
		if (statSync(tmp).isDirectory()) return tmp;
	} catch {}
}

//#endregion
//#region src/def/rename.ts
var BaseRenameCommand = class extends Command {
	static paths = [["rename"]];
	static usage = Command.Usage({ description: "Rename the NAPI-RS project" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	$$name = Option.String("--name,-n", { description: "The new name of the project" });
	binaryName = Option.String("--binary-name,-b", { description: "The new binary name *.node files" });
	packageName = Option.String("--package-name", { description: "The new package name of the project" });
	manifestPath = Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" });
	repository = Option.String("--repository", { description: "The new repository of the project" });
	description = Option.String("--description", { description: "The new description of the project" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const oldName = (await readConfig(options)).binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil)), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const tomlContent = await readFileAsync(cargoTomlPath, "utf8");
	const cargoToml = parse$2(tomlContent);
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	const updatedTomlContent = stringify(cargoToml);
	await writeFileAsync(cargoTomlPath, updatedTomlContent);
	if (oldName !== options.binaryName) {
		const githubActionsPath = dir(".github", { cwd: options.cwd });
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				var _githubActionsData$en;
				const githubActionsContent = await readFileAsync(githubActionsCIYmlPath, "utf8");
				const githubActionsData = load(githubActionsContent);
				if ((_githubActionsData$en = githubActionsData.env) === null || _githubActionsData$en === void 0 ? void 0 : _githubActionsData$en.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) {
			const gitAttributesData = (await readFileAsync(gitAttributesPath, "utf8")).split("\n").map((line) => {
				return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
			}).join("\n");
			await writeFileAsync(gitAttributesPath, gitAttributesData);
		}
	}
}

//#endregion
//#region src/api/new.ts
const debug$5 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$5(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(/* @__PURE__ */ new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$5("Template updated successfully");
		} catch (error) {
			debug$5(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$5(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$5("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	var _packageJson$napi;
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if ((_packageJson$napi = packageJson.napi) === null || _packageJson$napi === void 0 ? void 0 : _packageJson$napi.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	var _yaml$jobs, _yaml$jobs5;
	const content = await promises.readFile(filePath, "utf-8");
	const yaml = load(content);
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"x86_64-pc-windows-gnu",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"loongarch64-unknown-linux-gnu",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml === null || yaml === void 0 || (_yaml$jobs = yaml.jobs) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.build) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.strategy) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.matrix) === null || _yaml$jobs === void 0 ? void 0 : _yaml$jobs.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else {
		var _yaml$jobs2;
		if (yaml === null || yaml === void 0 || (_yaml$jobs2 = yaml.jobs) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2["test-macOS-windows-binding"]) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2.strategy) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2.matrix) === null || _yaml$jobs2 === void 0 ? void 0 : _yaml$jobs2.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
			if (setting.target) return enabledTargets.includes(setting.target);
			return true;
		});
	}
	if (!hasLinuxTargets) {
		var _yaml$jobs3;
		if (yaml === null || yaml === void 0 || (_yaml$jobs3 = yaml.jobs) === null || _yaml$jobs3 === void 0 ? void 0 : _yaml$jobs3["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else {
		var _yaml$jobs4;
		if (yaml === null || yaml === void 0 || (_yaml$jobs4 = yaml.jobs) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4["test-linux-binding"]) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4.strategy) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4.matrix) === null || _yaml$jobs4 === void 0 ? void 0 : _yaml$jobs4.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
			if (target) return enabledTargets.includes(target);
			return true;
		});
	}
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		var _job$strategy;
		const job = jobConfig;
		if ((_job$strategy = job.strategy) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy.matrix) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy.settings) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy[0]) === null || _job$strategy === void 0 ? void 0 : _job$strategy.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray((_yaml$jobs5 = yaml.jobs) === null || _yaml$jobs5 === void 0 || (_yaml$jobs5 = _yaml$jobs5.publish) === null || _yaml$jobs5 === void 0 ? void 0 : _yaml$jobs5.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	var _options$targets;
	debug$5("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$5(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$5(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!((_options$targets = options.targets) === null || _options$targets === void 0 ? void 0 : _options$targets.length)) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$5("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$5("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		if (execSync(`rustup target list`, { encoding: "utf8" }).includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$5("Will create napi-rs project with given options:");
	debug$5(userOptions);
	const options = processOptions(userOptions);
	debug$5("Targets to be enabled:");
	debug$5(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		const templatePath = path.join(cacheDir, "repo");
		await copyDirectory(templatePath, options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$5(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$5(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			if ((await readdirAsync(path$1)).length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$5(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name$1) {
	return name$1.split("/").pop();
}

//#endregion
//#region src/def/pre-publish.ts
var BasePrePublishCommand = class extends Command {
	static paths = [["pre-publish"], ["prepublish"]];
	static usage = Command.Usage({ description: "Update package.json and copy addons into per platform packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" });
	tagStyle = Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" });
	ghRelease = Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" });
	ghReleaseName = Option.String("--gh-release-name", { description: "GitHub release name" });
	ghReleaseId = Option.String("--gh-release-id", { description: "Existing GitHub release id" });
	skipOptionalPublish = Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var BaseVersionCommand = class extends Command {
	static paths = [["version"]];
	static usage = Command.Usage({ description: "Update version in created npm packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$4 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$4(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$3 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$3("Receive pre-publish options:");
	debug$3("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$3(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$3(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			pkgInfo$1 = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag).find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$3.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) try {
				const output = execSync(`${npmClient} publish`, {
					cwd: pkgDir,
					env: process.env,
					stdio: "pipe"
				});
				process.stdout.write(output);
			} catch (e) {
				if (e instanceof Error && e.message.includes("You cannot publish over the previously published versions")) {
					console.info(e.message);
					debug$3.warn(`${pkgDir} has been published, skipping`);
				} else throw e;
			}
			if (options.ghRelease && repo && owner) {
				debug$3.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$3.info(`GitHub release created`);
					debug$3.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$3.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$3.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	return {
		name: segments.join("@"),
		version: version$2,
		tag
	};
}

//#endregion
//#region src/def/universalize.ts
var BaseUniversalizeCommand = class extends Command {
	static paths = [["universalize"]];
	static usage = Command.Usage({ description: "Combile built binaries into one universal binary" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug$2 = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	var _UniArchsByPlatform$p, _universalizers$proce;
	const options = applyDefaultUniversalizeOptions(userOptions);
	const packageJsonPath = join(options.cwd, options.packageJsonPath);
	const config = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	if (!config.targets.find((t) => t.platform === process.platform && t.arch === "universal")) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = (_UniArchsByPlatform$p = UniArchsByPlatform[process.platform]) === null || _UniArchsByPlatform$p === void 0 ? void 0 : _UniArchsByPlatform$p.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug$2(`Looking up source binaries to combine: `);
	debug$2("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	(_universalizers$proce = universalizers[process.platform]) === null || _universalizers$proce === void 0 || _universalizers$proce.call(universalizers, srcFiles, output);
	debug$2(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/commands/artifacts.ts
var ArtifactsCommand = class extends BaseArtifactsCommand {
	static usage = Command.Usage({
		description: "Copy artifacts from Github Actions into specified dir",
		examples: [["$0 artifacts --output-dir ./artifacts --dist ./npm", `Copy [binaryName].[platform].node under current dir(.) into packages under npm dir.
e.g: index.linux-x64-gnu.node --> ./npm/linux-x64-gnu/index.linux-x64-gnu.node`]]
	});
	static paths = [["artifacts"]];
	async execute() {
		await collectArtifacts(this.getOptions());
	}
};

//#endregion
//#region src/def/build.ts
var BaseBuildCommand = class extends Command {
	static paths = [["build"]];
	static usage = Command.Usage({ description: "Build the NAPI-RS project" });
	target = Option.String("--target,-t", { description: "Build for the target triple, bypassed to `cargo build --target`" });
	cwd = Option.String("--cwd", { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	manifestPath = Option.String("--manifest-path", { description: "Path to `Cargo.toml`" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", { description: "Path to `package.json`" });
	targetDir = Option.String("--target-dir", { description: "Directory for all crate generated artifacts, see `cargo build --target-dir`" });
	outputDir = Option.String("--output-dir,-o", { description: "Path to where all the built files would be put. Default to the crate folder" });
	platform = Option.Boolean("--platform", { description: "Add platform triple to the generated nodejs binding file, eg: `[name].linux-x64-gnu.node`" });
	jsPackageName = Option.String("--js-package-name", { description: "Package name in generated js binding file. Only works with `--platform` flag" });
	constEnum = Option.Boolean("--const-enum", { description: "Whether generate const enum for typescript bindings" });
	jsBinding = Option.String("--js", { description: "Path and filename of generated JS binding file. Only works with `--platform` flag. Relative to `--output-dir`." });
	noJsBinding = Option.Boolean("--no-js", { description: "Whether to disable the generation JS binding file. Only works with `--platform` flag." });
	dts = Option.String("--dts", { description: "Path and filename of generated type def file. Relative to `--output-dir`" });
	dtsHeader = Option.String("--dts-header", { description: "Custom file header for generated type def file. Only works when `typedef` feature enabled." });
	noDtsHeader = Option.Boolean("--no-dts-header", { description: "Whether to disable the default file header for generated type def file. Only works when `typedef` feature enabled." });
	dtsCache = Option.Boolean("--dts-cache", true, { description: "Whether to enable the dts cache, default to true" });
	esm = Option.Boolean("--esm", { description: "Whether to emit an ESM JS binding file instead of CJS format. Only works with `--platform` flag." });
	strip = Option.Boolean("--strip,-s", { description: "Whether strip the library to achieve the minimum file size" });
	release = Option.Boolean("--release,-r", { description: "Build in release mode" });
	verbose = Option.Boolean("--verbose,-v", { description: "Verbosely log build command trace" });
	bin = Option.String("--bin", { description: "Build only the specified binary" });
	package = Option.String("--package,-p", { description: "Build the specified library or the one at cwd" });
	profile = Option.String("--profile", { description: "Build artifacts with the specified profile" });
	crossCompile = Option.Boolean("--cross-compile,-x", { description: "[experimental] cross-compile for the specified target with `cargo-xwin` on windows and `cargo-zigbuild` on other platform" });
	useCross = Option.Boolean("--use-cross", { description: "[experimental] use [cross](https://github.com/cross-rs/cross) instead of `cargo`" });
	useNapiCross = Option.Boolean("--use-napi-cross", { description: "[experimental] use @napi-rs/cross-toolchain to cross-compile Linux arm/arm64/x64 gnu targets." });
	watch = Option.Boolean("--watch,-w", { description: "watch the crate changes and build continuously with `cargo-watch` crates" });
	features = Option.Array("--features,-F", { description: "Space-separated list of features to activate" });
	allFeatures = Option.Boolean("--all-features", { description: "Activate all available features" });
	noDefaultFeatures = Option.Boolean("--no-default-features", { description: "Do not activate the `default` feature" });
	getOptions() {
		return {
			target: this.target,
			cwd: this.cwd,
			manifestPath: this.manifestPath,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			targetDir: this.targetDir,
			outputDir: this.outputDir,
			platform: this.platform,
			jsPackageName: this.jsPackageName,
			constEnum: this.constEnum,
			jsBinding: this.jsBinding,
			noJsBinding: this.noJsBinding,
			dts: this.dts,
			dtsHeader: this.dtsHeader,
			noDtsHeader: this.noDtsHeader,
			dtsCache: this.dtsCache,
			esm: this.esm,
			strip: this.strip,
			release: this.release,
			verbose: this.verbose,
			bin: this.bin,
			package: this.package,
			profile: this.profile,
			crossCompile: this.crossCompile,
			useCross: this.useCross,
			useNapiCross: this.useNapiCross,
			watch: this.watch,
			features: this.features,
			allFeatures: this.allFeatures,
			noDefaultFeatures: this.noDefaultFeatures
		};
	}
};

//#endregion
//#region src/commands/build.ts
const debug$1 = debugFactory("build");
var BuildCommand = class extends BaseBuildCommand {
	pipe = Option.String("--pipe", { description: "Pipe all outputs file to given command. e.g. `napi build --pipe \"npx prettier --write\"`" });
	cargoOptions = Option.Rest();
	async execute() {
		const { task } = await buildProject({
			...this.getOptions(),
			cargoOptions: this.cargoOptions
		});
		const outputs = await task;
		if (this.pipe) for (const output of outputs) {
			debug$1("Piping output file to command: %s", this.pipe);
			try {
				execSync(`${this.pipe} ${output.path}`, {
					stdio: "inherit",
					cwd: this.cwd
				});
			} catch (e) {
				debug$1.error(`Failed to pipe output file ${output.path} to command`);
				debug$1.error(e);
			}
		}
	}
};

//#endregion
//#region src/commands/create-npm-dirs.ts
var CreateNpmDirsCommand = class extends BaseCreateNpmDirsCommand {
	async execute() {
		await createNpmDirs(this.getOptions());
	}
};

//#endregion
//#region src/commands/help.ts
/**
* A command that prints the usage of all commands.
*
* Paths: `-h`, `--help`
*/
var HelpCommand = class extends Command {
	static paths = [[`-h`], [`--help`]];
	async execute() {
		await this.context.stdout.write(this.cli.usage());
	}
};

//#endregion
//#region src/commands/new.ts
const debug = debugFactory("new");
var NewCommand = class extends BaseNewCommand {
	interactive = Option.Boolean("--interactive,-i", true, { description: "Ask project basic information interactively without just using the default." });
	async execute() {
		try {
			const options = await this.fetchOptions();
			await newProject(options);
			return 0;
		} catch (e) {
			debug("Failed to create new project");
			debug.error(e);
			return 1;
		}
	}
	async fetchOptions() {
		const cmdOptions = super.getOptions();
		if (this.interactive) {
			const targetPath = cmdOptions.path ? cmdOptions.path : await inquirerProjectPath();
			cmdOptions.path = targetPath;
			return {
				...cmdOptions,
				name: await this.fetchName(path.parse(targetPath).base),
				minNodeApiVersion: await this.fetchNapiVersion(),
				targets: await this.fetchTargets(),
				license: await this.fetchLicense(),
				enableTypeDef: await this.fetchTypeDef(),
				enableGithubActions: await this.fetchGithubActions()
			};
		}
		return cmdOptions;
	}
	async fetchName(defaultName) {
		return this.$$name ?? input({
			message: "Package name (the name field in your package.json file)",
			default: defaultName
		});
	}
	async fetchLicense() {
		return input({
			message: "License for open-sourced project",
			default: this.license
		});
	}
	async fetchNapiVersion() {
		return select({
			message: "Minimum node-api version (with node version requirement)",
			loop: false,
			pageSize: 10,
			choices: Array.from({ length: 8 }, (_, i) => ({
				name: `napi${i + 1} (${napiEngineRequirement(i + 1)})`,
				value: i + 1
			})),
			default: this.minNodeApiVersion - 1
		});
	}
	async fetchTargets() {
		if (this.enableAllTargets) return AVAILABLE_TARGETS.concat();
		return await checkbox({
			loop: false,
			message: "Choose target(s) your crate will be compiled to",
			choices: AVAILABLE_TARGETS.map((target) => ({
				name: target,
				value: target,
				checked: DEFAULT_TARGETS.includes(target)
			}))
		});
	}
	async fetchTypeDef() {
		return await confirm({
			message: "Enable type definition auto-generation",
			default: this.enableTypeDef
		});
	}
	async fetchGithubActions() {
		return await confirm({
			message: "Enable Github Actions CI",
			default: this.enableGithubActions
		});
	}
};
async function inquirerProjectPath() {
	return input({ message: "Target path to create the project, relative to cwd." }).then((path$1) => {
		if (!path$1) return inquirerProjectPath();
		return path$1;
	});
}

//#endregion
//#region src/commands/pre-publish.ts
var PrePublishCommand = class extends BasePrePublishCommand {
	async execute() {
		await prePublish(this.getOptions());
	}
};

//#endregion
//#region src/commands/rename.ts
var RenameCommand = class extends BaseRenameCommand {
	async execute() {
		const options = this.getOptions();
		if (!options.name) options.name = await input({
			message: `Enter the new package name in the package.json`,
			required: true
		});
		if (!options.binaryName) options.binaryName = await input({
			message: `Enter the new binary name`,
			required: true
		});
		await renameProject(options);
	}
};

//#endregion
//#region src/commands/universalize.ts
var UniversalizeCommand = class extends BaseUniversalizeCommand {
	async execute() {
		await universalizeBinaries(this.getOptions());
	}
};

//#endregion
//#region src/commands/version.ts
var VersionCommand = class extends BaseVersionCommand {
	async execute() {
		await version(this.getOptions());
	}
};

//#endregion
//#region src/index.ts
const cli = new Cli({
	binaryName: "napi",
	binaryVersion: CLI_VERSION
});
cli.register(NewCommand);
cli.register(BuildCommand);
cli.register(CreateNpmDirsCommand);
cli.register(ArtifactsCommand);
cli.register(UniversalizeCommand);
cli.register(RenameCommand);
cli.register(PrePublishCommand);
cli.register(VersionCommand);
cli.register(HelpCommand);

//#endregion
//#region src/cli.ts
cli.runExit(process.argv.slice(2));

//#endregion
export {  };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwibmFtZXMiOlsiZGVidWciLCJwYXRoIiwicGljayIsInBrZ0pzb24iLCJUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwiQ3B1VG9Ob2RlQXJjaDogUmVjb3JkPHN0cmluZywgTm9kZUpTQXJjaD4iLCJTeXNUb05vZGVQbGF0Zm9ybTogUmVjb3JkPHN0cmluZywgUGxhdGZvcm0+IiwiVW5pQXJjaHNCeVBsYXRmb3JtOiBQYXJ0aWFsPFJlY29yZDxQbGF0Zm9ybSwgTm9kZUpTQXJjaFtdPj4iLCJjcHU6IHN0cmluZyIsInN5czogc3RyaW5nIiwiYWJpOiBzdHJpbmcgfCBudWxsIiwicmVxdWlyZW1lbnRzOiBzdHJpbmdbXSIsInBhdGgiLCJzZXBhcmF0ZWRDb25maWc6IFVzZXJOYXBpQ29uZmlnIHwgdW5kZWZpbmVkIiwibmFwaUNvbmZpZzogTmFwaUNvbmZpZyIsInRhcmdldHM6IHN0cmluZ1tdIiwiYmluIiwibmFtZSIsImV4cG9ydHM6IHN0cmluZ1tdIiwiZGVmcyIsImRlYnVnIiwiZGlyIiwiZmlsZXMiLCJmcyIsImZzIiwiZGVidWciLCJvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMiLCJtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSIsImNyYXRlOiBDcmF0ZSIsImNvbmZpZzogTmFwaUNvbmZpZyIsImFsaWFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwidmVyc2lvbiIsImV4cG9ydHMiLCJkZXN0IiwiZGlyIiwibmFtZSIsInZhbHVlIiwiZXhwb3J0czogc3RyaW5nW10iLCJmaWxlcyIsImRlYnVnIiwibWtkaXJBc3luYyIsImRpciIsInJhd01rZGlyQXN5bmMiLCJ3cml0ZUZpbGVBc3luYyIsInJhd1dyaXRlRmlsZUFzeW5jIiwic2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzIiwicGljayIsInBhcnNlIiwiI3ByaW50T2JqZWN0IiwiI2Zvcm1hdCIsIiNpc1NpbXBseVNlcmlhbGl6YWJsZSIsInZhbHVlIiwiI2RhdGVEZWNsYXJhdGlvbiIsIiNzdHJEZWNsYXJhdGlvbiIsIiNudW1iZXJEZWNsYXJhdGlvbiIsIiNib29sRGVjbGFyYXRpb24iLCIjZ2V0VHlwZU9mQXJyYXkiLCIjYXJyYXlEZWNsYXJhdGlvbiIsIiNoZWFkZXJHcm91cCIsIiNwcmludEFzSW5saW5lVmFsdWUiLCIjZGVjbGFyYXRpb24iLCIjaGVhZGVyIiwiI2FycmF5VHlwZUNhY2hlIiwidHlwZSIsIiNkb0dldFR5cGVPZkFycmF5IiwiI2lzUHJpbWl0aXZlIiwiI3ByaW50RGF0ZSIsInZhbHVlIiwiI3NvdXJjZSIsIiNwb3NpdGlvbiIsIiN3aGl0ZXNwYWNlIiwidmFsdWUiLCJ0YWJsZSIsInBhcnNlIiwiam9pbiIsIm1lcmdlIiwiZmxvYXQiLCJwYWlyIiwicGFyc2UiLCJpbnB1dCIsImRpciIsIndhbGsudXAiLCJuYW1lIiwicGFyc2VUb21sIiwic3RyaW5naWZ5VG9tbCIsImZpbmQuZGlyIiwieWFtbFBhcnNlIiwieWFtbFN0cmluZ2lmeSIsImRlYnVnIiwiZnMiLCJ5YW1sTG9hZCIsImpvYnNUb1JlbW92ZTogc3RyaW5nW10iLCJ5YW1sRHVtcCIsInN0YXQiLCJwYXRoIiwibmFtZSIsImRlYnVnIiwiZGVidWciLCJwYWNrYWdlTmFtZSIsInZlcnNpb24iLCJyZXBvIiwib3duZXIiLCJvY3Rva2l0IiwicGtnSW5mbyIsInBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkIiwiZGVidWciLCJ1bml2ZXJzYWxpemVyczogUGFydGlhbDxcbiAgUmVjb3JkPE5vZGVKUy5QbGF0Zm9ybSwgKGlucHV0czogc3RyaW5nW10sIG91dHB1dDogc3RyaW5nKSA9PiB2b2lkPlxuPiIsImRlYnVnIiwidGFyZ2V0UGF0aDogc3RyaW5nIiwicGF0aCJdLCJzb3VyY2VzIjpbIi4uL3NyYy9kZWYvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL3V0aWxzL2xvZy50cyIsIi4uL3BhY2thZ2UuanNvbiIsIi4uL3NyYy91dGlscy9taXNjLnRzIiwiLi4vc3JjL3V0aWxzL3RhcmdldC50cyIsIi4uL3NyYy91dGlscy92ZXJzaW9uLnRzIiwiLi4vc3JjL3V0aWxzL21ldGFkYXRhLnRzIiwiLi4vc3JjL3V0aWxzL2NvbmZpZy50cyIsIi4uL3NyYy91dGlscy9jYXJnby50cyIsIi4uL3NyYy91dGlscy90eXBlZ2VuLnRzIiwiLi4vc3JjL3V0aWxzL3JlYWQtY29uZmlnLnRzIiwiLi4vc3JjL2FwaS9hcnRpZmFjdHMudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy9qcy1iaW5kaW5nLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvbG9hZC13YXNpLXRlbXBsYXRlLnRzIiwiLi4vc3JjL2FwaS90ZW1wbGF0ZXMvd2FzaS13b3JrZXItdGVtcGxhdGUudHMiLCIuLi9zcmMvYXBpL2J1aWxkLnRzIiwiLi4vc3JjL2RlZi9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvYXBpL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9kZWYvbmV3LnRzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9zdHJpbmdpZnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQGpzci9zdGRfX2NvbGxlY3Rpb25zL191dGlscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AanNyL3N0ZF9fY29sbGVjdGlvbnMvZGVlcF9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvX3BhcnNlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ac3RkL3RvbWwvcGFyc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW1wYXRoaWMvcmVzb2x2ZS5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW1wYXRoaWMvd2Fsay5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZW1wYXRoaWMvZmluZC5tanMiLCIuLi9zcmMvZGVmL3JlbmFtZS50cyIsIi4uL3NyYy9hcGkvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9uZXcudHMiLCIuLi9zcmMvZGVmL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS92ZXJzaW9uLnRzIiwiLi4vc3JjL2FwaS9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9kZWYvdW5pdmVyc2FsaXplLnRzIiwiLi4vc3JjL2FwaS91bml2ZXJzYWxpemUudHMiLCIuLi9zcmMvY29tbWFuZHMvYXJ0aWZhY3RzLnRzIiwiLi4vc3JjL2RlZi9idWlsZC50cyIsIi4uL3NyYy9jb21tYW5kcy9idWlsZC50cyIsIi4uL3NyYy9jb21tYW5kcy9jcmVhdGUtbnBtLWRpcnMudHMiLCIuLi9zcmMvY29tbWFuZHMvaGVscC50cyIsIi4uL3NyYy9jb21tYW5kcy9uZXcudHMiLCIuLi9zcmMvY29tbWFuZHMvcHJlLXB1Ymxpc2gudHMiLCIuLi9zcmMvY29tbWFuZHMvcmVuYW1lLnRzIiwiLi4vc3JjL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9jb21tYW5kcy92ZXJzaW9uLnRzIiwiLi4vc3JjL2luZGV4LnRzIiwiLi4vc3JjL2NsaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUFydGlmYWN0c0NvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1snYXJ0aWZhY3RzJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIG5wbSBwYWNrYWdlcyBhbmQgcmVhZHkgdG8gcHVibGlzaCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgb3V0cHV0RGlyID0gT3B0aW9uLlN0cmluZygnLS1vdXRwdXQtZGlyLC1vLC1kJywgJy4vYXJ0aWZhY3RzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgYnVpbGRPdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWJ1aWxkLW91dHB1dC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB0aGUgYnVpbGQgb3V0cHV0IGRpciwgb25seSBuZWVkZWQgd2hlbiB0YXJnZXRzIGNvbnRhaW5zIGB3YXNtMzItd2FzaS0qYCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIGJ1aWxkT3V0cHV0RGlyOiB0aGlzLmJ1aWxkT3V0cHV0RGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBucG0gcGFja2FnZXMgYW5kIHJlYWR5IHRvIHB1Ymxpc2hcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdHNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuL2FydGlmYWN0cydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGJ1aWxkIG91dHB1dCBkaXIsIG9ubHkgbmVlZGVkIHdoZW4gdGFyZ2V0cyBjb250YWlucyBgd2FzbTMyLXdhc2ktKmBcbiAgICovXG4gIGJ1aWxkT3V0cHV0RGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zKG9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBvdXRwdXREaXI6ICcuL2FydGlmYWN0cycsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuaW1wb3J0IHJhd0RlYnVnIGZyb20gJ2RlYnVnJ1xuXG4vLyBkZWJ1ZygnJWknLCAnVGhpcyBpcyBhbiBpbmZvJylcbnJhd0RlYnVnLmZvcm1hdHRlcnMuaSA9ICh2KSA9PiB7XG4gIHJldHVybiBjb2xvcnMuZ3JlZW4odilcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ2RlYnVnJyB7XG4gIGludGVyZmFjZSBEZWJ1Z2dlciB7XG4gICAgaW5mbzogdHlwZW9mIGNvbnNvbGUuZXJyb3JcbiAgICB3YXJuOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIGVycm9yOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWJ1Z0ZhY3RvcnkgPSAobmFtZXNwYWNlOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZGVidWcgPSByYXdEZWJ1ZyhgbmFwaToke25hbWVzcGFjZX1gKVxuXG4gIGRlYnVnLmluZm8gPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihjb2xvcnMuYmxhY2soY29sb3JzLmJnR3JlZW4oJyBJTkZPICcpKSwgLi4uYXJncylcbiAgZGVidWcud2FybiA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdZZWxsb3coJyBXQVJOSU5HICcpKSwgLi4uYXJncylcbiAgZGVidWcuZXJyb3IgPSAoLi4uYXJnczogYW55W10pID0+XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGNvbG9ycy53aGl0ZShjb2xvcnMuYmdSZWQoJyBFUlJPUiAnKSksXG4gICAgICAuLi5hcmdzLm1hcCgoYXJnKSA9PlxuICAgICAgICBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IChhcmcuc3RhY2sgPz8gYXJnLm1lc3NhZ2UpIDogYXJnLFxuICAgICAgKSxcbiAgICApXG5cbiAgcmV0dXJuIGRlYnVnXG59XG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3V0aWxzJylcbiIsIntcbiAgXCJuYW1lXCI6IFwiQG5hcGktcnMvY2xpXCIsXG4gIFwidmVyc2lvblwiOiBcIjMuNC4xXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGkgdG9vbHMgZm9yIG5hcGktcnNcIixcbiAgXCJhdXRob3JcIjogXCJMb25nWWluYW4gPGx5bndla2xtQGdtYWlsLmNvbT5cIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnNcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwidHlwZVwiOiBcIm1vZHVsZVwiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49IDE2XCJcbiAgfSxcbiAgXCJiaW5cIjoge1xuICAgIFwibmFwaVwiOiBcIi4vZGlzdC9jbGkuanNcIixcbiAgICBcIm5hcGktcmF3XCI6IFwiLi9jbGkubWpzXCJcbiAgfSxcbiAgXCJtYWluXCI6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICBcIm1vZHVsZVwiOiBcIi4vZGlzdC9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwiLi9kaXN0L2luZGV4LmQudHNcIixcbiAgXCJleHBvcnRzXCI6IHtcbiAgICBcIi5cIjoge1xuICAgICAgXCJpbXBvcnRcIjogXCIuL2Rpc3QvaW5kZXguanNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vZGlzdC9pbmRleC5janNcIlxuICAgIH0sXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCJcbiAgfSxcbiAgXCJmaWxlc1wiOiBbXG4gICAgXCJkaXN0XCIsXG4gICAgXCJzcmNcIixcbiAgICBcIiFfX3Rlc3RzX19cIlxuICBdLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImNsaVwiLFxuICAgIFwicnVzdFwiLFxuICAgIFwibmFwaVwiLFxuICAgIFwibi1hcGlcIixcbiAgICBcIm5vZGUtYXBpXCIsXG4gICAgXCJub2RlLWFkZG9uXCIsXG4gICAgXCJuZW9uXCJcbiAgXSxcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwiTG9uZ1lpbmFuXCIsXG4gICAgICBcImVtYWlsXCI6IFwibHlud2VrbG1AZ21haWwuY29tXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0Jyb29vb29va2x5blwiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJmb3JlaGFsb1wiLFxuICAgICAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9mb3JlaGFsb1wiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL25hcGktcnMuZ2l0XCJcbiAgfSxcbiAgXCJwdWJsaXNoQ29uZmlnXCI6IHtcbiAgICBcInJlZ2lzdHJ5XCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXCIsXG4gICAgXCJhY2Nlc3NcIjogXCJwdWJsaWNcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAaW5xdWlyZXIvcHJvbXB0c1wiOiBcIl43LjguNFwiLFxuICAgIFwiQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluXCI6IFwiXjEuMC4zXCIsXG4gICAgXCJAbmFwaS1ycy93YXNtLXRvb2xzXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJAb2N0b2tpdC9yZXN0XCI6IFwiXjIyLjAuMFwiLFxuICAgIFwiY2xpcGFuaW9uXCI6IFwiXjQuMC4wLXJjLjRcIixcbiAgICBcImNvbG9yZXR0ZVwiOiBcIl4yLjAuMjBcIixcbiAgICBcImRlYnVnXCI6IFwiXjQuNC4xXCIsXG4gICAgXCJlbW5hcGlcIjogXCJeMS41LjBcIixcbiAgICBcImVzLXRvb2xraXRcIjogXCJeMS4zOS4xMFwiLFxuICAgIFwianMteWFtbFwiOiBcIl40LjEuMFwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjcuNy4yXCIsXG4gICAgXCJ0eXBhbmlvblwiOiBcIl4zLjE0LjBcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS41LjBcIixcbiAgICBcIkBveGMtbm9kZS9jb3JlXCI6IFwiXjAuMC4zMlwiLFxuICAgIFwiQHN0ZC90b21sXCI6IFwibnBtOkBqc3Ivc3RkX190b21sQF4xLjAuMTBcIixcbiAgICBcIkB0eXBlcy9kZWJ1Z1wiOiBcIl40LjEuMTJcIixcbiAgICBcIkB0eXBlcy9pbnF1aXJlclwiOiBcIl45LjAuOVwiLFxuICAgIFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjlcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjI0LjMuMVwiLFxuICAgIFwiQHR5cGVzL3NlbXZlclwiOiBcIl43LjcuMVwiLFxuICAgIFwiYXZhXCI6IFwiXjYuNC4xXCIsXG4gICAgXCJlbXBhdGhpY1wiOiBcIl4yLjAuMFwiLFxuICAgIFwiZW52LXBhdGhzXCI6IFwiXjMuMC4wXCIsXG4gICAgXCJwcmV0dGllclwiOiBcIl4zLjYuMlwiLFxuICAgIFwidHNkb3duXCI6IFwiXjAuMTUuMFwiLFxuICAgIFwidHNsaWJcIjogXCJeMi44LjFcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCJeNS45LjJcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IFwiXjEuNS4wXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzTWV0YVwiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjoge1xuICAgICAgXCJvcHRpb25hbFwiOiB0cnVlXG4gICAgfSxcbiAgICBcImVtbmFwaVwiOiB7XG4gICAgICBcIm9wdGlvbmFsXCI6IHRydWVcbiAgICB9XG4gIH0sXG4gIFwiZnVuZGluZ1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0aHViXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc3BvbnNvcnMvQnJvb29vb29rbHluXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImNvZGVnZW5cIjogXCJub2RlIC0taW1wb3J0IEBveGMtbm9kZS9jb3JlL3JlZ2lzdGVyIC4vY29kZWdlbi9pbmRleC50c1wiLFxuICAgIFwiYnVpbGRcIjogXCJ0c2Rvd25cIixcbiAgICBcInRlc3RcIjogXCJub2RlIC0taW1wb3J0IEBveGMtbm9kZS9jb3JlL3JlZ2lzdGVyIC4uL25vZGVfbW9kdWxlcy9hdmEvZW50cnlwb2ludHMvY2xpLm1qc1wiXG4gIH0sXG4gIFwiYXZhXCI6IHtcbiAgICBcImV4dGVuc2lvbnNcIjoge1xuICAgICAgXCJ0c1wiOiBcIm1vZHVsZVwiXG4gICAgfSxcbiAgICBcInRpbWVvdXRcIjogXCIybVwiLFxuICAgIFwid29ya2VyVGhyZWFkc1wiOiBmYWxzZSxcbiAgICBcImZpbGVzXCI6IFtcbiAgICAgIFwiKiovX190ZXN0c19fLyoqLyouc3BlYy50c1wiLFxuICAgICAgXCJlMmUvKiovKi5zcGVjLnRzXCJcbiAgICBdXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIHJlYWRGaWxlLFxuICB3cml0ZUZpbGUsXG4gIHVubGluayxcbiAgY29weUZpbGUsXG4gIG1rZGlyLFxuICBzdGF0LFxuICByZWFkZGlyLFxuICBhY2Nlc3MsXG59IGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnXG5cbmltcG9ydCBwa2dKc29uIGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbicgd2l0aCB7IHR5cGU6ICdqc29uJyB9XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4vbG9nLmpzJ1xuXG5leHBvcnQgY29uc3QgcmVhZEZpbGVBc3luYyA9IHJlYWRGaWxlXG5leHBvcnQgY29uc3Qgd3JpdGVGaWxlQXN5bmMgPSB3cml0ZUZpbGVcbmV4cG9ydCBjb25zdCB1bmxpbmtBc3luYyA9IHVubGlua1xuZXhwb3J0IGNvbnN0IGNvcHlGaWxlQXN5bmMgPSBjb3B5RmlsZVxuZXhwb3J0IGNvbnN0IG1rZGlyQXN5bmMgPSBta2RpclxuZXhwb3J0IGNvbnN0IHN0YXRBc3luYyA9IHN0YXRcbmV4cG9ydCBjb25zdCByZWFkZGlyQXN5bmMgPSByZWFkZGlyXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICByZXR1cm4gYWNjZXNzKHBhdGgpLnRoZW4oXG4gICAgKCkgPT4gdHJ1ZSxcbiAgICAoKSA9PiBmYWxzZSxcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlyRXhpc3RzQXN5bmMocGF0aDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBzdGF0QXN5bmMocGF0aClcbiAgICByZXR1cm4gc3RhdHMuaXNEaXJlY3RvcnkoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljazxPLCBLIGV4dGVuZHMga2V5b2YgTz4obzogTywgLi4ua2V5czogS1tdKTogUGljazxPLCBLPiB7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IG9ba2V5XVxuICAgIHJldHVybiBhY2NcbiAgfSwge30gYXMgTylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhY2thZ2VKc29uKFxuICBwYXRoOiBzdHJpbmcsXG4gIHBhcnRpYWw6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pIHtcbiAgY29uc3QgZXhpc3RzID0gYXdhaXQgZmlsZUV4aXN0cyhwYXRoKVxuICBpZiAoIWV4aXN0cykge1xuICAgIGRlYnVnKGBGaWxlIG5vdCBleGlzdHMgJHtwYXRofWApXG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgb2xkID0gSlNPTi5wYXJzZShhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JykpXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHBhdGgsIEpTT04uc3RyaW5naWZ5KHsgLi4ub2xkLCAuLi5wYXJ0aWFsIH0sIG51bGwsIDIpKVxufVxuXG5leHBvcnQgY29uc3QgQ0xJX1ZFUlNJT04gPSBwa2dKc29uLnZlcnNpb25cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5leHBvcnQgdHlwZSBQbGF0Zm9ybSA9IE5vZGVKUy5QbGF0Zm9ybSB8ICd3YXNtJyB8ICd3YXNpJyB8ICdvcGVuaGFybW9ueSdcblxuZXhwb3J0IGNvbnN0IFVOSVZFUlNBTF9UQVJHRVRTID0ge1xuICAndW5pdmVyc2FsLWFwcGxlLWRhcndpbic6IFsnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLCAneDg2XzY0LWFwcGxlLWRhcndpbiddLFxufSBhcyBjb25zdFxuXG5jb25zdCBTVUJfU1lTVEVNUyA9IG5ldyBTZXQoWydhbmRyb2lkJywgJ29ob3MnXSlcblxuZXhwb3J0IGNvbnN0IEFWQUlMQUJMRV9UQVJHRVRTID0gW1xuICAnYWFyY2g2NC1hcHBsZS1kYXJ3aW4nLFxuICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW9ob3MnLFxuICAnYWFyY2g2NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLWdudScsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1vaG9zJyxcbiAgJ3g4Nl82NC11bmtub3duLWZyZWVic2QnLFxuICAnaTY4Ni1wYy13aW5kb3dzLW1zdmMnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1nbnVlYWJpaGYnLFxuICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgJ3VuaXZlcnNhbC1hcHBsZS1kYXJ3aW4nLFxuICAnbG9vbmdhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgJ3Bvd2VycGM2NGxlLXVua25vd24tbGludXgtZ251JyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgJ3dhc20zMi13YXNpLXByZXZpZXcxLXRocmVhZHMnLFxuICAnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgVGFyZ2V0VHJpcGxlID0gKHR5cGVvZiBBVkFJTEFCTEVfVEFSR0VUUylbbnVtYmVyXVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UQVJHRVRTID0gW1xuICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG5dIGFzIGNvbnN0XG5cbmV4cG9ydCBjb25zdCBUQVJHRVRfTElOS0VSOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnOiAnYWFyY2g2NC1saW51eC1tdXNsLWdjYycsXG4gIC8vIFRPRE86IFN3aXRjaCB0byBsb29uZ2FyY2g2NC1saW51eC1nbnUtZ2NjIHdoZW4gYXZhaWxhYmxlXG4gICdsb29uZ2FyY2g2NC11bmtub3duLWxpbnV4LWdudSc6ICdsb29uZ2FyY2g2NC1saW51eC1nbnUtZ2NjLTEzJyxcbiAgJ3Jpc2N2NjRnYy11bmtub3duLWxpbnV4LWdudSc6ICdyaXNjdjY0LWxpbnV4LWdudS1nY2MnLFxuICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnOiAncG93ZXJwYzY0bGUtbGludXgtZ251LWdjYycsXG4gICdzMzkweC11bmtub3duLWxpbnV4LWdudSc6ICdzMzkweC1saW51eC1nbnUtZ2NjJyxcbn1cblxuLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2FyY2hcbnR5cGUgTm9kZUpTQXJjaCA9XG4gIHwgJ2FybSdcbiAgfCAnYXJtNjQnXG4gIHwgJ2lhMzInXG4gIHwgJ2xvb25nNjQnXG4gIHwgJ21pcHMnXG4gIHwgJ21pcHNlbCdcbiAgfCAncHBjJ1xuICB8ICdwcGM2NCdcbiAgfCAncmlzY3Y2NCdcbiAgfCAnczM5MCdcbiAgfCAnczM5MHgnXG4gIHwgJ3gzMidcbiAgfCAneDY0J1xuICB8ICd1bml2ZXJzYWwnXG4gIHwgJ3dhc20zMidcblxuY29uc3QgQ3B1VG9Ob2RlQXJjaDogUmVjb3JkPHN0cmluZywgTm9kZUpTQXJjaD4gPSB7XG4gIHg4Nl82NDogJ3g2NCcsXG4gIGFhcmNoNjQ6ICdhcm02NCcsXG4gIGk2ODY6ICdpYTMyJyxcbiAgYXJtdjc6ICdhcm0nLFxuICBsb29uZ2FyY2g2NDogJ2xvb25nNjQnLFxuICByaXNjdjY0Z2M6ICdyaXNjdjY0JyxcbiAgcG93ZXJwYzY0bGU6ICdwcGM2NCcsXG59XG5cbmV4cG9ydCBjb25zdCBOb2RlQXJjaFRvQ3B1OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICB4NjQ6ICd4ODZfNjQnLFxuICBhcm02NDogJ2FhcmNoNjQnLFxuICBpYTMyOiAnaTY4NicsXG4gIGFybTogJ2FybXY3JyxcbiAgbG9vbmc2NDogJ2xvb25nYXJjaDY0JyxcbiAgcmlzY3Y2NDogJ3Jpc2N2NjRnYycsXG4gIHBwYzY0OiAncG93ZXJwYzY0bGUnLFxufVxuXG5jb25zdCBTeXNUb05vZGVQbGF0Zm9ybTogUmVjb3JkPHN0cmluZywgUGxhdGZvcm0+ID0ge1xuICBsaW51eDogJ2xpbnV4JyxcbiAgZnJlZWJzZDogJ2ZyZWVic2QnLFxuICBkYXJ3aW46ICdkYXJ3aW4nLFxuICB3aW5kb3dzOiAnd2luMzInLFxuICBvaG9zOiAnb3Blbmhhcm1vbnknLFxufVxuXG5leHBvcnQgY29uc3QgVW5pQXJjaHNCeVBsYXRmb3JtOiBQYXJ0aWFsPFJlY29yZDxQbGF0Zm9ybSwgTm9kZUpTQXJjaFtdPj4gPSB7XG4gIGRhcndpbjogWyd4NjQnLCAnYXJtNjQnXSxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYXJnZXQge1xuICB0cmlwbGU6IHN0cmluZ1xuICBwbGF0Zm9ybUFyY2hBQkk6IHN0cmluZ1xuICBwbGF0Zm9ybTogUGxhdGZvcm1cbiAgYXJjaDogTm9kZUpTQXJjaFxuICBhYmk6IHN0cmluZyB8IG51bGxcbn1cblxuLyoqXG4gKiBBIHRyaXBsZSBpcyBhIHNwZWNpZmljIGZvcm1hdCBmb3Igc3BlY2lmeWluZyBhIHRhcmdldCBhcmNoaXRlY3R1cmUuXG4gKiBUcmlwbGVzIG1heSBiZSByZWZlcnJlZCB0byBhcyBhIHRhcmdldCB0cmlwbGUgd2hpY2ggaXMgdGhlIGFyY2hpdGVjdHVyZSBmb3IgdGhlIGFydGlmYWN0IHByb2R1Y2VkLCBhbmQgdGhlIGhvc3QgdHJpcGxlIHdoaWNoIGlzIHRoZSBhcmNoaXRlY3R1cmUgdGhhdCB0aGUgY29tcGlsZXIgaXMgcnVubmluZyBvbi5cbiAqIFRoZSBnZW5lcmFsIGZvcm1hdCBvZiB0aGUgdHJpcGxlIGlzIGA8YXJjaD48c3ViPi08dmVuZG9yPi08c3lzPi08YWJpPmAgd2hlcmU6XG4gKiAgIC0gYGFyY2hgID0gVGhlIGJhc2UgQ1BVIGFyY2hpdGVjdHVyZSwgZm9yIGV4YW1wbGUgYHg4Nl82NGAsIGBpNjg2YCwgYGFybWAsIGB0aHVtYmAsIGBtaXBzYCwgZXRjLlxuICogICAtIGBzdWJgID0gVGhlIENQVSBzdWItYXJjaGl0ZWN0dXJlLCBmb3IgZXhhbXBsZSBgYXJtYCBoYXMgYHY3YCwgYHY3c2AsIGB2NXRlYCwgZXRjLlxuICogICAtIGB2ZW5kb3JgID0gVGhlIHZlbmRvciwgZm9yIGV4YW1wbGUgYHVua25vd25gLCBgYXBwbGVgLCBgcGNgLCBgbnZpZGlhYCwgZXRjLlxuICogICAtIGBzeXNgID0gVGhlIHN5c3RlbSBuYW1lLCBmb3IgZXhhbXBsZSBgbGludXhgLCBgd2luZG93c2AsIGBkYXJ3aW5gLCBldGMuIG5vbmUgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGJhcmUtbWV0YWwgd2l0aG91dCBhbiBPUy5cbiAqICAgLSBgYWJpYCA9IFRoZSBBQkksIGZvciBleGFtcGxlIGBnbnVgLCBgYW5kcm9pZGAsIGBlYWJpYCwgZXRjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmlwbGUocmF3VHJpcGxlOiBzdHJpbmcpOiBUYXJnZXQge1xuICBpZiAoXG4gICAgcmF3VHJpcGxlID09PSAnd2FzbTMyLXdhc2knIHx8XG4gICAgcmF3VHJpcGxlID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycgfHxcbiAgICByYXdUcmlwbGUuc3RhcnRzV2l0aCgnd2FzbTMyLXdhc2lwJylcbiAgKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgICAgcGxhdGZvcm1BcmNoQUJJOiAnd2FzbTMyLXdhc2knLFxuICAgICAgcGxhdGZvcm06ICd3YXNpJyxcbiAgICAgIGFyY2g6ICd3YXNtMzInLFxuICAgICAgYWJpOiAnd2FzaScsXG4gICAgfVxuICB9XG4gIGNvbnN0IHRyaXBsZSA9IHJhd1RyaXBsZS5lbmRzV2l0aCgnZWFiaScpXG4gICAgPyBgJHtyYXdUcmlwbGUuc2xpY2UoMCwgLTQpfS1lYWJpYFxuICAgIDogcmF3VHJpcGxlXG4gIGNvbnN0IHRyaXBsZXMgPSB0cmlwbGUuc3BsaXQoJy0nKVxuICBsZXQgY3B1OiBzdHJpbmdcbiAgbGV0IHN5czogc3RyaW5nXG4gIGxldCBhYmk6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gIGlmICh0cmlwbGVzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIGFhcmNoNjQtZnVjaHNpYVxuICAgIC8vIF4gY3B1ICAgXiBzeXNcbiAgICA7W2NwdSwgc3lzXSA9IHRyaXBsZXNcbiAgfSBlbHNlIHtcbiAgICAvLyBhYXJjaDY0LXVua25vd24tbGludXgtbXVzbFxuICAgIC8vIF4gY3B1ICAgXnZlbmRvciBeIHN5cyBeIGFiaVxuICAgIC8vIGFhcmNoNjQtYXBwbGUtZGFyd2luXG4gICAgLy8gXiBjcHUgICAgICAgICBeIHN5cyAgKGFiaSBpcyBOb25lKVxuICAgIDtbY3B1LCAsIHN5cywgYWJpID0gbnVsbF0gPSB0cmlwbGVzXG4gIH1cblxuICBpZiAoYWJpICYmIFNVQl9TWVNURU1TLmhhcyhhYmkpKSB7XG4gICAgc3lzID0gYWJpXG4gICAgYWJpID0gbnVsbFxuICB9XG4gIGNvbnN0IHBsYXRmb3JtID0gU3lzVG9Ob2RlUGxhdGZvcm1bc3lzXSA/PyAoc3lzIGFzIFBsYXRmb3JtKVxuICBjb25zdCBhcmNoID0gQ3B1VG9Ob2RlQXJjaFtjcHVdID8/IChjcHUgYXMgTm9kZUpTQXJjaClcblxuICByZXR1cm4ge1xuICAgIHRyaXBsZTogcmF3VHJpcGxlLFxuICAgIHBsYXRmb3JtQXJjaEFCSTogYWJpID8gYCR7cGxhdGZvcm19LSR7YXJjaH0tJHthYml9YCA6IGAke3BsYXRmb3JtfS0ke2FyY2h9YCxcbiAgICBwbGF0Zm9ybSxcbiAgICBhcmNoLFxuICAgIGFiaSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpOiBUYXJnZXQge1xuICBjb25zdCBob3N0ID0gZXhlY1N5bmMoYHJ1c3RjIC12VmAsIHtcbiAgICBlbnY6IHByb2Nlc3MuZW52LFxuICB9KVxuICAgIC50b1N0cmluZygndXRmOCcpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2hvc3Q6ICcpKVxuICBjb25zdCB0cmlwbGUgPSBob3N0Py5zbGljZSgnaG9zdDogJy5sZW5ndGgpXG4gIGlmICghdHJpcGxlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ2FuIG5vdCBwYXJzZSB0YXJnZXQgdHJpcGxlIGZyb20gaG9zdGApXG4gIH1cbiAgcmV0dXJuIHBhcnNlVHJpcGxlKHRyaXBsZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRhcmdldExpbmtlcih0YXJnZXQ6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBUQVJHRVRfTElOS0VSW3RhcmdldF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvRW52VmFyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRhcmdldC5yZXBsYWNlKC8tL2csICdfJykudG9VcHBlckNhc2UoKVxufVxuIiwiZXhwb3J0IGVudW0gTmFwaVZlcnNpb24ge1xuICBOYXBpMSA9IDEsXG4gIE5hcGkyLFxuICBOYXBpMyxcbiAgTmFwaTQsXG4gIE5hcGk1LFxuICBOYXBpNixcbiAgTmFwaTcsXG4gIE5hcGk4LFxuICBOYXBpOSxcbn1cblxuLy8vIGJlY2F1c2Ugbm9kZSBzdXBwb3J0IG5ldyBuYXBpIHZlcnNpb24gaW4gc29tZSBtaW5vciB2ZXJzaW9uIHVwZGF0ZXMsIHNvIHdlIG1pZ2h0IG1lZXQgc3VjaCBzaXR1YXRpb246XG4vLy8gYG5vZGUgdjEwLjIwLjBgIHN1cHBvcnRzIGBuYXBpNWAgYW5kIGBuYXBpNmAsIGJ1dCBgbm9kZSB2MTIuMC4wYCBvbmx5IHN1cHBvcnQgYG5hcGk0YCxcbi8vLyBieSB3aGljaCwgd2UgY2FuIG5vdCB0ZWxsIGRpcmVjdGx5IG5hcGkgdmVyc2lvbiBzdXBwb3J0bGVzcyBmcm9tIG5vZGUgdmVyc2lvbiBkaXJlY3RseS5cbmNvbnN0IE5BUElfVkVSU0lPTl9NQVRSSVggPSBuZXcgTWFwPE5hcGlWZXJzaW9uLCBzdHJpbmc+KFtcbiAgW05hcGlWZXJzaW9uLk5hcGkxLCAnOC42LjAgfCA5LjAuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTIsICc4LjEwLjAgfCA5LjMuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTMsICc2LjE0LjIgfCA4LjExLjIgfCA5LjExLjAgfCAxMC4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk0LCAnMTAuMTYuMCB8IDExLjguMCB8IDEyLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTUsICcxMC4xNy4wIHwgMTIuMTEuMCB8IDEzLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTYsICcxMC4yMC4wIHwgMTIuMTcuMCB8IDE0LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTcsICcxMC4yMy4wIHwgMTIuMTkuMCB8IDE0LjEyLjAgfCAxNS4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk4LCAnMTIuMjIuMCB8IDE0LjE3LjAgfCAxNS4xMi4wIHwgMTYuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpOSwgJzE4LjE3LjAgfCAyMC4zLjAgfCAyMS4xLjAnXSxcbl0pXG5cbmludGVyZmFjZSBOb2RlVmVyc2lvbiB7XG4gIG1ham9yOiBudW1iZXJcbiAgbWlub3I6IG51bWJlclxuICBwYXRjaDogbnVtYmVyXG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9kZVZlcnNpb24odjogc3RyaW5nKTogTm9kZVZlcnNpb24ge1xuICBjb25zdCBtYXRjaGVzID0gdi5tYXRjaCgvdj8oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykvaSlcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB2ZXJzaW9uIG51bWJlcjogJyArIHYpXG4gIH1cblxuICBjb25zdCBbLCBtYWpvciwgbWlub3IsIHBhdGNoXSA9IG1hdGNoZXNcblxuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJzZUludChtYWpvciksXG4gICAgbWlub3I6IHBhcnNlSW50KG1pbm9yKSxcbiAgICBwYXRjaDogcGFyc2VJbnQocGF0Y2gpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IE5vZGVWZXJzaW9uW10ge1xuICBjb25zdCByZXF1aXJlbWVudCA9IE5BUElfVkVSU0lPTl9NQVRSSVguZ2V0KG5hcGlWZXJzaW9uKVxuXG4gIGlmICghcmVxdWlyZW1lbnQpIHtcbiAgICByZXR1cm4gW3BhcnNlTm9kZVZlcnNpb24oJzEwLjAuMCcpXVxuICB9XG5cbiAgcmV0dXJuIHJlcXVpcmVtZW50LnNwbGl0KCd8JykubWFwKHBhcnNlTm9kZVZlcnNpb24pXG59XG5cbmZ1bmN0aW9uIHRvRW5naW5lUmVxdWlyZW1lbnQodmVyc2lvbnM6IE5vZGVWZXJzaW9uW10pOiBzdHJpbmcge1xuICBjb25zdCByZXF1aXJlbWVudHM6IHN0cmluZ1tdID0gW11cbiAgdmVyc2lvbnMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgIGxldCByZXEgPSAnJ1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBsYXN0VmVyc2lvbiA9IHZlcnNpb25zW2kgLSAxXVxuICAgICAgcmVxICs9IGA8ICR7bGFzdFZlcnNpb24ubWFqb3IgKyAxfWBcbiAgICB9XG5cbiAgICByZXEgKz0gYCR7aSA9PT0gMCA/ICcnIDogJyB8fCAnfT49ICR7di5tYWpvcn0uJHt2Lm1pbm9yfS4ke3YucGF0Y2h9YFxuICAgIHJlcXVpcmVtZW50cy5wdXNoKHJlcSlcbiAgfSlcblxuICByZXR1cm4gcmVxdWlyZW1lbnRzLmpvaW4oJyAnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG5hcGlWZXJzaW9uOiBOYXBpVmVyc2lvbik6IHN0cmluZyB7XG4gIHJldHVybiB0b0VuZ2luZVJlcXVpcmVtZW50KHJlcXVpcmVkTm9kZVZlcnNpb25zKG5hcGlWZXJzaW9uKSlcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IGZzIGZyb20gJ25vZGU6ZnMnXG5cbmV4cG9ydCB0eXBlIENyYXRlVGFyZ2V0S2luZCA9XG4gIHwgJ2JpbidcbiAgfCAnZXhhbXBsZSdcbiAgfCAndGVzdCdcbiAgfCAnYmVuY2gnXG4gIHwgJ2xpYidcbiAgfCAncmxpYidcbiAgfCAnY2R5bGliJ1xuICB8ICdjdXN0b20tYnVpbGQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGVUYXJnZXQge1xuICBuYW1lOiBzdHJpbmdcbiAga2luZDogQ3JhdGVUYXJnZXRLaW5kW11cbiAgY3JhdGVfdHlwZXM6IENyYXRlVGFyZ2V0S2luZFtdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JhdGUge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBzcmNfcGF0aDogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICBlZGl0aW9uOiBzdHJpbmdcbiAgdGFyZ2V0czogQ3JhdGVUYXJnZXRbXVxuICBmZWF0dXJlczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+XG4gIG1hbmlmZXN0X3BhdGg6IHN0cmluZ1xuICBkZXBlbmRlbmNpZXM6IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBzb3VyY2U6IHN0cmluZ1xuICAgIHJlcTogc3RyaW5nXG4gICAga2luZDogc3RyaW5nIHwgbnVsbFxuICAgIHJlbmFtZTogc3RyaW5nIHwgbnVsbFxuICAgIG9wdGlvbmFsOiBib29sZWFuXG4gICAgdXNlc19kZWZhdWx0X2ZlYXR1cmVzOiBib29sZWFuXG4gICAgZmVhdHVyZXM6IHN0cmluZ1tdXG4gICAgdGFyZ2V0OiBzdHJpbmcgfCBudWxsXG4gICAgcmVnaXN0cnk6IHN0cmluZyB8IG51bGxcbiAgfT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhIHtcbiAgdmVyc2lvbjogbnVtYmVyXG4gIHBhY2thZ2VzOiBDcmF0ZVtdXG4gIHdvcmtzcGFjZV9tZW1iZXJzOiBzdHJpbmdbXVxuICB0YXJnZXRfZGlyZWN0b3J5OiBzdHJpbmdcbiAgd29ya3NwYWNlX3Jvb3Q6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VNZXRhZGF0YShtYW5pZmVzdFBhdGg6IHN0cmluZykge1xuICBpZiAoIWZzLmV4aXN0c1N5bmMobWFuaWZlc3RQYXRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gY3JhdGUgZm91bmQgaW4gbWFuaWZlc3Q6ICR7bWFuaWZlc3RQYXRofWApXG4gIH1cblxuICBjb25zdCBjaGlsZFByb2Nlc3MgPSBzcGF3bihcbiAgICAnY2FyZ28nLFxuICAgIFsnbWV0YWRhdGEnLCAnLS1tYW5pZmVzdC1wYXRoJywgbWFuaWZlc3RQYXRoLCAnLS1mb3JtYXQtdmVyc2lvbicsICcxJ10sXG4gICAgeyBzdGRpbzogJ3BpcGUnIH0sXG4gIClcblxuICBsZXQgc3Rkb3V0ID0gJydcbiAgbGV0IHN0ZGVyciA9ICcnXG4gIGxldCBzdGF0dXMgPSAwXG4gIGxldCBlcnJvciA9IG51bGxcblxuICBjaGlsZFByb2Nlc3Muc3Rkb3V0Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICBzdGRvdXQgKz0gZGF0YVxuICB9KVxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRlcnIub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZGVyciArPSBkYXRhXG4gIH0pXG5cbiAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjaGlsZFByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGUpID0+IHtcbiAgICAgIHN0YXR1cyA9IGNvZGUgPz8gMFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhcmdvIG1ldGFkYXRhIGZhaWxlZCB0byBydW4nLCB7IGNhdXNlOiBlcnJvciB9KVxuICB9XG4gIGlmIChzdGF0dXMgIT09IDApIHtcbiAgICBjb25zdCBzaW1wbGVNZXNzYWdlID0gYGNhcmdvIG1ldGFkYXRhIGV4aXRlZCB3aXRoIGNvZGUgJHtzdGF0dXN9YFxuICAgIHRocm93IG5ldyBFcnJvcihgJHtzaW1wbGVNZXNzYWdlfSBhbmQgZXJyb3IgbWVzc2FnZTpcXG5cXG4ke3N0ZGVycn1gLCB7XG4gICAgICBjYXVzZTogbmV3IEVycm9yKHNpbXBsZU1lc3NhZ2UpLFxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0ZG91dCkgYXMgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgY2FyZ28gbWV0YWRhdGEgSlNPTicsIHsgY2F1c2U6IGUgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgdW5kZXJsaW5lLCB5ZWxsb3cgfSBmcm9tICdjb2xvcmV0dGUnXG5pbXBvcnQgeyBtZXJnZSwgb21pdCB9IGZyb20gJ2VzLXRvb2xraXQnXG5cbmltcG9ydCB7IGZpbGVFeGlzdHMsIHJlYWRGaWxlQXN5bmMgfSBmcm9tICcuL21pc2MuanMnXG5pbXBvcnQgeyBERUZBVUxUX1RBUkdFVFMsIHBhcnNlVHJpcGxlLCB0eXBlIFRhcmdldCB9IGZyb20gJy4vdGFyZ2V0LmpzJ1xuXG5leHBvcnQgdHlwZSBWYWx1ZU9mQ29uc3RBcnJheTxUPiA9IFRbRXhjbHVkZTxrZXlvZiBULCBrZXlvZiBBcnJheTxhbnk+Pl1cblxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VycyA9IFsneWFybicsICdwbnBtJ10gYXMgY29uc3RcbmV4cG9ydCBjb25zdCBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrcyA9IFsnYXZhJ10gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIgPSBWYWx1ZU9mQ29uc3RBcnJheTxcbiAgdHlwZW9mIFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2Vyc1xuPlxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkVGVzdEZyYW1ld29yayA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkVGVzdEZyYW1ld29ya3Ncbj5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyTmFwaUNvbmZpZyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBiaW5hcnkgdG8gYmUgZ2VuZXJhdGVkLCBkZWZhdWx0IHRvIGBpbmRleGBcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG5wbSBwYWNrYWdlLCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHJvb3QgcGFja2FnZS5qc29uIG5hbWVcbiAgICpcbiAgICogQWx3YXlzIGdpdmVuIGBAc2NvcGUvcGtnYCBhbmQgYXJjaCBzdWZmaXggd2lsbCBiZSBhcHBlbmRlZCBsaWtlIGBAc2NvcGUvcGtnLWxpbnV4LWdudS14NjRgXG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIHRhcmdldHMgdGhlIGNyYXRlIHdpbGwgYmUgY29tcGlsZWQgZm9yXG4gICAqL1xuICB0YXJnZXRzPzogc3RyaW5nW11cblxuICAvKipcbiAgICogVGhlIG5wbSBjbGllbnQgcHJvamVjdCB1c2VzLlxuICAgKi9cbiAgbnBtQ2xpZW50Pzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZ2VuZXJhdGUgY29uc3QgZW51bSBmb3IgdHlwZXNjcmlwdCBiaW5kaW5nc1xuICAgKi9cbiAgY29uc3RFbnVtPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBkdHMgaGVhZGVyIHByZXBlbmQgdG8gdGhlIGdlbmVyYXRlZCBkdHMgZmlsZVxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgZmlsZSBwYXRoIHRvIGJlIHByZXBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqIGlmIGJvdGggZHRzSGVhZGVyIGFuZCBkdHNIZWFkZXJGaWxlIGFyZSBwcm92aWRlZCwgZHRzSGVhZGVyRmlsZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIGR0c0hlYWRlckZpbGU/OiBzdHJpbmdcblxuICAvKipcbiAgICogd2FzbSBjb21waWxhdGlvbiBvcHRpb25zXG4gICAqL1xuICB3YXNtPzoge1xuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViQXNzZW1ibHkvSmF2YVNjcmlwdF9pbnRlcmZhY2UvTWVtb3J5XG4gICAgICogQGRlZmF1bHQgNDAwMCBwYWdlcyAoMjU2TWlCKVxuICAgICAqL1xuICAgIGluaXRpYWxNZW1vcnk/OiBudW1iZXJcbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCA2NTUzNiBwYWdlcyAoNEdpQilcbiAgICAgKi9cbiAgICBtYXhpbXVtTWVtb3J5PzogbnVtYmVyXG5cbiAgICAvKipcbiAgICAgKiBCcm93c2VyIHdhc20gYmluZGluZyBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYnJvd3Nlcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIHVzZSBmcyBtb2R1bGUgaW4gYnJvd3NlclxuICAgICAgICovXG4gICAgICBmcz86IGJvb2xlYW5cbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byBpbml0aWFsaXplIHdhc20gYXN5bmNocm9ub3VzbHlcbiAgICAgICAqL1xuICAgICAgYXN5bmNJbml0PzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluamVjdCBgYnVmZmVyYCB0byBlbW5hcGkgY29udGV4dFxuICAgICAgICovXG4gICAgICBidWZmZXI/OiBib29sZWFuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGJpbmFyeU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHBhY2thZ2VOYW1lIGluc3RlYWRcbiAgICovXG4gIHBhY2thZ2U/OiB7XG4gICAgbmFtZT86IHN0cmluZ1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgdGFyZ2V0cyBpbnN0ZWFkXG4gICAqL1xuICB0cmlwbGVzPzoge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0c1xuICAgICAqL1xuICAgIGRlZmF1bHRzOiBib29sZWFuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCB0YXJnZXRzIHRvIGJlIGNvbXBpbGVkIGZvclxuICAgICAqL1xuICAgIGFkZGl0aW9uYWw/OiBzdHJpbmdbXVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMge1xuICBuYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gIGtleXdvcmRzPzogc3RyaW5nW11cbiAgYXV0aG9yPzogc3RyaW5nXG4gIGF1dGhvcnM/OiBzdHJpbmdbXVxuICBsaWNlbnNlPzogc3RyaW5nXG4gIGNwdT86IHN0cmluZ1tdXG4gIG9zPzogc3RyaW5nW11cbiAgbGliYz86IHN0cmluZ1tdXG4gIGZpbGVzPzogc3RyaW5nW11cbiAgcmVwb3NpdG9yeT86IGFueVxuICBob21lcGFnZT86IGFueVxuICBlbmdpbmVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBwdWJsaXNoQ29uZmlnPzogYW55XG4gIGJ1Z3M/OiBhbnlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIG5hcGk/OiBVc2VyTmFwaUNvbmZpZ1xuICB0eXBlPzogJ21vZHVsZScgfCAnY29tbW9uanMnXG4gIHNjcmlwdHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cbiAgLy8gbW9kdWxlc1xuICBtYWluPzogc3RyaW5nXG4gIG1vZHVsZT86IHN0cmluZ1xuICB0eXBlcz86IHN0cmluZ1xuICBicm93c2VyPzogc3RyaW5nXG4gIGV4cG9ydHM/OiBhbnlcblxuICBkZXBlbmRlbmNpZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIGRldkRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICBhdmE/OiB7XG4gICAgdGltZW91dD86IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIE5hcGlDb25maWcgPSBSZXF1aXJlZDxcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ2JpbmFyeU5hbWUnIHwgJ3BhY2thZ2VOYW1lJyB8ICducG1DbGllbnQnPlxuPiAmXG4gIFBpY2s8VXNlck5hcGlDb25maWcsICd3YXNtJyB8ICdkdHNIZWFkZXInIHwgJ2R0c0hlYWRlckZpbGUnIHwgJ2NvbnN0RW51bSc+ICYge1xuICAgIHRhcmdldHM6IFRhcmdldFtdXG4gICAgcGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzXG4gIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWROYXBpQ29uZmlnKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcsXG4pOiBQcm9taXNlPE5hcGlDb25maWc+IHtcbiAgaWYgKGNvbmZpZ1BhdGggJiYgIShhd2FpdCBmaWxlRXhpc3RzKGNvbmZpZ1BhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTkFQSS1SUyBjb25maWcgbm90IGZvdW5kIGF0ICR7Y29uZmlnUGF0aH1gKVxuICB9XG4gIGlmICghKGF3YWl0IGZpbGVFeGlzdHMocGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYWNrYWdlLmpzb24gbm90IGZvdW5kIGF0ICR7cGF0aH1gKVxuICB9XG4gIC8vIE1heSBzdXBwb3J0IG11bHRpcGxlIGNvbmZpZyBzb3VyY2VzIGxhdGVyIG9uLlxuICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYXRoLCAndXRmOCcpXG4gIGxldCBwa2dKc29uXG4gIHRyeSB7XG4gICAgcGtnSnNvbiA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHBhY2thZ2UuanNvbiBhdCAke3BhdGh9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxuXG4gIGxldCBzZXBhcmF0ZWRDb25maWc6IFVzZXJOYXBpQ29uZmlnIHwgdW5kZWZpbmVkXG4gIGlmIChjb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY29uZmlnUGF0aCwgJ3V0ZjgnKVxuICAgIHRyeSB7XG4gICAgICBzZXBhcmF0ZWRDb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0NvbnRlbnQpIGFzIFVzZXJOYXBpQ29uZmlnXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgTkFQSS1SUyBjb25maWcgYXQgJHtjb25maWdQYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVzZXJOYXBpQ29uZmlnID0gcGtnSnNvbi5uYXBpID8/IHt9XG4gIGlmIChwa2dKc29uLm5hcGkgJiYgc2VwYXJhdGVkQ29uZmlnKSB7XG4gICAgY29uc3QgcGtnSnNvblBhdGggPSB1bmRlcmxpbmUocGF0aClcbiAgICBjb25zdCBjb25maWdQYXRoVW5kZXJsaW5lID0gdW5kZXJsaW5lKGNvbmZpZ1BhdGghKVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIHllbGxvdyhcbiAgICAgICAgYEJvdGggbmFwaSBmaWVsZCBpbiAke3BrZ0pzb25QYXRofSBhbmQgW05BUEktUlMgY29uZmlnXSgke2NvbmZpZ1BhdGhVbmRlcmxpbmV9KSBmaWxlIGFyZSBmb3VuZCwgdGhlIE5BUEktUlMgY29uZmlnIGZpbGUgd2lsbCBiZSB1c2VkLmAsXG4gICAgICApLFxuICAgIClcbiAgICBPYmplY3QuYXNzaWduKHVzZXJOYXBpQ29uZmlnLCBzZXBhcmF0ZWRDb25maWcpXG4gIH1cbiAgY29uc3QgbmFwaUNvbmZpZzogTmFwaUNvbmZpZyA9IG1lcmdlKFxuICAgIHtcbiAgICAgIGJpbmFyeU5hbWU6ICdpbmRleCcsXG4gICAgICBwYWNrYWdlTmFtZTogcGtnSnNvbi5uYW1lLFxuICAgICAgdGFyZ2V0czogW10sXG4gICAgICBwYWNrYWdlSnNvbjogcGtnSnNvbixcbiAgICAgIG5wbUNsaWVudDogJ25wbScsXG4gICAgfSxcbiAgICBvbWl0KHVzZXJOYXBpQ29uZmlnLCBbJ3RhcmdldHMnXSksXG4gIClcblxuICBsZXQgdGFyZ2V0czogc3RyaW5nW10gPSB1c2VyTmFwaUNvbmZpZy50YXJnZXRzID8/IFtdXG5cbiAgLy8gY29tcGF0aWJsZSB3aXRoIG9sZCBjb25maWdcbiAgaWYgKHVzZXJOYXBpQ29uZmlnPy5uYW1lKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgW0RFUFJFQ0FURURdIG5hcGkubmFtZSBpcyBkZXByZWNhdGVkLCB1c2UgbmFwaS5iaW5hcnlOYW1lIGluc3RlYWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIG5hcGlDb25maWcuYmluYXJ5TmFtZSA9IHVzZXJOYXBpQ29uZmlnLm5hbWVcbiAgfVxuXG4gIGlmICghdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICBsZXQgZGVwcmVjYXRlZFdhcm5lZCA9IGZhbHNlXG4gICAgY29uc3Qgd2FybmluZyA9IHllbGxvdyhcbiAgICAgIGBbREVQUkVDQVRFRF0gbmFwaS50cmlwbGVzIGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXBpLnRhcmdldHMgaW5zdGVhZC5gLFxuICAgIClcbiAgICBpZiAodXNlck5hcGlDb25maWcudHJpcGxlcz8uZGVmYXVsdHMpIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuZWQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChERUZBVUxUX1RBUkdFVFMpXG4gICAgfVxuXG4gICAgaWYgKHVzZXJOYXBpQ29uZmlnLnRyaXBsZXM/LmFkZGl0aW9uYWw/Lmxlbmd0aCkge1xuICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHVzZXJOYXBpQ29uZmlnLnRyaXBsZXMuYWRkaXRpb25hbClcbiAgICAgIGlmICghZGVwcmVjYXRlZFdhcm5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGR1cGxpY2F0ZSB0YXJnZXRzXG4gIGNvbnN0IHVuaXF1ZVRhcmdldHMgPSBuZXcgU2V0KHRhcmdldHMpXG4gIGlmICh1bmlxdWVUYXJnZXRzLnNpemUgIT09IHRhcmdldHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZHVwbGljYXRlVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKFxuICAgICAgKHRhcmdldCwgaW5kZXgpID0+IHRhcmdldHMuaW5kZXhPZih0YXJnZXQpICE9PSBpbmRleCxcbiAgICApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdGFyZ2V0cyBhcmUgbm90IGFsbG93ZWQ6ICR7ZHVwbGljYXRlVGFyZ2V0fWApXG4gIH1cblxuICBuYXBpQ29uZmlnLnRhcmdldHMgPSB0YXJnZXRzLm1hcChwYXJzZVRyaXBsZSlcblxuICByZXR1cm4gbmFwaUNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2cuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkobmFtZTogc3RyaW5nLCBiaW46IHN0cmluZykge1xuICBpZiAoZGV0ZWN0Q2FyZ29CaW5hcnkoYmluKSkge1xuICAgIGRlYnVnKCdDYXJnbyBiaW5hcnkgYWxyZWFkeSBpbnN0YWxsZWQ6ICVzJywgbmFtZSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVidWcoJ0luc3RhbGxpbmcgY2FyZ28gYmluYXJ5OiAlcycsIG5hbWUpXG4gICAgZXhlY1N5bmMoYGNhcmdvIGluc3RhbGwgJHtuYW1lfWAsIHtcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluc3RhbGwgY2FyZ28gYmluYXJ5OiAke25hbWV9YCwge1xuICAgICAgY2F1c2U6IGUsXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3RDYXJnb0JpbmFyeShiaW46IHN0cmluZykge1xuICBkZWJ1ZygnRGV0ZWN0aW5nIGNhcmdvIGJpbmFyeTogJXMnLCBiaW4pXG4gIHRyeSB7XG4gICAgZXhlY1N5bmMoYGNhcmdvIGhlbHAgJHtiaW59YCwge1xuICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgIH0pXG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBkZXRlY3RlZDogJXMnLCBiaW4pXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBub3QgZGV0ZWN0ZWQ6ICVzJywgYmluKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCJpbXBvcnQgeyBzb3J0QnkgfSBmcm9tICdlcy10b29sa2l0J1xuXG5pbXBvcnQgeyByZWFkRmlsZUFzeW5jIH0gZnJvbSAnLi9taXNjLmpzJ1xuXG5jb25zdCBUT1BfTEVWRUxfTkFNRVNQQUNFID0gJ19fVE9QX0xFVkVMX01PRFVMRV9fJ1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVFlQRV9ERUZfSEVBREVSID0gYC8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG5gXG5cbmVudW0gVHlwZURlZktpbmQge1xuICBDb25zdCA9ICdjb25zdCcsXG4gIEVudW0gPSAnZW51bScsXG4gIFN0cmluZ0VudW0gPSAnc3RyaW5nX2VudW0nLFxuICBJbnRlcmZhY2UgPSAnaW50ZXJmYWNlJyxcbiAgVHlwZSA9ICd0eXBlJyxcbiAgRm4gPSAnZm4nLFxuICBTdHJ1Y3QgPSAnc3RydWN0JyxcbiAgRXh0ZW5kcyA9ICdleHRlbmRzJyxcbiAgSW1wbCA9ICdpbXBsJyxcbn1cblxuaW50ZXJmYWNlIFR5cGVEZWZMaW5lIHtcbiAga2luZDogVHlwZURlZktpbmRcbiAgbmFtZTogc3RyaW5nXG4gIG9yaWdpbmFsX25hbWU/OiBzdHJpbmdcbiAgZGVmOiBzdHJpbmdcbiAgZXh0ZW5kcz86IHN0cmluZ1xuICBqc19kb2M/OiBzdHJpbmdcbiAganNfbW9kPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHByZXR0eVByaW50KFxuICBsaW5lOiBUeXBlRGVmTGluZSxcbiAgY29uc3RFbnVtOiBib29sZWFuLFxuICBpZGVudDogbnVtYmVyLFxuICBhbWJpZW50ID0gZmFsc2UsXG4pOiBzdHJpbmcge1xuICBsZXQgcyA9IGxpbmUuanNfZG9jID8/ICcnXG4gIHN3aXRjaCAobGluZS5raW5kKSB7XG4gICAgY2FzZSBUeXBlRGVmS2luZC5JbnRlcmZhY2U6XG4gICAgICBzICs9IGBleHBvcnQgaW50ZXJmYWNlICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuVHlwZTpcbiAgICAgIHMgKz0gYGV4cG9ydCB0eXBlICR7bGluZS5uYW1lfSA9IFxcbiR7bGluZS5kZWZ9YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuRW51bTpcbiAgICAgIGNvbnN0IGVudW1OYW1lID0gY29uc3RFbnVtID8gJ2NvbnN0IGVudW0nIDogJ2VudW0nXG4gICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9ICR7ZW51bU5hbWV9ICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgIGlmIChjb25zdEVudW0pIHtcbiAgICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjb25zdCBlbnVtICR7bGluZS5uYW1lfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyArPSBgZXhwb3J0IHR5cGUgJHtsaW5lLm5hbWV9ID0gJHtsaW5lLmRlZi5yZXBsYWNlQWxsKC8uKj0vZywgJycpLnJlcGxhY2VBbGwoJywnLCAnfCcpfTtgXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5TdHJ1Y3Q6XG4gICAgICBjb25zdCBleHRlbmRzRGVmID0gbGluZS5leHRlbmRzID8gYCBleHRlbmRzICR7bGluZS5leHRlbmRzfWAgOiAnJ1xuICAgICAgaWYgKGxpbmUuZXh0ZW5kcykge1xuICAgICAgICAvLyBFeHRyYWN0IGdlbmVyaWMgcGFyYW1zIGZyb20gZXh0ZW5kcyB0eXBlIGxpa2UgSXRlcmF0b3I8VCwgVFJlc3VsdCwgVE5leHQ+XG4gICAgICAgIGNvbnN0IGdlbmVyaWNNYXRjaCA9IGxpbmUuZXh0ZW5kcy5tYXRjaCgvSXRlcmF0b3I8KC4rKT4kLylcbiAgICAgICAgaWYgKGdlbmVyaWNNYXRjaCkge1xuICAgICAgICAgIGNvbnN0IFtULCBUUmVzdWx0LCBUTmV4dF0gPSBnZW5lcmljTWF0Y2hbMV1cbiAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKChwKSA9PiBwLnRyaW0oKSlcbiAgICAgICAgICBsaW5lLmRlZiA9XG4gICAgICAgICAgICBsaW5lLmRlZiArXG4gICAgICAgICAgICBgXFxubmV4dCh2YWx1ZT86ICR7VE5leHR9KTogSXRlcmF0b3JSZXN1bHQ8JHtUfSwgJHtUUmVzdWx0fT5gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gY2xhc3MgJHtsaW5lLm5hbWV9JHtleHRlbmRzRGVmfSB7XFxuJHtsaW5lLmRlZn1cXG59YFxuICAgICAgaWYgKGxpbmUub3JpZ2luYWxfbmFtZSAmJiBsaW5lLm9yaWdpbmFsX25hbWUgIT09IGxpbmUubmFtZSkge1xuICAgICAgICBzICs9IGBcXG5leHBvcnQgdHlwZSAke2xpbmUub3JpZ2luYWxfbmFtZX0gPSAke2xpbmUubmFtZX1gXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5GbjpcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gJHtsaW5lLmRlZn1gXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHMgKz0gbGluZS5kZWZcbiAgfVxuXG4gIHJldHVybiBjb3JyZWN0U3RyaW5nSWRlbnQocywgaWRlbnQpXG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlY2xhcmUoYW1iaWVudDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChhbWJpZW50KSB7XG4gICAgcmV0dXJuICdleHBvcnQnXG4gIH1cblxuICByZXR1cm4gJ2V4cG9ydCBkZWNsYXJlJ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1R5cGVEZWYoXG4gIGludGVybWVkaWF0ZVR5cGVGaWxlOiBzdHJpbmcsXG4gIGNvbnN0RW51bTogYm9vbGVhbixcbikge1xuICBjb25zdCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG4gIGNvbnN0IGRlZnMgPSBhd2FpdCByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoaW50ZXJtZWRpYXRlVHlwZUZpbGUpXG4gIGNvbnN0IGdyb3VwZWREZWZzID0gcHJlcHJvY2Vzc1R5cGVEZWYoZGVmcylcblxuICBjb25zdCBkdHMgPVxuICAgIHNvcnRCeShBcnJheS5mcm9tKGdyb3VwZWREZWZzKSwgWyhbbmFtZXNwYWNlXSkgPT4gbmFtZXNwYWNlXSlcbiAgICAgIC5tYXAoKFtuYW1lc3BhY2UsIGRlZnNdKSA9PiB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09IFRPUF9MRVZFTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gZGVmc1xuICAgICAgICAgICAgLm1hcCgoZGVmKSA9PiB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZGVmLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkNvbnN0OlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuRW51bTpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cmluZ0VudW06XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5GbjpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cnVjdDoge1xuICAgICAgICAgICAgICAgICAgZXhwb3J0cy5wdXNoKGRlZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgaWYgKGRlZi5vcmlnaW5hbF9uYW1lICYmIGRlZi5vcmlnaW5hbF9uYW1lICE9PSBkZWYubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzLnB1c2goZGVmLm9yaWdpbmFsX25hbWUpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcHJldHR5UHJpbnQoZGVmLCBjb25zdEVudW0sIDApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcblxcbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwb3J0cy5wdXNoKG5hbWVzcGFjZSlcbiAgICAgICAgICBsZXQgZGVjbGFyYXRpb24gPSAnJ1xuICAgICAgICAgIGRlY2xhcmF0aW9uICs9IGBleHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgJHtuYW1lc3BhY2V9IHtcXG5gXG4gICAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24gKz0gcHJldHR5UHJpbnQoZGVmLCBjb25zdEVudW0sIDIsIHRydWUpICsgJ1xcbidcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVjbGFyYXRpb24gKz0gJ30nXG4gICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignXFxuXFxuJykgKyAnXFxuJ1xuXG4gIHJldHVybiB7XG4gICAgZHRzLFxuICAgIGV4cG9ydHMsXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZEludGVybWVkaWF0ZVR5cGVGaWxlKGZpbGU6IHN0cmluZykge1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhmaWxlLCAndXRmOCcpXG5cbiAgY29uc3QgZGVmcyA9IGNvbnRlbnRcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKVxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShsaW5lKSBhcyBUeXBlRGVmTGluZVxuICAgICAgLy8gQ29udmVydCBlc2NhcGVkIG5ld2xpbmVzIGJhY2sgdG8gYWN0dWFsIG5ld2xpbmVzIGluIGpzX2RvYyBmaWVsZHNcbiAgICAgIGlmIChwYXJzZWQuanNfZG9jKSB7XG4gICAgICAgIHBhcnNlZC5qc19kb2MgPSBwYXJzZWQuanNfZG9jLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgfVxuICAgICAgLy8gQ29udmVydCBlc2NhcGVkIG5ld2xpbmVzIHRvIGFjdHVhbCBuZXdsaW5lcyBpbiBkZWYgZmllbGRzIGZvciBzdHJ1Y3QvY2xhc3MvaW50ZXJmYWNlL3R5cGUgdHlwZXNcbiAgICAgIC8vIHdoZXJlIFxcbiByZXByZXNlbnRzIG1ldGhvZC9maWVsZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGFjdHVhbCBuZXdsaW5lc1xuICAgICAgaWYgKHBhcnNlZC5kZWYpIHtcbiAgICAgICAgcGFyc2VkLmRlZiA9IHBhcnNlZC5kZWYucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfSlcblxuICAvLyBtb3ZlIGFsbCBgc3RydWN0YCBkZWYgdG8gdGhlIHZlcnkgdG9wXG4gIC8vIGFuZCBvcmRlciB0aGUgcmVzdCBhbHBoYWJldGljYWxseS5cbiAgcmV0dXJuIGRlZnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgaWYgKGIua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKGIua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1R5cGVEZWYoZGVmczogVHlwZURlZkxpbmVbXSk6IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lW10+IHtcbiAgY29uc3QgbmFtZXNwYWNlR3JvdXBlZCA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZVtdPigpXG4gIGNvbnN0IGNsYXNzRGVmcyA9IG5ldyBNYXA8c3RyaW5nLCBUeXBlRGVmTGluZT4oKVxuXG4gIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSBkZWYuanNfbW9kID8/IFRPUF9MRVZFTF9OQU1FU1BBQ0VcbiAgICBpZiAoIW5hbWVzcGFjZUdyb3VwZWQuaGFzKG5hbWVzcGFjZSkpIHtcbiAgICAgIG5hbWVzcGFjZUdyb3VwZWQuc2V0KG5hbWVzcGFjZSwgW10pXG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXAgPSBuYW1lc3BhY2VHcm91cGVkLmdldChuYW1lc3BhY2UpIVxuXG4gICAgaWYgKGRlZi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIGdyb3VwLnB1c2goZGVmKVxuICAgICAgY2xhc3NEZWZzLnNldChkZWYubmFtZSwgZGVmKVxuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLkV4dGVuZHMpIHtcbiAgICAgIGNvbnN0IGNsYXNzRGVmID0gY2xhc3NEZWZzLmdldChkZWYubmFtZSlcbiAgICAgIGlmIChjbGFzc0RlZikge1xuICAgICAgICBjbGFzc0RlZi5leHRlbmRzID0gZGVmLmRlZlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLkltcGwpIHtcbiAgICAgIC8vIG1lcmdlIGBpbXBsYCBpbnRvIGNsYXNzIGRlZmluaXRpb25cbiAgICAgIGNvbnN0IGNsYXNzRGVmID0gY2xhc3NEZWZzLmdldChkZWYubmFtZSlcbiAgICAgIGlmIChjbGFzc0RlZikge1xuICAgICAgICBpZiAoY2xhc3NEZWYuZGVmKSB7XG4gICAgICAgICAgY2xhc3NEZWYuZGVmICs9ICdcXG4nXG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc0RlZi5kZWYgKz0gZGVmLmRlZlxuICAgICAgICAvLyBDb252ZXJ0IGFueSByZW1haW5pbmcgXFxuIHNlcXVlbmNlcyBpbiB0aGUgbWVyZ2VkIGRlZiB0byBhY3R1YWwgbmV3bGluZXNcbiAgICAgICAgaWYgKGNsYXNzRGVmLmRlZikge1xuICAgICAgICAgIGNsYXNzRGVmLmRlZiA9IGNsYXNzRGVmLmRlZi5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBncm91cC5wdXNoKGRlZilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZXNwYWNlR3JvdXBlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29ycmVjdFN0cmluZ0lkZW50KHNyYzogc3RyaW5nLCBpZGVudDogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IGJyYWNrZXREZXB0aCA9IDBcbiAgY29uc3QgcmVzdWx0ID0gc3JjXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGxpbmUgPSBsaW5lLnRyaW0oKVxuICAgICAgaWYgKGxpbmUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0luTXVsdGlsaW5lQ29tbWVudCA9IGxpbmUuc3RhcnRzV2l0aCgnKicpXG4gICAgICBjb25zdCBpc0Nsb3NpbmdCcmFja2V0ID0gbGluZS5lbmRzV2l0aCgnfScpXG4gICAgICBjb25zdCBpc09wZW5pbmdCcmFja2V0ID0gbGluZS5lbmRzV2l0aCgneycpXG4gICAgICBjb25zdCBpc1R5cGVEZWNsYXJhdGlvbiA9IGxpbmUuZW5kc1dpdGgoJz0nKVxuICAgICAgY29uc3QgaXNUeXBlVmFyaWFudCA9IGxpbmUuc3RhcnRzV2l0aCgnfCcpXG5cbiAgICAgIGxldCByaWdodEluZGVudCA9IGlkZW50XG4gICAgICBpZiAoKGlzT3BlbmluZ0JyYWNrZXQgfHwgaXNUeXBlRGVjbGFyYXRpb24pICYmICFpc0luTXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgICBicmFja2V0RGVwdGggKz0gMVxuICAgICAgICByaWdodEluZGVudCArPSAoYnJhY2tldERlcHRoIC0gMSkgKiAyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNDbG9zaW5nQnJhY2tldCAmJlxuICAgICAgICAgIGJyYWNrZXREZXB0aCA+IDAgJiZcbiAgICAgICAgICAhaXNJbk11bHRpbGluZUNvbW1lbnQgJiZcbiAgICAgICAgICAhaXNUeXBlVmFyaWFudFxuICAgICAgICApIHtcbiAgICAgICAgICBicmFja2V0RGVwdGggLT0gMVxuICAgICAgICB9XG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IGJyYWNrZXREZXB0aCAqIDJcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW5NdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IDFcbiAgICAgIH1cblxuICAgICAgY29uc3QgcyA9IGAkeycgJy5yZXBlYXQocmlnaHRJbmRlbnQpfSR7bGluZX1gXG5cbiAgICAgIHJldHVybiBzXG4gICAgfSlcbiAgICAuam9pbignXFxuJylcblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJpbXBvcnQgeyByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyByZWFkTmFwaUNvbmZpZyB9IGZyb20gJy4vY29uZmlnLmpzJ1xuXG5pbnRlcmZhY2UgTWluaW1hbE5hcGlPcHRpb25zIHtcbiAgY3dkOiBzdHJpbmdcbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRDb25maWcob3B0aW9uczogTWluaW1hbE5hcGlPcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVQYXRoID0gKC4uLnBhdGhzOiBzdHJpbmdbXSkgPT4gcmVzb2x2ZShvcHRpb25zLmN3ZCwgLi4ucGF0aHMpXG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHJlc29sdmVQYXRoKG9wdGlvbnMucGFja2FnZUpzb25QYXRoID8/ICdwYWNrYWdlLmpzb24nKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG4gIHJldHVybiBjb25maWdcbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUsIHBhcnNlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRBcnRpZmFjdHNPcHRpb25zLFxuICB0eXBlIEFydGlmYWN0c09wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9hcnRpZmFjdHMuanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICByZWFkRmlsZUFzeW5jLFxuICB3cml0ZUZpbGVBc3luYyxcbiAgVW5pQXJjaHNCeVBsYXRmb3JtLFxuICByZWFkZGlyQXN5bmMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYXJ0aWZhY3RzJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RBcnRpZmFjdHModXNlck9wdGlvbnM6IEFydGlmYWN0c09wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcmVzb2x2ZVBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKSA9PiByZXNvbHZlKG9wdGlvbnMuY3dkLCAuLi5wYXRocylcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZVBhdGgob3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IHsgdGFyZ2V0cywgYmluYXJ5TmFtZSwgcGFja2FnZU5hbWUgfSA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgZGlzdERpcnMgPSB0YXJnZXRzLm1hcCgocGxhdGZvcm0pID0+XG4gICAgam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5ucG1EaXIsIHBsYXRmb3JtLnBsYXRmb3JtQXJjaEFCSSksXG4gIClcblxuICBjb25zdCB1bml2ZXJzYWxTb3VyY2VCaW5zID0gbmV3IFNldChcbiAgICB0YXJnZXRzXG4gICAgICAuZmlsdGVyKChwbGF0Zm9ybSkgPT4gcGxhdGZvcm0uYXJjaCA9PT0gJ3VuaXZlcnNhbCcpXG4gICAgICAuZmxhdE1hcCgocCkgPT5cbiAgICAgICAgVW5pQXJjaHNCeVBsYXRmb3JtW3AucGxhdGZvcm1dPy5tYXAoKGEpID0+IGAke3AucGxhdGZvcm19LSR7YX1gKSxcbiAgICAgIClcbiAgICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgc3RyaW5nW10sXG4gIClcblxuICBhd2FpdCBjb2xsZWN0Tm9kZUJpbmFyaWVzKGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMub3V0cHV0RGlyKSkudGhlbihcbiAgICAob3V0cHV0KSA9PlxuICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgIG91dHB1dC5tYXAoYXN5bmMgKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgICAgZGVidWcuaW5mbyhgUmVhZCBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGZpbGVQYXRoKX1dYClcbiAgICAgICAgICBjb25zdCBzb3VyY2VDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhmaWxlUGF0aClcbiAgICAgICAgICBjb25zdCBwYXJzZWROYW1lID0gcGFyc2UoZmlsZVBhdGgpXG4gICAgICAgICAgY29uc3QgdGVybXMgPSBwYXJzZWROYW1lLm5hbWUuc3BsaXQoJy4nKVxuICAgICAgICAgIGNvbnN0IHBsYXRmb3JtQXJjaEFCSSA9IHRlcm1zLnBvcCgpIVxuICAgICAgICAgIGNvbnN0IF9iaW5hcnlOYW1lID0gdGVybXMuam9pbignLicpXG5cbiAgICAgICAgICBpZiAoX2JpbmFyeU5hbWUgIT09IGJpbmFyeU5hbWUpIHtcbiAgICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAgIGBbJHtfYmluYXJ5TmFtZX1dIGlzIG5vdCBtYXRjaGVkIHdpdGggWyR7YmluYXJ5TmFtZX1dLCBza2lwYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkaXIgPSBkaXN0RGlycy5maW5kKChkaXIpID0+IGRpci5pbmNsdWRlcyhwbGF0Zm9ybUFyY2hBQkkpKVxuICAgICAgICAgIGlmICghZGlyICYmIHVuaXZlcnNhbFNvdXJjZUJpbnMuaGFzKHBsYXRmb3JtQXJjaEFCSSkpIHtcbiAgICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAgIGBbJHtwbGF0Zm9ybUFyY2hBQkl9XSBoYXMgbm8gZGlzdCBkaXIgYnV0IGl0IGlzIHNvdXJjZSBiaW4gZm9yIHVuaXZlcnNhbCBhcmNoLCBza2lwYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRpcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkaXN0IGRpciBmb3VuZCBmb3IgJHtmaWxlUGF0aH1gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRpc3RGaWxlUGF0aCA9IGpvaW4oZGlyLCBwYXJzZWROYW1lLmJhc2UpXG4gICAgICAgICAgZGVidWcuaW5mbyhcbiAgICAgICAgICAgIGBXcml0ZSBmaWxlIGNvbnRlbnQgdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodChkaXN0RmlsZVBhdGgpfV1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkaXN0RmlsZVBhdGgsIHNvdXJjZUNvbnRlbnQpXG4gICAgICAgICAgY29uc3QgZGlzdEZpbGVQYXRoTG9jYWwgPSBqb2luKFxuICAgICAgICAgICAgcGFyc2UocGFja2FnZUpzb25QYXRoKS5kaXIsXG4gICAgICAgICAgICBwYXJzZWROYW1lLmJhc2UsXG4gICAgICAgICAgKVxuICAgICAgICAgIGRlYnVnLmluZm8oXG4gICAgICAgICAgICBgV3JpdGUgZmlsZSBjb250ZW50IHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZGlzdEZpbGVQYXRoTG9jYWwpfV1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkaXN0RmlsZVBhdGhMb2NhbCwgc291cmNlQ29udGVudClcbiAgICAgICAgfSksXG4gICAgICApLFxuICApXG5cbiAgY29uc3Qgd2FzaVRhcmdldCA9IHRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuICBpZiAod2FzaVRhcmdldCkge1xuICAgIGNvbnN0IHdhc2lEaXIgPSBqb2luKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm5wbURpcixcbiAgICAgIHdhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJLFxuICAgIClcbiAgICBjb25zdCBjanNGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2AsXG4gICAgKVxuICAgIGNvbnN0IHdvcmtlckZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGB3YXNpLXdvcmtlci5tanNgLFxuICAgIClcbiAgICBjb25zdCBicm93c2VyRW50cnkgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGAke2JpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgKVxuICAgIGNvbnN0IGJyb3dzZXJXb3JrZXJGaWxlID0gam9pbihcbiAgICAgIG9wdGlvbnMuYnVpbGRPdXRwdXREaXIgPz8gb3B0aW9ucy5jd2QsXG4gICAgICBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBiaW5kaW5nIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgY2pzRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYCR7YmluYXJ5TmFtZX0ud2FzaS5janNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMoY2pzRmlsZSksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIHdvcmtlciBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIHdvcmtlckZpbGUsXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGB3YXNpLXdvcmtlci5tanNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMod29ya2VyRmlsZSksXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJyb3dzZXIgZW50cnkgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBicm93c2VyRW50cnksXG4gICAgICApfV0gdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodCh3YXNpRGlyKX1dYCxcbiAgICApXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICBqb2luKHdhc2lEaXIsIGAke2JpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2ApLFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy84NDI3XG4gICAgICAoYXdhaXQgcmVhZEZpbGVBc3luYyhicm93c2VyRW50cnksICd1dGY4JykpLnJlcGxhY2UoXG4gICAgICAgIGBuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKWAsXG4gICAgICAgIGBuZXcgVVJMKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaS93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybClgLFxuICAgICAgKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYnJvd3NlciB3b3JrZXIgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBicm93c2VyV29ya2VyRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCksXG4gICAgICBhd2FpdCByZWFkRmlsZUFzeW5jKGJyb3dzZXJXb3JrZXJGaWxlKSxcbiAgICApXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29sbGVjdE5vZGVCaW5hcmllcyhyb290OiBzdHJpbmcpIHtcbiAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocm9vdCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG4gIGNvbnN0IG5vZGVCaW5hcmllcyA9IGZpbGVzXG4gICAgLmZpbHRlcihcbiAgICAgIChmaWxlKSA9PlxuICAgICAgICBmaWxlLmlzRmlsZSgpICYmXG4gICAgICAgIChmaWxlLm5hbWUuZW5kc1dpdGgoJy5ub2RlJykgfHwgZmlsZS5uYW1lLmVuZHNXaXRoKCcud2FzbScpKSxcbiAgICApXG4gICAgLm1hcCgoZmlsZSkgPT4gam9pbihyb290LCBmaWxlLm5hbWUpKVxuXG4gIGNvbnN0IGRpcnMgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUuaXNEaXJlY3RvcnkoKSlcbiAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgIGlmIChkaXIubmFtZSAhPT0gJ25vZGVfbW9kdWxlcycpIHtcbiAgICAgIG5vZGVCaW5hcmllcy5wdXNoKC4uLihhd2FpdCBjb2xsZWN0Tm9kZUJpbmFyaWVzKGpvaW4ocm9vdCwgZGlyLm5hbWUpKSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlQmluYXJpZXNcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDanNCaW5kaW5nKFxuICBsb2NhbE5hbWU6IHN0cmluZyxcbiAgcGtnTmFtZTogc3RyaW5nLFxuICBpZGVudHM6IHN0cmluZ1tdLFxuICBwYWNrYWdlVmVyc2lvbj86IHN0cmluZyxcbik6IHN0cmluZyB7XG4gIHJldHVybiBgJHtiaW5kaW5nSGVhZGVyfVxuJHtjcmVhdGVDb21tb25CaW5kaW5nKGxvY2FsTmFtZSwgcGtnTmFtZSwgcGFja2FnZVZlcnNpb24pfVxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVCaW5kaW5nXG4ke2lkZW50c1xuICAubWFwKChpZGVudCkgPT4gYG1vZHVsZS5leHBvcnRzLiR7aWRlbnR9ID0gbmF0aXZlQmluZGluZy4ke2lkZW50fWApXG4gIC5qb2luKCdcXG4nKX1cbmBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVzbUJpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIGlkZW50czogc3RyaW5nW10sXG4gIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpXG5jb25zdCBfX2Rpcm5hbWUgPSBuZXcgVVJMKCcuJywgaW1wb3J0Lm1ldGEudXJsKS5wYXRobmFtZVxuXG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lLCBwYWNrYWdlVmVyc2lvbil9XG5jb25zdCB7ICR7aWRlbnRzLmpvaW4oJywgJyl9IH0gPSBuYXRpdmVCaW5kaW5nXG4ke2lkZW50cy5tYXAoKGlkZW50KSA9PiBgZXhwb3J0IHsgJHtpZGVudH0gfWApLmpvaW4oJ1xcbicpfVxuYFxufVxuXG5jb25zdCBiaW5kaW5nSGVhZGVyID0gYC8vIHByZXR0aWVyLWlnbm9yZVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vKiBhdXRvLWdlbmVyYXRlZCBieSBOQVBJLVJTICovXG5gXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbkJpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgZnVuY3Rpb24gcmVxdWlyZVR1cGxlKHR1cGxlOiBzdHJpbmcsIGlkZW50U2l6ZSA9IDgpIHtcbiAgICBjb25zdCBpZGVudExvdyA9ICcgJy5yZXBlYXQoaWRlbnRTaXplIC0gMilcbiAgICBjb25zdCBpZGVudCA9ICcgJy5yZXBlYXQoaWRlbnRTaXplKVxuICAgIGNvbnN0IHZlcnNpb25DaGVjayA9IHBhY2thZ2VWZXJzaW9uXG4gICAgICA/IGBcbiR7aWRlbnRMb3d9dHJ5IHtcbiR7aWRlbnR9Y29uc3QgYmluZGluZyA9IHJlcXVpcmUoJyR7cGtnTmFtZX0tJHt0dXBsZX0nKVxuJHtpZGVudH1jb25zdCBiaW5kaW5nUGFja2FnZVZlcnNpb24gPSByZXF1aXJlKCcke3BrZ05hbWV9LSR7dHVwbGV9L3BhY2thZ2UuanNvbicpLnZlcnNpb25cbiR7aWRlbnR9aWYgKGJpbmRpbmdQYWNrYWdlVmVyc2lvbiAhPT0gJyR7cGFja2FnZVZlcnNpb259JyAmJiBwcm9jZXNzLmVudi5OQVBJX1JTX0VORk9SQ0VfVkVSU0lPTl9DSEVDSyAmJiBwcm9jZXNzLmVudi5OQVBJX1JTX0VORk9SQ0VfVkVSU0lPTl9DSEVDSyAhPT0gJzAnKSB7XG4ke2lkZW50fSAgdGhyb3cgbmV3IEVycm9yKFxcYE5hdGl2ZSBiaW5kaW5nIHBhY2thZ2UgdmVyc2lvbiBtaXNtYXRjaCwgZXhwZWN0ZWQgJHtwYWNrYWdlVmVyc2lvbn0gYnV0IGdvdCBcXCR7YmluZGluZ1BhY2thZ2VWZXJzaW9ufS4gWW91IGNhbiByZWluc3RhbGwgZGVwZW5kZW5jaWVzIHRvIGZpeCB0aGlzIGlzc3VlLlxcYClcbiR7aWRlbnR9fVxuJHtpZGVudH1yZXR1cm4gYmluZGluZ1xuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319YFxuICAgICAgOiBgXG4ke2lkZW50TG93fXRyeSB7XG4ke2lkZW50fXJldHVybiByZXF1aXJlKCcke3BrZ05hbWV9LSR7dHVwbGV9JylcbiR7aWRlbnRMb3d9fSBjYXRjaCAoZSkge1xuJHtpZGVudH1sb2FkRXJyb3JzLnB1c2goZSlcbiR7aWRlbnRMb3d9fWBcbiAgICByZXR1cm4gYHRyeSB7XG4ke2lkZW50fXJldHVybiByZXF1aXJlKCcuLyR7bG9jYWxOYW1lfS4ke3R1cGxlfS5ub2RlJylcbiR7aWRlbnRMb3d9fSBjYXRjaCAoZSkge1xuJHtpZGVudH1sb2FkRXJyb3JzLnB1c2goZSlcbiR7aWRlbnRMb3d9fSR7dmVyc2lvbkNoZWNrfWBcbiAgfVxuXG4gIHJldHVybiBgY29uc3QgeyByZWFkRmlsZVN5bmMgfSA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxubGV0IG5hdGl2ZUJpbmRpbmcgPSBudWxsXG5jb25zdCBsb2FkRXJyb3JzID0gW11cblxuY29uc3QgaXNNdXNsID0gKCkgPT4ge1xuICBsZXQgbXVzbCA9IGZhbHNlXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgbXVzbCA9IGlzTXVzbEZyb21GaWxlc3lzdGVtKClcbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21SZXBvcnQoKVxuICAgIH1cbiAgICBpZiAobXVzbCA9PT0gbnVsbCkge1xuICAgICAgbXVzbCA9IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbXVzbFxufVxuXG5jb25zdCBpc0ZpbGVNdXNsID0gKGYpID0+IGYuaW5jbHVkZXMoJ2xpYmMubXVzbC0nKSB8fCBmLmluY2x1ZGVzKCdsZC1tdXNsLScpXG5cbmNvbnN0IGlzTXVzbEZyb21GaWxlc3lzdGVtID0gKCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiByZWFkRmlsZVN5bmMoJy91c3IvYmluL2xkZCcsICd1dGYtOCcpLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jb25zdCBpc011c2xGcm9tUmVwb3J0ID0gKCkgPT4ge1xuICBsZXQgcmVwb3J0ID0gbnVsbFxuICBpZiAodHlwZW9mIHByb2Nlc3MucmVwb3J0Py5nZXRSZXBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLnJlcG9ydC5leGNsdWRlTmV0d29yayA9IHRydWVcbiAgICByZXBvcnQgPSBwcm9jZXNzLnJlcG9ydC5nZXRSZXBvcnQoKVxuICB9XG4gIGlmICghcmVwb3J0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAocmVwb3J0LmhlYWRlciAmJiByZXBvcnQuaGVhZGVyLmdsaWJjVmVyc2lvblJ1bnRpbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXBvcnQuc2hhcmVkT2JqZWN0cykpIHtcbiAgICBpZiAocmVwb3J0LnNoYXJlZE9iamVjdHMuc29tZShpc0ZpbGVNdXNsKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmNvbnN0IGlzTXVzbEZyb21DaGlsZFByb2Nlc3MgPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYygnbGRkIC0tdmVyc2lvbicsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KS5pbmNsdWRlcygnbXVzbCcpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZiB3ZSByZWFjaCB0aGlzIGNhc2UsIHdlIGRvbid0IGtub3cgaWYgdGhlIHN5c3RlbSBpcyBtdXNsIG9yIG5vdCwgc28gaXMgYmV0dGVyIHRvIGp1c3QgZmFsbGJhY2sgdG8gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1aXJlTmF0aXZlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKHByb2Nlc3MuZW52Lk5BUElfUlNfTkFUSVZFX0xJQlJBUllfUEFUSCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2goZXJyKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm02NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2FuZHJvaWQtYXJtLWVhYmknKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gQW5kcm9pZCBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgaWYgKHByb2Nlc3MuY29uZmlnPy52YXJpYWJsZXM/LnNobGliX3N1ZmZpeCA9PT0gJ2RsbC5hJyB8fCBwcm9jZXNzLmNvbmZpZz8udmFyaWFibGVzPy5ub2RlX3RhcmdldF90eXBlID09PSAnc2hhcmVkX2xpYnJhcnknKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi14NjQtZ251Jyl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzIteDY0LW1zdmMnKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2lhMzInKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnd2luMzItaWEzMi1tc3ZjJyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi1hcm02NC1tc3ZjJyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIFdpbmRvd3M6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXVuaXZlcnNhbCcsIDYpfVxuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZGFyd2luLWFybTY0Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIG1hY09TOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdmcmVlYnNkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZnJlZWJzZC14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2ZyZWVic2QtYXJtNjQnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gRnJlZUJTRDogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgteDY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm02NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLW11c2xlYWJpaGYnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtLWdudWVhYmloZicsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2xvb25nNjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWxvb25nNjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1sb29uZzY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3Jpc2N2NjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXJpc2N2NjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1yaXNjdjY0LWdudScsIDEwKX1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3BwYzY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXBwYzY0LWdudScpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnczM5MHgnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtczM5MHgtZ251Jyl9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChuZXcgRXJyb3IoXFxgVW5zdXBwb3J0ZWQgYXJjaGl0ZWN0dXJlIG9uIExpbnV4OiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdvcGVuaGFybW9ueScpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnb3Blbmhhcm1vbnktYXJtNjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdvcGVuaGFybW9ueS14NjQnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybScpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdvcGVuaGFybW9ueS1hcm0nKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gT3Blbkhhcm1vbnk6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBPUzogXFwke3Byb2Nlc3MucGxhdGZvcm19LCBhcmNoaXRlY3R1cmU6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgfVxufVxuXG5uYXRpdmVCaW5kaW5nID0gcmVxdWlyZU5hdGl2ZSgpXG5cbmlmICghbmF0aXZlQmluZGluZyB8fCBwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kpIHtcbiAgbGV0IHdhc2lCaW5kaW5nID0gbnVsbFxuICBsZXQgd2FzaUJpbmRpbmdFcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB3YXNpQmluZGluZyA9IHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9Lndhc2kuY2pzJylcbiAgICBuYXRpdmVCaW5kaW5nID0gd2FzaUJpbmRpbmdcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgd2FzaUJpbmRpbmdFcnJvciA9IGVyclxuICAgIH1cbiAgfVxuICBpZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgICB0cnkge1xuICAgICAgd2FzaUJpbmRpbmcgPSByZXF1aXJlKCcke3BrZ05hbWV9LXdhc20zMi13YXNpJylcbiAgICAgIG5hdGl2ZUJpbmRpbmcgPSB3YXNpQmluZGluZ1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICAgICAgICB3YXNpQmluZGluZ0Vycm9yLmNhdXNlID0gZXJyXG4gICAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX0ZPUkNFX1dBU0kgPT09ICdlcnJvcicgJiYgIXdhc2lCaW5kaW5nKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1dBU0kgYmluZGluZyBub3QgZm91bmQgYW5kIE5BUElfUlNfRk9SQ0VfV0FTSSBpcyBzZXQgdG8gZXJyb3InKVxuICAgIGVycm9yLmNhdXNlID0gd2FzaUJpbmRpbmdFcnJvclxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuaWYgKCFuYXRpdmVCaW5kaW5nKSB7XG4gIGlmIChsb2FkRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcXGBDYW5ub3QgZmluZCBuYXRpdmUgYmluZGluZy4gXFxgICtcbiAgICAgICAgXFxgbnBtIGhhcyBhIGJ1ZyByZWxhdGVkIHRvIG9wdGlvbmFsIGRlcGVuZGVuY2llcyAoaHR0cHM6Ly9naXRodWIuY29tL25wbS9jbGkvaXNzdWVzLzQ4MjgpLiBcXGAgK1xuICAgICAgICAnUGxlYXNlIHRyeSBcXGBucG0gaVxcYCBhZ2FpbiBhZnRlciByZW1vdmluZyBib3RoIHBhY2thZ2UtbG9jay5qc29uIGFuZCBub2RlX21vZHVsZXMgZGlyZWN0b3J5LicsXG4gICAgICB7XG4gICAgICAgIGNhdXNlOiBsb2FkRXJyb3JzLnJlZHVjZSgoZXJyLCBjdXIpID0+IHtcbiAgICAgICAgICBjdXIuY2F1c2UgPSBlcnJcbiAgICAgICAgICByZXR1cm4gY3VyXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxcYEZhaWxlZCB0byBsb2FkIG5hdGl2ZSBiaW5kaW5nXFxgKVxufVxuYFxufVxuIiwiZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyA9IChcbiAgd2FzaUZpbGVuYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4gIGZzID0gZmFsc2UsXG4gIGFzeW5jSW5pdCA9IGZhbHNlLFxuICBidWZmZXIgPSBmYWxzZSxcbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzXG4gICAgPyBidWZmZXJcbiAgICAgID8gYGltcG9ydCB7IG1lbWZzLCBCdWZmZXIgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUvZnMnYFxuICAgICAgOiBgaW1wb3J0IHsgbWVtZnMgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUvZnMnYFxuICAgIDogJydcbiAgY29uc3QgYnVmZmVySW1wb3J0ID0gYnVmZmVyICYmICFmcyA/IGBpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInYCA6ICcnXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgXG5leHBvcnQgY29uc3QgeyBmczogX19mcywgdm9sOiBfX3ZvbHVtZSB9ID0gbWVtZnMoKVxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19XQVNJKHtcbiAgdmVyc2lvbjogJ3ByZXZpZXcxJyxcbiAgZnM6IF9fZnMsXG4gIHByZW9wZW5zOiB7XG4gICAgJy8nOiAnLycsXG4gIH0sXG59KWBcbiAgICA6IGBcbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxufSlgXG5cbiAgY29uc3Qgd29ya2VyRnNIYW5kbGVyID0gZnNcbiAgICA/IGAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fZnMpKVxcbmBcbiAgICA6ICcnXG5cbiAgY29uc3QgZW1uYXBpSW5qZWN0QnVmZmVyID0gYnVmZmVyXG4gICAgPyAnX19lbW5hcGlDb250ZXh0LmZlYXR1cmUuQnVmZmVyID0gQnVmZmVyJ1xuICAgIDogJydcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVJbXBvcnQgPSBhc3luY0luaXRcbiAgICA/IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGUgYXMgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmNgXG4gIGNvbnN0IGVtbmFwaUluc3RhbnRpYXRlQ2FsbCA9IGFzeW5jSW5pdFxuICAgID8gYGF3YWl0IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlYFxuICAgIDogYF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcblxuICByZXR1cm4gYGltcG9ydCB7XG4gIGNyZWF0ZU9uTWVzc2FnZSBhcyBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dCBhcyBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0LFxuICAke2VtbmFwaUluc3RhbnRpYXRlSW1wb3J0fSxcbiAgV0FTSSBhcyBfX1dBU0ksXG59IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbiR7ZnNJbXBvcnR9XG4ke2J1ZmZlckltcG9ydH1cbiR7d2FzaUNyZWF0aW9ufVxuXG5jb25zdCBfX3dhc21VcmwgPSBuZXcgVVJMKCcuLyR7d2FzaUZpbGVuYW1lfS53YXNtJywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmXG5jb25zdCBfX2VtbmFwaUNvbnRleHQgPSBfX2VtbmFwaUdldERlZmF1bHRDb250ZXh0KClcbiR7ZW1uYXBpSW5qZWN0QnVmZmVyfVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5jb25zdCBfX3dhc21GaWxlID0gYXdhaXQgZmV0Y2goX193YXNtVXJsKS50aGVuKChyZXMpID0+IHJlcy5hcnJheUJ1ZmZlcigpKVxuXG5jb25zdCB7XG4gIGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSxcbiAgbW9kdWxlOiBfX3dhc2lNb2R1bGUsXG4gIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSxcbn0gPSAke2VtbmFwaUluc3RhbnRpYXRlQ2FsbH0oX193YXNtRmlsZSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiA0LFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgnLi93YXNpLXdvcmtlci1icm93c2VyLm1qcycsIGltcG9ydC5tZXRhLnVybCksIHtcbiAgICAgIHR5cGU6ICdtb2R1bGUnLFxuICAgIH0pXG4ke3dvcmtlckZzSGFuZGxlcn1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVXYXNpQmluZGluZyA9IChcbiAgd2FzbUZpbGVOYW1lOiBzdHJpbmcsXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gIGluaXRpYWxNZW1vcnkgPSA0MDAwLFxuICBtYXhpbXVtTWVtb3J5ID0gNjU1MzYsXG4pID0+IGAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogcHJldHRpZXItaWdub3JlICovXG5cbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cblxuY29uc3QgX19ub2RlRnMgPSByZXF1aXJlKCdub2RlOmZzJylcbmNvbnN0IF9fbm9kZVBhdGggPSByZXF1aXJlKCdub2RlOnBhdGgnKVxuY29uc3QgeyBXQVNJOiBfX25vZGVXQVNJIH0gPSByZXF1aXJlKCdub2RlOndhc2knKVxuY29uc3QgeyBXb3JrZXIgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG5jb25zdCB7XG4gIGNyZWF0ZU9uTWVzc2FnZTogX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eSxcbiAgZ2V0RGVmYXVsdENvbnRleHQ6IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmM6IF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyxcbn0gPSByZXF1aXJlKCdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnKVxuXG5jb25zdCBfX3Jvb3REaXIgPSBfX25vZGVQYXRoLnBhcnNlKHByb2Nlc3MuY3dkKCkpLnJvb3RcblxuY29uc3QgX193YXNpID0gbmV3IF9fbm9kZVdBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBlbnY6IHByb2Nlc3MuZW52LFxuICBwcmVvcGVuczoge1xuICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gIH1cbn0pXG5cbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuXG5jb25zdCBfX3NoYXJlZE1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe1xuICBpbml0aWFsOiAke2luaXRpYWxNZW1vcnl9LFxuICBtYXhpbXVtOiAke21heGltdW1NZW1vcnl9LFxuICBzaGFyZWQ6IHRydWUsXG59KVxuXG5sZXQgX193YXNtRmlsZVBhdGggPSBfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnJHt3YXNtRmlsZU5hbWV9Lndhc20nKVxuY29uc3QgX193YXNtRGVidWdGaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0uZGVidWcud2FzbScpXG5cbmlmIChfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbURlYnVnRmlsZVBhdGgpKSB7XG4gIF9fd2FzbUZpbGVQYXRoID0gX193YXNtRGVidWdGaWxlUGF0aFxufSBlbHNlIGlmICghX19ub2RlRnMuZXhpc3RzU3luYyhfX3dhc21GaWxlUGF0aCkpIHtcbiAgdHJ5IHtcbiAgICBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGgucmVzb2x2ZSgnJHtwYWNrYWdlTmFtZX0td2FzbTMyLXdhc2knKVxuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kICR7d2FzbUZpbGVOYW1lfS53YXNtIGZpbGUsIGFuZCAke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaSBwYWNrYWdlIGlzIG5vdCBpbnN0YWxsZWQuJylcbiAgfVxufVxuXG5jb25zdCB7IGluc3RhbmNlOiBfX25hcGlJbnN0YW5jZSwgbW9kdWxlOiBfX3dhc2lNb2R1bGUsIG5hcGlNb2R1bGU6IF9fbmFwaU1vZHVsZSB9ID0gX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKF9fbm9kZUZzLnJlYWRGaWxlU3luYyhfX3dhc21GaWxlUGF0aCksIHtcbiAgY29udGV4dDogX19lbW5hcGlDb250ZXh0LFxuICBhc3luY1dvcmtQb29sU2l6ZTogKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHRocmVhZHNTaXplRnJvbUVudiA9IE51bWJlcihwcm9jZXNzLmVudi5OQVBJX1JTX0FTWU5DX1dPUktfUE9PTF9TSVpFID8/IHByb2Nlc3MuZW52LlVWX1RIUkVBRFBPT0xfU0laRSlcbiAgICAvLyBOYU4gPiAwIGlzIGZhbHNlXG4gICAgaWYgKHRocmVhZHNTaXplRnJvbUVudiA+IDApIHtcbiAgICAgIHJldHVybiB0aHJlYWRzU2l6ZUZyb21FbnZcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDRcbiAgICB9XG4gIH0pKCksXG4gIHJldXNlV29ya2VyOiB0cnVlLFxuICB3YXNpOiBfX3dhc2ksXG4gIG9uQ3JlYXRlV29ya2VyKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJ3dhc2ktd29ya2VyLm1qcycpLCB7XG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgIH0pXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgICAgX193YXNtQ3JlYXRlT25NZXNzYWdlRm9yRnNQcm94eShfX25vZGVGcykoZGF0YSlcbiAgICB9XG5cbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgb2YgTm9kZS5qcyB3YWl0cyBmb3IgYWxsIHRoZSBhY3RpdmUgaGFuZGxlcyBiZWZvcmUgZXhpdGluZy5cbiAgICAvLyBCdXQgUnVzdCB0aHJlYWRzIGFyZSBuZXZlciB3YWl0ZWQgd2l0aG91dCBcXGB0aHJlYWQ6OmpvaW5cXGAuXG4gICAgLy8gU28gaGVyZSB3ZSBoYWNrIHRoZSBjb2RlIG9mIE5vZGUuanMgdG8gcHJldmVudCB0aGUgd29ya2VycyBmcm9tIGJlaW5nIHJlZmVyZW5jZWQgKGFjdGl2ZSkuXG4gICAgLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzE5ZTBkNDcyNzI4Yzc5ZDQxOGI3NGJkZGZmNTg4YmVhNzBhNDAzZDAvbGliL2ludGVybmFsL3dvcmtlci5qcyNMNDE1LFxuICAgIC8vIGEgd29ya2VyIGlzIGNvbnNpc3Qgb2YgdHdvIGhhbmRsZXM6IGtQdWJsaWNQb3J0IGFuZCBrSGFuZGxlLlxuICAgIHtcbiAgICAgIGNvbnN0IGtQdWJsaWNQb3J0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrUHVibGljUG9ydFwiKVxuICAgICAgKTtcbiAgICAgIGlmIChrUHVibGljUG9ydCkge1xuICAgICAgICB3b3JrZXJba1B1YmxpY1BvcnRdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrSGFuZGxlID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh3b3JrZXIpLmZpbmQocyA9PlxuICAgICAgICBzLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJrSGFuZGxlXCIpXG4gICAgICApO1xuICAgICAgaWYgKGtIYW5kbGUpIHtcbiAgICAgICAgd29ya2VyW2tIYW5kbGVdLnJlZiA9ICgpID0+IHt9O1xuICAgICAgfVxuXG4gICAgICB3b3JrZXIudW5yZWYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlclxuICB9LFxuICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgbWVtb3J5OiBfX3NoYXJlZE1lbW9yeSxcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE9iamVjdFxuICB9LFxuICBiZWZvcmVJbml0KHsgaW5zdGFuY2UgfSkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpbnN0YW5jZS5leHBvcnRzKSkge1xuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnX19uYXBpX3JlZ2lzdGVyX18nKSkge1xuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW25hbWVdKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59KVxuYFxuIiwiZXhwb3J0IGNvbnN0IFdBU0lfV09SS0VSX1RFTVBMQVRFID0gYGltcG9ydCBmcyBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJub2RlOm1vZHVsZVwiO1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgeyBXQVNJIH0gZnJvbSBcIm5vZGU6d2FzaVwiO1xuaW1wb3J0IHsgcGFyZW50UG9ydCwgV29ya2VyIH0gZnJvbSBcIm5vZGU6d29ya2VyX3RocmVhZHNcIjtcblxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcblxuY29uc3QgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgZ2V0RGVmYXVsdENvbnRleHQgfSA9IHJlcXVpcmUoXCJAbmFwaS1ycy93YXNtLXJ1bnRpbWVcIik7XG5cbmlmIChwYXJlbnRQb3J0KSB7XG4gIHBhcmVudFBvcnQub24oXCJtZXNzYWdlXCIsIChkYXRhKSA9PiB7XG4gICAgZ2xvYmFsVGhpcy5vbm1lc3NhZ2UoeyBkYXRhIH0pO1xuICB9KTtcbn1cblxuT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB7XG4gIHNlbGY6IGdsb2JhbFRoaXMsXG4gIHJlcXVpcmUsXG4gIFdvcmtlcixcbiAgaW1wb3J0U2NyaXB0czogZnVuY3Rpb24gKGYpIHtcbiAgICA7KDAsIGV2YWwpKGZzLnJlYWRGaWxlU3luYyhmLCBcInV0ZjhcIikgKyBcIi8vIyBzb3VyY2VVUkw9XCIgKyBmKTtcbiAgfSxcbiAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAocGFyZW50UG9ydCkge1xuICAgICAgcGFyZW50UG9ydC5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfSxcbn0pO1xuXG5jb25zdCBlbW5hcGlDb250ZXh0ID0gZ2V0RGVmYXVsdENvbnRleHQoKTtcblxuY29uc3QgX19yb290RGlyID0gcGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdDtcblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgIGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgIFtfX3Jvb3REaXJdOiBfX3Jvb3REaXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMod2FzbU1vZHVsZSwge1xuICAgICAgY2hpbGRUaHJlYWQ6IHRydWUsXG4gICAgICB3YXNpLFxuICAgICAgY29udGV4dDogZW1uYXBpQ29udGV4dCxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcbn0pO1xuXG5nbG9iYWxUaGlzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gIGhhbmRsZXIuaGFuZGxlKGUpO1xufTtcbmBcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyA9IChmczogYm9vbGVhbikgPT4ge1xuICBjb25zdCBmc0ltcG9ydCA9IGZzXG4gICAgPyBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0ksIGNyZWF0ZUZzUHJveHkgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnXG5pbXBvcnQgeyBtZW1mc0V4cG9ydGVkIGFzIF9fbWVtZnNFeHBvcnRlZCB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydcblxuY29uc3QgZnMgPSBjcmVhdGVGc1Byb3h5KF9fbWVtZnNFeHBvcnRlZClgXG4gICAgOiBgaW1wb3J0IHsgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYywgTWVzc2FnZUhhbmRsZXIsIFdBU0kgfSBmcm9tICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnYFxuICBjb25zdCB3YXNpQ3JlYXRpb24gPSBmc1xuICAgID8gYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBmcyxcbiAgICAgIHByZW9wZW5zOiB7XG4gICAgICAgICcvJzogJy8nLFxuICAgICAgfSxcbiAgICAgIHByaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgICBwcmludEVycjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICB9KWBcbiAgICA6IGBjb25zdCB3YXNpID0gbmV3IFdBU0koe1xuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICByZXR1cm4gYCR7ZnNJbXBvcnR9XG5cbmNvbnN0IGhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoe1xuICBvbkxvYWQoeyB3YXNtTW9kdWxlLCB3YXNtTWVtb3J5IH0pIHtcbiAgICAke3dhc2lDcmVhdGlvbn1cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBvdmVyd3JpdGVJbXBvcnRzKGltcG9ydE9iamVjdCkge1xuICAgICAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0Lm5hcGksXG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgICAgICBtZW1vcnk6IHdhc21NZW1vcnksXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSlcbiAgfSxcbn0pXG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSlcbn1cbmBcbn1cbiIsImltcG9ydCB7IHNwYXduIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ25vZGU6Y3J5cHRvJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgbWtkaXJTeW5jLCBybVN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gJ25vZGU6bW9kdWxlJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgeyBwYXJzZSwgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9yZXR0ZSdcblxuaW1wb3J0IHR5cGUgeyBCdWlsZE9wdGlvbnMgYXMgUmF3QnVpbGRPcHRpb25zIH0gZnJvbSAnLi4vZGVmL2J1aWxkLmpzJ1xuaW1wb3J0IHtcbiAgQ0xJX1ZFUlNJT04sXG4gIGNvcHlGaWxlQXN5bmMsXG4gIHR5cGUgQ3JhdGUsXG4gIGRlYnVnRmFjdG9yeSxcbiAgREVGQVVMVF9UWVBFX0RFRl9IRUFERVIsXG4gIGZpbGVFeGlzdHMsXG4gIGdldFN5c3RlbURlZmF1bHRUYXJnZXQsXG4gIGdldFRhcmdldExpbmtlcixcbiAgbWtkaXJBc3luYyxcbiAgdHlwZSBOYXBpQ29uZmlnLFxuICBwYXJzZU1ldGFkYXRhLFxuICBwYXJzZVRyaXBsZSxcbiAgcHJvY2Vzc1R5cGVEZWYsXG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICB0eXBlIFRhcmdldCxcbiAgdGFyZ2V0VG9FbnZWYXIsXG4gIHRyeUluc3RhbGxDYXJnb0JpbmFyeSxcbiAgdW5saW5rQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBkaXJFeGlzdHNBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICB0eXBlIENhcmdvV29ya3NwYWNlTWV0YWRhdGEsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5pbXBvcnQgeyBjcmVhdGVDanNCaW5kaW5nLCBjcmVhdGVFc21CaW5kaW5nIH0gZnJvbSAnLi90ZW1wbGF0ZXMvaW5kZXguanMnXG5pbXBvcnQge1xuICBjcmVhdGVXYXNpQmluZGluZyxcbiAgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nLFxufSBmcm9tICcuL3RlbXBsYXRlcy9sb2FkLXdhc2ktdGVtcGxhdGUuanMnXG5pbXBvcnQge1xuICBjcmVhdGVXYXNpQnJvd3NlcldvcmtlckJpbmRpbmcsXG4gIFdBU0lfV09SS0VSX1RFTVBMQVRFLFxufSBmcm9tICcuL3RlbXBsYXRlcy93YXNpLXdvcmtlci10ZW1wbGF0ZS5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2J1aWxkJylcbmNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybClcblxudHlwZSBPdXRwdXRLaW5kID0gJ2pzJyB8ICdkdHMnIHwgJ25vZGUnIHwgJ2V4ZScgfCAnd2FzbSdcbnR5cGUgT3V0cHV0ID0geyBraW5kOiBPdXRwdXRLaW5kOyBwYXRoOiBzdHJpbmcgfVxuXG50eXBlIEJ1aWxkT3B0aW9ucyA9IFJhd0J1aWxkT3B0aW9ucyAmIHsgY2FyZ29PcHRpb25zPzogc3RyaW5nW10gfVxudHlwZSBQYXJzZWRCdWlsZE9wdGlvbnMgPSBPbWl0PEJ1aWxkT3B0aW9ucywgJ2N3ZCc+ICYgeyBjd2Q6IHN0cmluZyB9XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZFByb2plY3QocmF3T3B0aW9uczogQnVpbGRPcHRpb25zKSB7XG4gIGRlYnVnKCduYXBpIGJ1aWxkIGNvbW1hbmQgcmVjZWl2ZSBvcHRpb25zOiAlTycsIHJhd09wdGlvbnMpXG5cbiAgY29uc3Qgb3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zID0ge1xuICAgIGR0c0NhY2hlOiB0cnVlLFxuICAgIC4uLnJhd09wdGlvbnMsXG4gICAgY3dkOiByYXdPcHRpb25zLmN3ZCA/PyBwcm9jZXNzLmN3ZCgpLFxuICB9XG5cbiAgY29uc3QgcmVzb2x2ZVBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKSA9PiByZXNvbHZlKG9wdGlvbnMuY3dkLCAuLi5wYXRocylcblxuICBjb25zdCBtYW5pZmVzdFBhdGggPSByZXNvbHZlUGF0aChvcHRpb25zLm1hbmlmZXN0UGF0aCA/PyAnQ2FyZ28udG9tbCcpXG4gIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgcGFyc2VNZXRhZGF0YShtYW5pZmVzdFBhdGgpXG5cbiAgY29uc3QgY3JhdGUgPSBtZXRhZGF0YS5wYWNrYWdlcy5maW5kKChwKSA9PiB7XG4gICAgLy8gcGFja2FnZSB3aXRoIGdpdmVuIG5hbWVcbiAgICBpZiAob3B0aW9ucy5wYWNrYWdlKSB7XG4gICAgICByZXR1cm4gcC5uYW1lID09PSBvcHRpb25zLnBhY2thZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHAubWFuaWZlc3RfcGF0aCA9PT0gbWFuaWZlc3RQYXRoXG4gICAgfVxuICB9KVxuXG4gIGlmICghY3JhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5hYmxlIHRvIGZpbmQgY3JhdGUgdG8gYnVpbGQuIEl0IHNlZW1zIHlvdSBhcmUgdHJ5aW5nIHRvIGJ1aWxkIGEgY3JhdGUgaW4gYSB3b3Jrc3BhY2UsIHRyeSB1c2luZyBgLS1wYWNrYWdlYCBvcHRpb24gdG8gc3BlY2lmeSB0aGUgcGFja2FnZSB0byBidWlsZC4nLFxuICAgIClcbiAgfVxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICByZXNvbHZlUGF0aChvcHRpb25zLnBhY2thZ2VKc29uUGF0aCA/PyAncGFja2FnZS5qc29uJyksXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZVBhdGgob3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQnVpbGRlcihtZXRhZGF0YSwgY3JhdGUsIGNvbmZpZywgb3B0aW9ucylcblxuICByZXR1cm4gYnVpbGRlci5idWlsZCgpXG59XG5cbmNsYXNzIEJ1aWxkZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGFyZ3M6IHN0cmluZ1tdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBlbnZzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRzOiBPdXRwdXRbXSA9IFtdXG5cbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXQ6IFRhcmdldFxuICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlRGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXREaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5hYmxlVHlwZURlZjogYm9vbGVhbiA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNyYXRlOiBDcmF0ZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogTmFwaUNvbmZpZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFBhcnNlZEJ1aWxkT3B0aW9ucyxcbiAgKSB7XG4gICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldFxuICAgICAgPyBwYXJzZVRyaXBsZShvcHRpb25zLnRhcmdldClcbiAgICAgIDogcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUXG4gICAgICAgID8gcGFyc2VUcmlwbGUocHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUKVxuICAgICAgICA6IGdldFN5c3RlbURlZmF1bHRUYXJnZXQoKVxuICAgIHRoaXMuY3JhdGVEaXIgPSBwYXJzZShjcmF0ZS5tYW5pZmVzdF9wYXRoKS5kaXJcbiAgICB0aGlzLm91dHB1dERpciA9IHJlc29sdmUoXG4gICAgICB0aGlzLm9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5vdXRwdXREaXIgPz8gdGhpcy5jcmF0ZURpcixcbiAgICApXG4gICAgdGhpcy50YXJnZXREaXIgPVxuICAgICAgb3B0aW9ucy50YXJnZXREaXIgPz9cbiAgICAgIHByb2Nlc3MuZW52LkNBUkdPX0JVSUxEX1RBUkdFVF9ESVIgPz9cbiAgICAgIG1ldGFkYXRhLnRhcmdldF9kaXJlY3RvcnlcbiAgICB0aGlzLmVuYWJsZVR5cGVEZWYgPSB0aGlzLmNyYXRlLmRlcGVuZGVuY2llcy5zb21lKFxuICAgICAgKGRlcCkgPT5cbiAgICAgICAgZGVwLm5hbWUgPT09ICduYXBpLWRlcml2ZScgJiZcbiAgICAgICAgKGRlcC51c2VzX2RlZmF1bHRfZmVhdHVyZXMgfHwgZGVwLmZlYXR1cmVzLmluY2x1ZGVzKCd0eXBlLWRlZicpKSxcbiAgICApXG5cbiAgICBpZiAoIXRoaXMuZW5hYmxlVHlwZURlZikge1xuICAgICAgY29uc3QgcmVxdWlyZW1lbnRXYXJuaW5nID1cbiAgICAgICAgJ2BuYXBpLWRlcml2ZWAgY3JhdGUgaXMgbm90IHVzZWQgb3IgYHR5cGUtZGVmYCBmZWF0dXJlIGlzIG5vdCBlbmFibGVkIGZvciBgbmFwaS1kZXJpdmVgIGNyYXRlJ1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gV2lsbCBza2lwIGJpbmRpbmcgZ2VuZXJhdGlvbiBmb3IgXFxgLm5vZGVcXGAsIFxcYC53YXNpXFxgIGFuZCBcXGAuZC50c1xcYCBmaWxlcy5gLFxuICAgICAgKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMub3B0aW9ucy5kdHMgfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXIgfHxcbiAgICAgICAgdGhpcy5jb25maWcuZHRzSGVhZGVyRmlsZVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgYCR7cmVxdWlyZW1lbnRXYXJuaW5nfS4gXFxgZHRzXFxgIHJlbGF0ZWQgb3B0aW9ucyBhcmUgZW5hYmxlZCBidXQgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY2R5TGliTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2NkeWxpYicpKVxuICAgICAgPy5uYW1lXG4gIH1cblxuICBnZXQgYmluTmFtZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vcHRpb25zLmJpbiA/P1xuICAgICAgLy8gb25seSBhdmFpbGFibGUgaWYgbm90IGNkeWxpYiBvciBiaW4gbmFtZSBzcGVjaWZpZWRcbiAgICAgICh0aGlzLmNkeUxpYk5hbWVcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdGhpcy5jcmF0ZS50YXJnZXRzLmZpbmQoKHQpID0+IHQuY3JhdGVfdHlwZXMuaW5jbHVkZXMoJ2JpbicpKT8ubmFtZSlcbiAgICApXG4gIH1cblxuICBidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3Qgd2FybmluZyA9XG4gICAgICAgICdNaXNzaW5nIGBjcmF0ZS10eXBlID0gW1wiY2R5bGliXCJdYCBpbiBbbGliXSBjb25maWcuIFRoZSBidWlsZCByZXN1bHQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFzIG5vZGUgYWRkb24uJ1xuXG4gICAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICAgIGRlYnVnLndhcm4od2FybmluZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih3YXJuaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBpY2tCaW5hcnkoKVxuICAgICAgLnNldFBhY2thZ2UoKVxuICAgICAgLnNldEZlYXR1cmVzKClcbiAgICAgIC5zZXRUYXJnZXQoKVxuICAgICAgLnBpY2tDcm9zc1Rvb2xjaGFpbigpXG4gICAgICAuc2V0RW52cygpXG4gICAgICAuc2V0QnlwYXNzQXJncygpXG4gICAgICAuZXhlYygpXG4gIH1cblxuICBwcml2YXRlIHBpY2tDcm9zc1Rvb2xjaGFpbigpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VOYXBpQ3Jvc3MpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zc2AgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS11c2UtY3Jvc3NgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gdXNlIGJvdGggYC0tY3Jvc3MtY29tcGlsZWAgYW5kIGAtLXVzZS1uYXBpLWNyb3NzYCBvcHRpb25zLCBgLS1jcm9zcy1jb21waWxlYCB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICAgIClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2ZXJzaW9uLCBkb3dubG9hZCB9ID0gcmVxdWlyZSgnQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluJylcblxuICAgICAgY29uc3QgYWxpYXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudSc6ICdzMzkweC1pYm0tbGludXgtZ251JyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9vbGNoYWluUGF0aCA9IGpvaW4oXG4gICAgICAgIGhvbWVkaXIoKSxcbiAgICAgICAgJy5uYXBpLXJzJyxcbiAgICAgICAgJ2Nyb3NzLXRvb2xjaGFpbicsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHRoaXMudGFyZ2V0LnRyaXBsZSxcbiAgICAgIClcbiAgICAgIG1rZGlyU3luYyh0b29sY2hhaW5QYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KVxuICAgICAgaWYgKGV4aXN0c1N5bmMoam9pbih0b29sY2hhaW5QYXRoLCAncGFja2FnZS5qc29uJykpKSB7XG4gICAgICAgIGRlYnVnKGBUb29sY2hhaW4gJHt0b29sY2hhaW5QYXRofSBleGlzdHMsIHNraXAgZXh0cmFjdGluZ2ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJBcmNoaXZlID0gZG93bmxvYWQocHJvY2Vzcy5hcmNoLCB0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICAgIHRhckFyY2hpdmUudW5wYWNrKHRvb2xjaGFpblBhdGgpXG4gICAgICB9XG4gICAgICBjb25zdCB1cHBlckNhc2VUYXJnZXQgPSB0YXJnZXRUb0VudlZhcih0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgICBjb25zdCBjcm9zc1RhcmdldE5hbWUgPSBhbGlhc1t0aGlzLnRhcmdldC50cmlwbGVdID8/IHRoaXMudGFyZ2V0LnRyaXBsZVxuICAgICAgY29uc3QgbGlua2VyRW52ID0gYENBUkdPX1RBUkdFVF8ke3VwcGVyQ2FzZVRhcmdldH1fTElOS0VSYFxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgbGlua2VyRW52LFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsICdiaW4nLCBgJHtjcm9zc1RhcmdldE5hbWV9LWdjY2ApLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9TWVNST09UJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCBjcm9zc1RhcmdldE5hbWUsICdzeXNyb290JyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0FSJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCAnYmluJywgYCR7Y3Jvc3NUYXJnZXROYW1lfS1hcmApLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9SQU5MSUInLFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsICdiaW4nLCBgJHtjcm9zc1RhcmdldE5hbWV9LXJhbmxpYmApLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9SRUFERUxGJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCAnYmluJywgYCR7Y3Jvc3NUYXJnZXROYW1lfS1yZWFkZWxmYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NfSU5DTFVERV9QQVRIJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCBjcm9zc1RhcmdldE5hbWUsICdzeXNyb290JywgJ3VzcicsICdpbmNsdWRlLycpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DQycsXG4gICAgICAgIGpvaW4odG9vbGNoYWluUGF0aCwgJ2JpbicsIGAke2Nyb3NzVGFyZ2V0TmFtZX0tZ2NjYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NYWCcsXG4gICAgICAgIGpvaW4odG9vbGNoYWluUGF0aCwgJ2JpbicsIGAke2Nyb3NzVGFyZ2V0TmFtZX0tZysrYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnQklOREdFTl9FWFRSQV9DTEFOR19BUkdTJyxcbiAgICAgICAgYC0tc3lzcm9vdD0ke3RoaXMuZW52cy5UQVJHRVRfU1lTUk9PVH19YCxcbiAgICAgIClcblxuICAgICAgaWYgKFxuICAgICAgICBwcm9jZXNzLmVudi5UQVJHRVRfQ0M/LnN0YXJ0c1dpdGgoJ2NsYW5nJykgfHxcbiAgICAgICAgKHByb2Nlc3MuZW52LkNDPy5zdGFydHNXaXRoKCdjbGFuZycpICYmICFwcm9jZXNzLmVudi5UQVJHRVRfQ0MpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgVEFSR0VUX0NGTEFHUyA9IHByb2Nlc3MuZW52LlRBUkdFVF9DRkxBR1MgPz8gJydcbiAgICAgICAgdGhpcy5lbnZzLlRBUkdFVF9DRkxBR1MgPSBgLS1zeXNyb290PSR7dGhpcy5lbnZzLlRBUkdFVF9TWVNST09UfSAtLWdjYy10b29sY2hhaW49JHt0b29sY2hhaW5QYXRofSAke1RBUkdFVF9DRkxBR1N9YFxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAocHJvY2Vzcy5lbnYuQ1hYPy5zdGFydHNXaXRoKCdjbGFuZysrJykgJiYgIXByb2Nlc3MuZW52LlRBUkdFVF9DWFgpIHx8XG4gICAgICAgIHByb2Nlc3MuZW52LlRBUkdFVF9DWFg/LnN0YXJ0c1dpdGgoJ2NsYW5nKysnKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IFRBUkdFVF9DWFhGTEFHUyA9IHByb2Nlc3MuZW52LlRBUkdFVF9DWFhGTEFHUyA/PyAnJ1xuICAgICAgICB0aGlzLmVudnMuVEFSR0VUX0NYWEZMQUdTID0gYC0tc3lzcm9vdD0ke3RoaXMuZW52cy5UQVJHRVRfU1lTUk9PVH0gLS1nY2MtdG9vbGNoYWluPSR7dG9vbGNoYWluUGF0aH0gJHtUQVJHRVRfQ1hYRkxBR1N9YFxuICAgICAgfVxuICAgICAgdGhpcy5lbnZzLlBBVEggPSB0aGlzLmVudnMuUEFUSFxuICAgICAgICA/IGAke3Rvb2xjaGFpblBhdGh9L2Jpbjoke3RoaXMuZW52cy5QQVRIfToke3Byb2Nlc3MuZW52LlBBVEh9YFxuICAgICAgICA6IGAke3Rvb2xjaGFpblBhdGh9L2Jpbjoke3Byb2Nlc3MuZW52LlBBVEh9YFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnLndhcm4oJ1BpY2sgY3Jvc3MgdG9vbGNoYWluIGZhaWxlZCcsIGUgYXMgRXJyb3IpXG4gICAgICAvLyBpZ25vcmUsIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgZXhlYygpIHtcbiAgICBkZWJ1ZyhgU3RhcnQgYnVpbGRpbmcgY3JhdGU6ICR7dGhpcy5jcmF0ZS5uYW1lfWApXG4gICAgZGVidWcoJyAgJWknLCBgY2FyZ28gJHt0aGlzLmFyZ3Muam9pbignICcpfWApXG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cbiAgICBjb25zdCB3YXRjaCA9IHRoaXMub3B0aW9ucy53YXRjaFxuICAgIGNvbnN0IGJ1aWxkVGFzayA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MgJiYgdGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2AtLXVzZS1jcm9zc2AgYW5kIGAtLWNyb3NzLWNvbXBpbGVgIGNhbiBub3QgYmUgdXNlZCB0b2dldGhlcicsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1hbmQgPVxuICAgICAgICBwcm9jZXNzLmVudi5DQVJHTyA/PyAodGhpcy5vcHRpb25zLnVzZUNyb3NzID8gJ2Nyb3NzJyA6ICdjYXJnbycpXG4gICAgICBjb25zdCBidWlsZFByb2Nlc3MgPSBzcGF3bihjb21tYW5kLCB0aGlzLmFyZ3MsIHtcbiAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi50aGlzLmVudnMgfSxcbiAgICAgICAgc3RkaW86IHdhdGNoID8gWydpbmhlcml0JywgJ2luaGVyaXQnLCAncGlwZSddIDogJ2luaGVyaXQnLFxuICAgICAgICBjd2Q6IHRoaXMub3B0aW9ucy5jd2QsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICB9KVxuXG4gICAgICBidWlsZFByb2Nlc3Mub25jZSgnZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgZGVidWcoJyVpJywgYEJ1aWxkIGNyYXRlICR7dGhpcy5jcmF0ZS5uYW1lfSBzdWNjZXNzZnVsbHkhYClcbiAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBCdWlsZCBmYWlsZWQgd2l0aCBleGl0IGNvZGUgJHtjb2RlfWApKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBidWlsZFByb2Nlc3Mub25jZSgnZXJyb3InLCAoZSkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBCdWlsZCBmYWlsZWQgd2l0aCBlcnJvcjogJHtlLm1lc3NhZ2V9YCwgeyBjYXVzZTogZSB9KSlcbiAgICAgIH0pXG5cbiAgICAgIC8vIHdhdGNoIG1vZGUgb25seSwgdGhleSBhcmUgcGlwZWQgdGhyb3VnaCBzdGRlcnJcbiAgICAgIGJ1aWxkUHJvY2Vzcy5zdGRlcnI/Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZGF0YS50b1N0cmluZygpXG4gICAgICAgIGNvbnNvbGUuZXJyb3Iob3V0cHV0KVxuICAgICAgICBpZiAoL0ZpbmlzaGVkXFxzKGBkZXZgfGByZWxlYXNlYCkvLnRlc3Qob3V0cHV0KSkge1xuICAgICAgICAgIHRoaXMucG9zdEJ1aWxkKCkuY2F0Y2goKCkgPT4ge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICB0YXNrOiBidWlsZFRhc2sudGhlbigoKSA9PiB0aGlzLnBvc3RCdWlsZCgpKSxcbiAgICAgIGFib3J0OiAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwaWNrQmluYXJ5KCkge1xuICAgIGxldCBzZXQgPSBmYWxzZVxuICAgIGlmICh0aGlzLm9wdGlvbnMud2F0Y2gpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5DSSkge1xuICAgICAgICBkZWJ1Zy53YXJuKCdXYXRjaCBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gQ0kgZW52aXJvbm1lbnQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ1VzZSAlaScsICdjYXJnby13YXRjaCcpXG4gICAgICAgIHRyeUluc3RhbGxDYXJnb0JpbmFyeSgnY2FyZ28td2F0Y2gnLCAnd2F0Y2gnKVxuICAgICAgICAvLyB5YXJuIG5hcGkgd2F0Y2ggLS10YXJnZXQgeDg2XzY0LXVua25vd24tbGludXgtZ251IFstLWNyb3NzLWNvbXBpbGVdXG4gICAgICAgIC8vID09PT5cbiAgICAgICAgLy8gY2FyZ28gd2F0Y2ggWy4uLl0gLS0gYnVpbGQgLS10YXJnZXQgeDg2XzY0LXVua25vd24tbGludXgtZ251XG4gICAgICAgIC8vIGNhcmdvIHdhdGNoIFsuLi5dIC0tIHppZ2J1aWxkIC0tdGFyZ2V0IHg4Nl82NC11bmtub3duLWxpbnV4LWdudVxuICAgICAgICB0aGlzLmFyZ3MucHVzaChcbiAgICAgICAgICAnd2F0Y2gnLFxuICAgICAgICAgICctLXdoeScsXG4gICAgICAgICAgJy1pJyxcbiAgICAgICAgICAnKi57anMsdHMsbm9kZX0nLFxuICAgICAgICAgICctdycsXG4gICAgICAgICAgdGhpcy5jcmF0ZURpcixcbiAgICAgICAgICAnLS0nLFxuICAgICAgICAgICdjYXJnbycsXG4gICAgICAgICAgJ2J1aWxkJyxcbiAgICAgICAgKVxuICAgICAgICBzZXQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gY3Jvc3MgY29tcGlsZSB0byB3aW4zMiBwbGF0Zm9ybSBvbiB3aW4zMiBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgY2FyZ28teHdpbiB0byBjcm9zcyBjb21waWxlIHRvIHdpbjMyIHBsYXRmb3JtXG4gICAgICAgICAgZGVidWcoJ1VzZSAlaScsICdjYXJnby14d2luJylcbiAgICAgICAgICB0cnlJbnN0YWxsQ2FyZ29CaW5hcnkoJ2NhcmdvLXh3aW4nLCAneHdpbicpXG4gICAgICAgICAgdGhpcy5hcmdzLnB1c2goJ3h3aW4nLCAnYnVpbGQnKVxuICAgICAgICAgIGlmICh0aGlzLnRhcmdldC5hcmNoID09PSAnaWEzMicpIHtcbiAgICAgICAgICAgIHRoaXMuZW52cy5YV0lOX0FSQ0ggPSAneDg2J1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJlxuICAgICAgICAgIHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcgJiZcbiAgICAgICAgICB0aGlzLnRhcmdldC5hcmNoID09PSBwcm9jZXNzLmFyY2ggJiZcbiAgICAgICAgICAoZnVuY3Rpb24gKGFiaTogc3RyaW5nIHwgbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZ2xpYmNWZXJzaW9uUnVudGltZSA9XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgcHJvY2Vzcy5yZXBvcnQ/LmdldFJlcG9ydCgpPy5oZWFkZXI/LmdsaWJjVmVyc2lvblJ1bnRpbWVcbiAgICAgICAgICAgIGNvbnN0IGxpYmMgPSBnbGliY1ZlcnNpb25SdW50aW1lID8gJ2dudScgOiAnbXVzbCdcbiAgICAgICAgICAgIHJldHVybiBhYmkgPT09IGxpYmNcbiAgICAgICAgICB9KSh0aGlzLnRhcmdldC5hYmkpXG4gICAgICAgICkge1xuICAgICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB0cnlpbmcgdG8gY3Jvc3MgY29tcGlsZSB0byBsaW51eCB0YXJnZXQgb24gbGludXggcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdkYXJ3aW4nICYmXG4gICAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIGRhcndpbiB0YXJnZXQgb24gZGFyd2luIHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjYXJnby16aWdidWlsZCB0byBjcm9zcyBjb21waWxlIHRvIG90aGVyIHBsYXRmb3Jtc1xuICAgICAgICAgIGRlYnVnKCdVc2UgJWknLCAnY2FyZ28temlnYnVpbGQnKVxuICAgICAgICAgIHRyeUluc3RhbGxDYXJnb0JpbmFyeSgnY2FyZ28temlnYnVpbGQnLCAnemlnYnVpbGQnKVxuICAgICAgICAgIHRoaXMuYXJncy5wdXNoKCd6aWdidWlsZCcpXG4gICAgICAgICAgc2V0ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZXQpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCdidWlsZCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldFBhY2thZ2UoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhY2thZ2UpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1wYWNrYWdlJywgdGhpcy5vcHRpb25zLnBhY2thZ2UpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmluTmFtZSkge1xuICAgICAgYXJncy5wdXNoKCctLWJpbicsIHRoaXMuYmluTmFtZSlcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKCdTZXQgcGFja2FnZSBmbGFnczogJylcbiAgICAgIGRlYnVnKCcgICVPJywgYXJncylcbiAgICAgIHRoaXMuYXJncy5wdXNoKC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0VGFyZ2V0KCkge1xuICAgIGRlYnVnKCdTZXQgY29tcGlsaW5nIHRhcmdldCB0bzogJylcbiAgICBkZWJ1ZygnICAlaScsIHRoaXMudGFyZ2V0LnRyaXBsZSlcblxuICAgIHRoaXMuYXJncy5wdXNoKCctLXRhcmdldCcsIHRoaXMudGFyZ2V0LnRyaXBsZSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEVudnMoKSB7XG4gICAgLy8gVFlQRSBERUZcbiAgICBpZiAodGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICB0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSID1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZUludGVybWVkaWF0ZVR5cGVEZWZGb2xkZXIoKVxuICAgICAgdGhpcy5zZXRGb3JjZUJ1aWxkRW52cyh0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSKVxuICAgIH1cblxuICAgIC8vIFJVU1RGTEFHU1xuICAgIGxldCBydXN0ZmxhZ3MgPVxuICAgICAgcHJvY2Vzcy5lbnYuUlVTVEZMQUdTID8/IHByb2Nlc3MuZW52LkNBUkdPX0JVSUxEX1JVU1RGTEFHUyA/PyAnJ1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy50YXJnZXQuYWJpPy5pbmNsdWRlcygnbXVzbCcpICYmXG4gICAgICAhcnVzdGZsYWdzLmluY2x1ZGVzKCd0YXJnZXQtZmVhdHVyZT0tY3J0LXN0YXRpYycpXG4gICAgKSB7XG4gICAgICBydXN0ZmxhZ3MgKz0gJyAtQyB0YXJnZXQtZmVhdHVyZT0tY3J0LXN0YXRpYydcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0cmlwICYmICFydXN0ZmxhZ3MuaW5jbHVkZXMoJ2xpbmstYXJnPS1zJykpIHtcbiAgICAgIHJ1c3RmbGFncyArPSAnIC1DIGxpbmstYXJnPS1zJ1xuICAgIH1cblxuICAgIGlmIChydXN0ZmxhZ3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLmVudnMuUlVTVEZMQUdTID0gcnVzdGZsYWdzXG4gICAgfVxuICAgIC8vIEVORCBSVVNURkxBR1NcblxuICAgIC8vIExJTktFUlxuICAgIGNvbnN0IGxpbmtlciA9IHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGVcbiAgICAgID8gdm9pZCAwXG4gICAgICA6IGdldFRhcmdldExpbmtlcih0aGlzLnRhcmdldC50cmlwbGUpXG4gICAgLy8gVE9ETzpcbiAgICAvLyAgIGRpcmVjdGx5IHNldCBDQVJHT19UQVJHRVRfPHRhcmdldD5fTElOS0VSIHdpbGwgY292ZXIgLmNhcmdvL2NvbmZpZy50b21sXG4gICAgLy8gICB3aWxsIGRldGVjdCBieSBjYXJnbyBjb25maWcgd2hlbiBpdCBiZWNvbWVzIHN0YWJsZVxuICAgIC8vICAgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcnVzdC1sYW5nL2NhcmdvL2lzc3Vlcy85MzAxXG4gICAgY29uc3QgbGlua2VyRW52ID0gYENBUkdPX1RBUkdFVF8ke3RhcmdldFRvRW52VmFyKFxuICAgICAgdGhpcy50YXJnZXQudHJpcGxlLFxuICAgICl9X0xJTktFUmBcbiAgICBpZiAobGlua2VyICYmICFwcm9jZXNzLmVudltsaW5rZXJFbnZdICYmICF0aGlzLmVudnNbbGlua2VyRW52XSkge1xuICAgICAgdGhpcy5lbnZzW2xpbmtlckVudl0gPSBsaW5rZXJcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgICAgdGhpcy5zZXRBbmRyb2lkRW52KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3YXNpJykge1xuICAgICAgdGhpcy5zZXRXYXNpRW52KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdvcGVuaGFybW9ueScpIHtcbiAgICAgIHRoaXMuc2V0T3Blbkhhcm1vbnlFbnYoKVxuICAgIH1cblxuICAgIGRlYnVnKCdTZXQgZW52czogJylcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudnMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgZGVidWcoJyAgJWknLCBgJHtrfT0ke3Z9YClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0Rm9yY2VCdWlsZEVudnModHlwZURlZlRtcEZvbGRlcjogc3RyaW5nKSB7XG4gICAgLy8gZHluYW1pY2FsbHkgY2hlY2sgYWxsIG5hcGktcnMgZGVwcyBhbmQgc2V0IGBOQVBJX0ZPUkNFX0JVSUxEX3t1cHBlcmNhc2Uoc25ha2VfY2FzZShuYW1lKSl9ID0gdGltZXN0YW1wYFxuICAgIHRoaXMubWV0YWRhdGEucGFja2FnZXMuZm9yRWFjaCgoY3JhdGUpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgY3JhdGUuZGVwZW5kZW5jaWVzLnNvbWUoKGQpID0+IGQubmFtZSA9PT0gJ25hcGktZGVyaXZlJykgJiZcbiAgICAgICAgIWV4aXN0c1N5bmMoam9pbih0eXBlRGVmVG1wRm9sZGVyLCBjcmF0ZS5uYW1lKSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLmVudnNbXG4gICAgICAgICAgYE5BUElfRk9SQ0VfQlVJTERfJHtjcmF0ZS5uYW1lLnJlcGxhY2UoLy0vZywgJ18nKS50b1VwcGVyQ2FzZSgpfWBcbiAgICAgICAgXSA9IERhdGUubm93KCkudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIHNldEFuZHJvaWRFbnYoKSB7XG4gICAgY29uc3QgeyBBTkRST0lEX05ES19MQVRFU1RfSE9NRSB9ID0gcHJvY2Vzcy5lbnZcbiAgICBpZiAoIUFORFJPSURfTkRLX0xBVEVTVF9IT01FKSB7XG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgJHtjb2xvcnMucmVkKFxuICAgICAgICAgICdBTkRST0lEX05ES19MQVRFU1RfSE9NRScsXG4gICAgICAgICl9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG1pc3NpbmdgLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIHNraXAgY3Jvc3MgY29tcGlsZSBzZXR1cCBpZiBob3N0IGlzIGFuZHJvaWRcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRBcmNoID0gdGhpcy50YXJnZXQuYXJjaCA9PT0gJ2FybScgPyAnYXJtdjdhJyA6ICdhYXJjaDY0J1xuICAgIGNvbnN0IHRhcmdldFBsYXRmb3JtID1cbiAgICAgIHRoaXMudGFyZ2V0LmFyY2ggPT09ICdhcm0nID8gJ2FuZHJvaWRlYWJpMjQnIDogJ2FuZHJvaWQyNCdcbiAgICBjb25zdCBob3N0UGxhdGZvcm0gPVxuICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbidcbiAgICAgICAgPyAnZGFyd2luJ1xuICAgICAgICA6IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgICA/ICd3aW5kb3dzJ1xuICAgICAgICAgIDogJ2xpbnV4J1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5lbnZzLCB7XG4gICAgICBDQVJHT19UQVJHRVRfQUFSQ0g2NF9MSU5VWF9BTkRST0lEX0xJTktFUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LWFuZHJvaWQyNC1jbGFuZ2AsXG4gICAgICBDQVJHT19UQVJHRVRfQVJNVjdfTElOVVhfQU5EUk9JREVBQklfTElOS0VSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtYW5kcm9pZGVhYmkyNC1jbGFuZ2AsXG4gICAgICBUQVJHRVRfQ0M6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC0ke3RhcmdldFBsYXRmb3JtfS1jbGFuZ2AsXG4gICAgICBUQVJHRVRfQ1hYOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtJHt0YXJnZXRQbGF0Zm9ybX0tY2xhbmcrK2AsXG4gICAgICBUQVJHRVRfQVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vbGx2bS1hcmAsXG4gICAgICBUQVJHRVRfUkFOTElCOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluL2xsdm0tcmFubGliYCxcbiAgICAgIEFORFJPSURfTkRLOiBBTkRST0lEX05ES19MQVRFU1RfSE9NRSxcbiAgICAgIFBBVEg6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4ke3Byb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnOycgOiAnOid9JHtwcm9jZXNzLmVudi5QQVRIfWAsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0V2FzaUVudigpIHtcbiAgICBjb25zdCBlbW5hcGkgPSBqb2luKFxuICAgICAgcmVxdWlyZS5yZXNvbHZlKCdlbW5hcGknKSxcbiAgICAgICcuLicsXG4gICAgICAnbGliJyxcbiAgICAgICd3YXNtMzItd2FzaS10aHJlYWRzJyxcbiAgICApXG4gICAgdGhpcy5lbnZzLkVNTkFQSV9MSU5LX0RJUiA9IGVtbmFwaVxuICAgIGNvbnN0IHsgV0FTSV9TREtfUEFUSCB9ID0gcHJvY2Vzcy5lbnZcblxuICAgIGlmIChXQVNJX1NES19QQVRIICYmIGV4aXN0c1N5bmMoV0FTSV9TREtfUEFUSCkpIHtcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lfUFJFVklFVzFfVEhSRUFEU19MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAxX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDFfVEhSRUFEU19MSU5LRVIgPSBqb2luKFxuICAgICAgICBXQVNJX1NES19QQVRILFxuICAgICAgICAnYmluJyxcbiAgICAgICAgJ3dhc20tbGQnLFxuICAgICAgKVxuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSVAyX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnY2xhbmcnKSlcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYJyxcbiAgICAgICAgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2NsYW5nKysnKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUicsIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdhcicpKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9SQU5MSUInLFxuICAgICAgICBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAncmFubGliJyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NGTEFHUycsXG4gICAgICAgIGAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzIC0tc3lzcm9vdD0ke1dBU0lfU0RLX1BBVEh9L3NoYXJlL3dhc2ktc3lzcm9vdCAtcHRocmVhZCAtbWxsdm0gLXdhc20tZW5hYmxlLXNqbGpgLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DWFhGTEFHUycsXG4gICAgICAgIGAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzIC0tc3lzcm9vdD0ke1dBU0lfU0RLX1BBVEh9L3NoYXJlL3dhc2ktc3lzcm9vdCAtcHRocmVhZCAtbWxsdm0gLXdhc20tZW5hYmxlLXNqbGpgLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgYFRBUkdFVF9MREZMQUdTYCxcbiAgICAgICAgYC1mdXNlLWxkPSR7V0FTSV9TREtfUEFUSH0vYmluL3dhc20tbGQgLS10YXJnZXQ9d2FzbTMyLXdhc2ktdGhyZWFkc2AsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRPcGVuSGFybW9ueUVudigpIHtcbiAgICBjb25zdCB7IE9IT1NfU0RLX1BBVEgsIE9IT1NfU0RLX05BVElWRSB9ID0gcHJvY2Vzcy5lbnZcbiAgICBjb25zdCBuZGtQYXRoID0gT0hPU19TREtfUEFUSCA/IGAke09IT1NfU0RLX1BBVEh9L25hdGl2ZWAgOiBPSE9TX1NES19OQVRJVkVcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKCFuZGtQYXRoICYmIHByb2Nlc3MucGxhdGZvcm0gIT09ICdvcGVuaGFybW9ueScpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX1BBVEgnKX0gb3IgJHtjb2xvcnMucmVkKCdPSE9TX1NES19OQVRJVkUnKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbGlua2VyTmFtZSA9IGBDQVJHT19UQVJHRVRfJHt0aGlzLnRhcmdldC50cmlwbGUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJyl9X0xJTktFUmBcbiAgICBjb25zdCByYW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1yYW5saWJgXG4gICAgY29uc3QgYXJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hcmBcbiAgICBjb25zdCBjY1BhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi8ke3RoaXMudGFyZ2V0LnRyaXBsZX0tY2xhbmdgXG4gICAgY29uc3QgY3h4UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZysrYFxuICAgIGNvbnN0IGFzUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tYXNgXG4gICAgY29uc3QgbGRQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGQubGxkYFxuICAgIGNvbnN0IHN0cmlwUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tc3RyaXBgXG4gICAgY29uc3Qgb2JqRHVtcFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamR1bXBgXG4gICAgY29uc3Qgb2JqQ29weVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW9iamNvcHlgXG4gICAgY29uc3Qgbm1QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1ubWBcbiAgICBjb25zdCBiaW5QYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW5gXG4gICAgY29uc3QgbGliUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vbGliYFxuXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnTElCQ0xBTkdfUEFUSCcsIGxpYlBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnREVQX0FUT01JQycsICdjbGFuZ19ydC5idWlsdGlucycpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhsaW5rZXJOYW1lLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NDJywgY2NQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DWFgnLCBjeHhQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUicsIGFyUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfUkFOTElCJywgcmFuUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQVMnLCBhc1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0xEJywgbGRQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9TVFJJUCcsIHN0cmlwUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfT0JKRFVNUCcsIG9iakR1bXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpDT1BZJywgb2JqQ29weVBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX05NJywgbm1QYXRoKVxuICAgIHRoaXMuZW52cy5QQVRIID0gYCR7YmluUGF0aH0ke3Byb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnOycgOiAnOid9JHtwcm9jZXNzLmVudi5QQVRIfWBcbiAgfVxuXG4gIHByaXZhdGUgc2V0RmVhdHVyZXMoKSB7XG4gICAgY29uc3QgYXJncyA9IFtdXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxGZWF0dXJlcyAmJiB0aGlzLm9wdGlvbnMubm9EZWZhdWx0RmVhdHVyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBzcGVjaWZ5IC0tYWxsLWZlYXR1cmVzIGFuZCAtLW5vLWRlZmF1bHQtZmVhdHVyZXMgdG9nZXRoZXInLFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYWxsLWZlYXR1cmVzJylcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgYXJncy5wdXNoKCctLW5vLWRlZmF1bHQtZmVhdHVyZXMnKVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tZmVhdHVyZXMnLCAuLi50aGlzLm9wdGlvbnMuZmVhdHVyZXMpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBmZWF0dXJlcyBmbGFnczogJylcbiAgICBkZWJ1ZygnICAlTycsIGFyZ3MpXG4gICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIHNldEJ5cGFzc0FyZ3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWxlYXNlKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1yZWxlYXNlJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXZlcmJvc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS10YXJnZXQtZGlyJywgdGhpcy5vcHRpb25zLnRhcmdldERpcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnByb2ZpbGUpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXByb2ZpbGUnLCB0aGlzLm9wdGlvbnMucHJvZmlsZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tbWFuaWZlc3QtcGF0aCcsIHRoaXMub3B0aW9ucy5tYW5pZmVzdFBhdGgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jYXJnb09wdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goLi4udGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUludGVybWVkaWF0ZVR5cGVEZWZGb2xkZXIoKSB7XG4gICAgbGV0IGZvbGRlciA9IGpvaW4oXG4gICAgICB0aGlzLnRhcmdldERpcixcbiAgICAgICduYXBpLXJzJyxcbiAgICAgIGAke3RoaXMuY3JhdGUubmFtZX0tJHtjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKHRoaXMuY3JhdGUubWFuaWZlc3RfcGF0aClcbiAgICAgICAgLnVwZGF0ZShDTElfVkVSU0lPTilcbiAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgLnN1YnN0cmluZygwLCA4KX1gLFxuICAgIClcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmR0c0NhY2hlKSB7XG4gICAgICBybVN5bmMoZm9sZGVyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbiAgICAgIGZvbGRlciArPSBgXyR7RGF0ZS5ub3coKX1gXG4gICAgfVxuXG4gICAgbWtkaXJBc3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG5cbiAgICByZXR1cm4gZm9sZGVyXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBvc3RCdWlsZCgpIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeTpgKVxuICAgICAgZGVidWcoJyAgJWknLCB0aGlzLm91dHB1dERpcilcbiAgICAgIGF3YWl0IG1rZGlyQXN5bmModGhpcy5vdXRwdXREaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBkZWJ1ZyhgT3V0cHV0IGRpcmVjdG9yeSBjcmVhdGVkYClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgb3V0cHV0IGRpcmVjdG9yeSAke3RoaXMub3V0cHV0RGlyfWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHdhc21CaW5hcnlOYW1lID0gYXdhaXQgdGhpcy5jb3B5QXJ0aWZhY3QoKVxuXG4gICAgLy8gb25seSBmb3IgY2R5bGliXG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgaWRlbnRzID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVEZWYoKVxuICAgICAgY29uc3QganNPdXRwdXQgPSBhd2FpdCB0aGlzLndyaXRlSnNCaW5kaW5nKGlkZW50cylcbiAgICAgIGNvbnN0IHdhc21CaW5kaW5nc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVXYXNpQmluZGluZyhcbiAgICAgICAgd2FzbUJpbmFyeU5hbWUsXG4gICAgICAgIGlkZW50cyxcbiAgICAgIClcbiAgICAgIGlmIChqc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChqc091dHB1dClcbiAgICAgIH1cbiAgICAgIGlmICh3YXNtQmluZGluZ3NPdXRwdXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goLi4ud2FzbUJpbmRpbmdzT3V0cHV0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm91dHB1dHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY29weUFydGlmYWN0KCkge1xuICAgIGNvbnN0IFtzcmNOYW1lLCBkZXN0TmFtZSwgd2FzbUJpbmFyeU5hbWVdID0gdGhpcy5nZXRBcnRpZmFjdE5hbWVzKClcbiAgICBpZiAoIXNyY05hbWUgfHwgIWRlc3ROYW1lKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcm9maWxlID1cbiAgICAgIHRoaXMub3B0aW9ucy5wcm9maWxlID8/ICh0aGlzLm9wdGlvbnMucmVsZWFzZSA/ICdyZWxlYXNlJyA6ICdkZWJ1ZycpXG4gICAgY29uc3Qgc3JjID0gam9pbih0aGlzLnRhcmdldERpciwgdGhpcy50YXJnZXQudHJpcGxlLCBwcm9maWxlLCBzcmNOYW1lKVxuICAgIGRlYnVnKGBDb3B5IGFydGlmYWN0IGZyb206IFske3NyY31dYClcbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgZGVzdE5hbWUpXG4gICAgY29uc3QgaXNXYXNtID0gZGVzdC5lbmRzV2l0aCgnLndhc20nKVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdPbGQgYXJ0aWZhY3QgZm91bmQsIHJlbW92ZSBpdCBmaXJzdCcpXG4gICAgICAgIGF3YWl0IHVubGlua0FzeW5jKGRlc3QpXG4gICAgICB9XG4gICAgICBkZWJ1ZygnQ29weSBhcnRpZmFjdCB0bzonKVxuICAgICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgICAgaWYgKGlzV2FzbSkge1xuICAgICAgICBjb25zdCB7IE1vZHVsZUNvbmZpZyB9ID0gYXdhaXQgaW1wb3J0KCdAbmFwaS1ycy93YXNtLXRvb2xzJylcbiAgICAgICAgZGVidWcoJ0dlbmVyYXRlIGRlYnVnIHdhc20gbW9kdWxlJylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVOYW1lU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbih0cnVlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybSh0cnVlKVxuICAgICAgICAgICAgLnN0cmljdFZhbGlkYXRlKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMoc3JjKSlcbiAgICAgICAgICBjb25zdCBkZWJ1Z1dhc21CaW5hcnkgPSBkZWJ1Z1dhc21Nb2R1bGUuZW1pdFdhc20odHJ1ZSlcbiAgICAgICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgICAgIGRlc3QucmVwbGFjZSgvXFwud2FzbSQvLCAnLmRlYnVnLndhc20nKSxcbiAgICAgICAgICAgIGRlYnVnV2FzbUJpbmFyeSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcoJ0dlbmVyYXRlIHJlbGVhc2Ugd2FzbSBtb2R1bGUnKVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtTW9kdWxlID0gbmV3IE1vZHVsZUNvbmZpZygpXG4gICAgICAgICAgICAuZ2VuZXJhdGVEd2FyZihmYWxzZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlUHJvZHVjZXJzU2VjdGlvbihmYWxzZSlcbiAgICAgICAgICAgIC5wcmVzZXJ2ZUNvZGVUcmFuc2Zvcm0oZmFsc2UpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAub25seVN0YWJsZUZlYXR1cmVzKGZhbHNlKVxuICAgICAgICAgICAgLnBhcnNlKGRlYnVnV2FzbUJpbmFyeSlcbiAgICAgICAgICBjb25zdCByZWxlYXNlV2FzbUJpbmFyeSA9IHJlbGVhc2VXYXNtTW9kdWxlLmVtaXRXYXNtKGZhbHNlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIHJlbGVhc2VXYXNtQmluYXJ5KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGU6ICR7KGUgYXMgYW55KS5tZXNzYWdlID8/IGV9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGNvcHlGaWxlQXN5bmMoc3JjLCBkZXN0KVxuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgICBraW5kOiBkZXN0LmVuZHNXaXRoKCcubm9kZScpID8gJ25vZGUnIDogaXNXYXNtID8gJ3dhc20nIDogJ2V4ZScsXG4gICAgICAgIHBhdGg6IGRlc3QsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHdhc21CaW5hcnlOYW1lID8gam9pbih0aGlzLm91dHB1dERpciwgd2FzbUJpbmFyeU5hbWUpIDogbnVsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvcHkgYXJ0aWZhY3QnLCB7IGNhdXNlOiBlIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcnRpZmFjdE5hbWVzKCkge1xuICAgIGlmICh0aGlzLmNkeUxpYk5hbWUpIHtcbiAgICAgIGNvbnN0IGNkeUxpYiA9IHRoaXMuY2R5TGliTmFtZS5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIGNvbnN0IHdhc2lUYXJnZXQgPSB0aGlzLmNvbmZpZy50YXJnZXRzLmZpbmQoKHQpID0+IHQucGxhdGZvcm0gPT09ICd3YXNpJylcblxuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICAgID8gYGxpYiR7Y2R5TGlifS5keWxpYmBcbiAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgICAgICAgICA/IGAke2NkeUxpYn0uZGxsYFxuICAgICAgICAgICAgOiB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knIHx8IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbSdcbiAgICAgICAgICAgICAgPyBgJHtjZHlMaWJ9Lndhc21gXG4gICAgICAgICAgICAgIDogYGxpYiR7Y2R5TGlifS5zb2BcblxuICAgICAgbGV0IGRlc3ROYW1lID0gdGhpcy5jb25maWcuYmluYXJ5TmFtZVxuICAgICAgLy8gYWRkIHBsYXRmb3JtIHN1ZmZpeCB0byBiaW5hcnkgbmFtZVxuICAgICAgLy8gaW5kZXhbLmxpbnV4LXg2NC1nbnVdLm5vZGVcbiAgICAgIC8vICAgICAgIF5eXl5eXl5eXl5eXl5eXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBsYXRmb3JtKSB7XG4gICAgICAgIGRlc3ROYW1lICs9IGAuJHt0aGlzLnRhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YFxuICAgICAgfVxuICAgICAgaWYgKHNyY05hbWUuZW5kc1dpdGgoJy53YXNtJykpIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy53YXNtJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gJy5ub2RlJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzcmNOYW1lLFxuICAgICAgICBkZXN0TmFtZSxcbiAgICAgICAgd2FzaVRhcmdldFxuICAgICAgICAgID8gYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0uJHt3YXNpVGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgICA6IG51bGwsXG4gICAgICBdXG4gICAgfSBlbHNlIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgIGNvbnN0IHNyY05hbWUgPVxuICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGAke3RoaXMuYmluTmFtZX0uZXhlYCA6IHRoaXMuYmluTmFtZVxuXG4gICAgICByZXR1cm4gW3NyY05hbWUsIHNyY05hbWVdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZURlZigpIHtcbiAgICBjb25zdCB0eXBlRGVmRGlyID0gdGhpcy5lbnZzLk5BUElfVFlQRV9ERUZfVE1QX0ZPTERFUlxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBjb25zdCB7IGV4cG9ydHMsIGR0cyB9ID0gYXdhaXQgZ2VuZXJhdGVUeXBlRGVmKHtcbiAgICAgIHR5cGVEZWZEaXIsXG4gICAgICBub0R0c0hlYWRlcjogdGhpcy5vcHRpb25zLm5vRHRzSGVhZGVyLFxuICAgICAgZHRzSGVhZGVyOiB0aGlzLm9wdGlvbnMuZHRzSGVhZGVyLFxuICAgICAgY29uZmlnRHRzSGVhZGVyOiB0aGlzLmNvbmZpZy5kdHNIZWFkZXIsXG4gICAgICBjb25maWdEdHNIZWFkZXJGaWxlOiB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlLFxuICAgICAgY29uc3RFbnVtOiB0aGlzLm9wdGlvbnMuY29uc3RFbnVtID8/IHRoaXMuY29uZmlnLmNvbnN0RW51bSxcbiAgICAgIGN3ZDogdGhpcy5vcHRpb25zLmN3ZCxcbiAgICB9KVxuXG4gICAgY29uc3QgZGVzdCA9IGpvaW4odGhpcy5vdXRwdXREaXIsIHRoaXMub3B0aW9ucy5kdHMgPz8gJ2luZGV4LmQudHMnKVxuXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKCdXcml0aW5nIHR5cGUgZGVmIHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBkdHMsICd1dGYtOCcpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcuZXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSB0eXBlIGRlZiBmaWxlJylcbiAgICAgIGRlYnVnLmVycm9yKGUgYXMgRXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZGVzdCA9IGpvaW4odGhpcy5vdXRwdXREaXIsIHRoaXMub3B0aW9ucy5kdHMgPz8gJ2luZGV4LmQudHMnKVxuICAgICAgdGhpcy5vdXRwdXRzLnB1c2goeyBraW5kOiAnZHRzJywgcGF0aDogZGVzdCB9KVxuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHdyaXRlSnNCaW5kaW5nKGlkZW50czogc3RyaW5nW10pIHtcbiAgICByZXR1cm4gd3JpdGVKc0JpbmRpbmcoe1xuICAgICAgcGxhdGZvcm06IHRoaXMub3B0aW9ucy5wbGF0Zm9ybSxcbiAgICAgIG5vSnNCaW5kaW5nOiB0aGlzLm9wdGlvbnMubm9Kc0JpbmRpbmcsXG4gICAgICBpZGVudHMsXG4gICAgICBqc0JpbmRpbmc6IHRoaXMub3B0aW9ucy5qc0JpbmRpbmcsXG4gICAgICBlc206IHRoaXMub3B0aW9ucy5lc20sXG4gICAgICBiaW5hcnlOYW1lOiB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lLFxuICAgICAgcGFja2FnZU5hbWU6IHRoaXMuY29uZmlnLnBhY2thZ2VOYW1lLFxuICAgICAgdmVyc2lvbjogcHJvY2Vzcy5lbnYubnBtX25ld192ZXJzaW9uID8/IHRoaXMuY29uZmlnLnBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHdyaXRlV2FzaUJpbmRpbmcoXG4gICAgZGlzdEZpbGVOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIGlkZW50czogc3RyaW5nW10sXG4gICkge1xuICAgIGlmIChkaXN0RmlsZU5hbWUpIHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgZGlyIH0gPSBwYXJzZShkaXN0RmlsZU5hbWUpXG4gICAgICBjb25zdCBiaW5kaW5nUGF0aCA9IGpvaW4oZGlyLCBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS53YXNpLmNqc2ApXG4gICAgICBjb25zdCBicm93c2VyQmluZGluZ1BhdGggPSBqb2luKFxuICAgICAgICBkaXIsXG4gICAgICAgIGAke3RoaXMuY29uZmlnLmJpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgICApXG4gICAgICBjb25zdCB3b3JrZXJQYXRoID0gam9pbihkaXIsICd3YXNpLXdvcmtlci5tanMnKVxuICAgICAgY29uc3QgYnJvd3NlcldvcmtlclBhdGggPSBqb2luKGRpciwgJ3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJylcbiAgICAgIGNvbnN0IGJyb3dzZXJFbnRyeVBhdGggPSBqb2luKGRpciwgJ2Jyb3dzZXIuanMnKVxuICAgICAgY29uc3QgZXhwb3J0c0NvZGUgPVxuICAgICAgICBgbW9kdWxlLmV4cG9ydHMgPSBfX25hcGlNb2R1bGUuZXhwb3J0c1xcbmAgK1xuICAgICAgICBpZGVudHNcbiAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgKGlkZW50KSA9PlxuICAgICAgICAgICAgICBgbW9kdWxlLmV4cG9ydHMuJHtpZGVudH0gPSBfX25hcGlNb2R1bGUuZXhwb3J0cy4ke2lkZW50fWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJpbmRpbmdQYXRoLFxuICAgICAgICBjcmVhdGVXYXNpQmluZGluZyhcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnBhY2thZ2VOYW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmluaXRpYWxNZW1vcnksXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8ubWF4aW11bU1lbW9yeSxcbiAgICAgICAgKSArXG4gICAgICAgICAgZXhwb3J0c0NvZGUgK1xuICAgICAgICAgICdcXG4nLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYnJvd3NlckJpbmRpbmdQYXRoLFxuICAgICAgICBjcmVhdGVXYXNpQnJvd3NlckJpbmRpbmcoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5pbml0aWFsTWVtb3J5LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/Lm1heGltdW1NZW1vcnksXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uZnMsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uYXN5bmNJbml0LFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmJ1ZmZlcixcbiAgICAgICAgKSArXG4gICAgICAgICAgYGV4cG9ydCBkZWZhdWx0IF9fbmFwaU1vZHVsZS5leHBvcnRzXFxuYCArXG4gICAgICAgICAgaWRlbnRzXG4gICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAoaWRlbnQpID0+XG4gICAgICAgICAgICAgICAgYGV4cG9ydCBjb25zdCAke2lkZW50fSA9IF9fbmFwaU1vZHVsZS5leHBvcnRzLiR7aWRlbnR9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKSArXG4gICAgICAgICAgJ1xcbicsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHdvcmtlclBhdGgsIFdBU0lfV09SS0VSX1RFTVBMQVRFLCAndXRmOCcpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYnJvd3NlcldvcmtlclBhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyh0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5mcyA/PyBmYWxzZSksXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyRW50cnlQYXRoLFxuICAgICAgICBgZXhwb3J0ICogZnJvbSAnJHt0aGlzLmNvbmZpZy5wYWNrYWdlTmFtZX0td2FzbTMyLXdhc2knXFxuYCxcbiAgICAgIClcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYmluZGluZ1BhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBicm93c2VyQmluZGluZ1BhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiB3b3JrZXJQYXRoIH0sXG4gICAgICAgIHsga2luZDogJ2pzJywgcGF0aDogYnJvd3NlcldvcmtlclBhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBicm93c2VyRW50cnlQYXRoIH0sXG4gICAgICBdIHNhdGlzZmllcyBPdXRwdXRbXVxuICAgIH1cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHByaXZhdGUgc2V0RW52SWZOb3RFeGlzdHMoZW52OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52W2Vudl0pIHtcbiAgICAgIHRoaXMuZW52c1tlbnZdID0gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXcml0ZUpzQmluZGluZ09wdGlvbnMge1xuICBwbGF0Zm9ybT86IGJvb2xlYW5cbiAgbm9Kc0JpbmRpbmc/OiBib29sZWFuXG4gIGlkZW50czogc3RyaW5nW11cbiAganNCaW5kaW5nPzogc3RyaW5nXG4gIGVzbT86IGJvb2xlYW5cbiAgYmluYXJ5TmFtZTogc3RyaW5nXG4gIHBhY2thZ2VOYW1lOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIG91dHB1dERpcjogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUpzQmluZGluZyhcbiAgb3B0aW9uczogV3JpdGVKc0JpbmRpbmdPcHRpb25zLFxuKTogUHJvbWlzZTxPdXRwdXQgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKFxuICAgICFvcHRpb25zLnBsYXRmb3JtIHx8XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgb3B0aW9ucy5ub0pzQmluZGluZyB8fFxuICAgIG9wdGlvbnMuaWRlbnRzLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zLmpzQmluZGluZyA/PyAnaW5kZXguanMnXG5cbiAgY29uc3QgY3JlYXRlQmluZGluZyA9IG9wdGlvbnMuZXNtID8gY3JlYXRlRXNtQmluZGluZyA6IGNyZWF0ZUNqc0JpbmRpbmdcbiAgY29uc3QgYmluZGluZyA9IGNyZWF0ZUJpbmRpbmcoXG4gICAgb3B0aW9ucy5iaW5hcnlOYW1lLFxuICAgIG9wdGlvbnMucGFja2FnZU5hbWUsXG4gICAgb3B0aW9ucy5pZGVudHMsXG4gICAgLy8gaW4gbnBtIHByZXZlcnNpb24gaG9va1xuICAgIG9wdGlvbnMudmVyc2lvbixcbiAgKVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZGVzdCA9IGpvaW4ob3B0aW9ucy5vdXRwdXREaXIsIG5hbWUpXG4gICAgZGVidWcoJ1dyaXRpbmcganMgYmluZGluZyB0bzonKVxuICAgIGRlYnVnKCcgICVpJywgZGVzdClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhkZXN0LCBiaW5kaW5nLCAndXRmLTgnKVxuICAgIHJldHVybiB7IGtpbmQ6ICdqcycsIHBhdGg6IGRlc3QgfSBzYXRpc2ZpZXMgT3V0cHV0XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB3cml0ZSBqcyBiaW5kaW5nIGZpbGUnLCB7IGNhdXNlOiBlIH0pXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0ZVR5cGVEZWZPcHRpb25zIHtcbiAgdHlwZURlZkRpcjogc3RyaW5nXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhblxuICBkdHNIZWFkZXI/OiBzdHJpbmdcbiAgZHRzSGVhZGVyRmlsZT86IHN0cmluZ1xuICBjb25maWdEdHNIZWFkZXI/OiBzdHJpbmdcbiAgY29uZmlnRHRzSGVhZGVyRmlsZT86IHN0cmluZ1xuICBjb25zdEVudW0/OiBib29sZWFuXG4gIGN3ZDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVR5cGVEZWYoXG4gIG9wdGlvbnM6IEdlbmVyYXRlVHlwZURlZk9wdGlvbnMsXG4pOiBQcm9taXNlPHsgZXhwb3J0czogc3RyaW5nW107IGR0czogc3RyaW5nIH0+IHtcbiAgaWYgKCEoYXdhaXQgZGlyRXhpc3RzQXN5bmMob3B0aW9ucy50eXBlRGVmRGlyKSkpIHtcbiAgICByZXR1cm4geyBleHBvcnRzOiBbXSwgZHRzOiAnJyB9XG4gIH1cblxuICBsZXQgaGVhZGVyID0gJydcbiAgbGV0IGR0cyA9ICcnXG4gIGxldCBleHBvcnRzOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKCFvcHRpb25zLm5vRHRzSGVhZGVyKSB7XG4gICAgY29uc3QgZHRzSGVhZGVyID0gb3B0aW9ucy5kdHNIZWFkZXIgPz8gb3B0aW9ucy5jb25maWdEdHNIZWFkZXJcbiAgICAvLyBgZHRzSGVhZGVyRmlsZWAgaW4gY29uZmlnID4gYGR0c0hlYWRlcmAgaW4gY2xpIGZsYWcgPiBgZHRzSGVhZGVyYCBpbiBjb25maWdcbiAgICBpZiAob3B0aW9ucy5jb25maWdEdHNIZWFkZXJGaWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoZWFkZXIgPSBhd2FpdCByZWFkRmlsZUFzeW5jKFxuICAgICAgICAgIGpvaW4ob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnRHRzSGVhZGVyRmlsZSksXG4gICAgICAgICAgJ3V0Zi04JyxcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcmVhZCBkdHMgaGVhZGVyIGZpbGUgJHtvcHRpb25zLmNvbmZpZ0R0c0hlYWRlckZpbGV9YCxcbiAgICAgICAgICBlLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkdHNIZWFkZXIpIHtcbiAgICAgIGhlYWRlciA9IGR0c0hlYWRlclxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXIgPSBERUZBVUxUX1RZUEVfREVGX0hFQURFUlxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKG9wdGlvbnMudHlwZURlZkRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG5cbiAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnTm8gdHlwZSBkZWYgZmlsZXMgZm91bmQuIFNraXAgZ2VuZXJhdGluZyBkdHMgZmlsZS4nKVxuICAgIHJldHVybiB7IGV4cG9ydHM6IFtdLCBkdHM6ICcnIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGlmICghZmlsZS5pc0ZpbGUoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCB7IGR0czogZmlsZUR0cywgZXhwb3J0czogZmlsZUV4cG9ydHMgfSA9IGF3YWl0IHByb2Nlc3NUeXBlRGVmKFxuICAgICAgam9pbihvcHRpb25zLnR5cGVEZWZEaXIsIGZpbGUubmFtZSksXG4gICAgICBvcHRpb25zLmNvbnN0RW51bSA/PyB0cnVlLFxuICAgIClcblxuICAgIGR0cyArPSBmaWxlRHRzXG4gICAgZXhwb3J0cy5wdXNoKC4uLmZpbGVFeHBvcnRzKVxuICB9XG5cbiAgaWYgKGR0cy5pbmRleE9mKCdFeHRlcm5hbE9iamVjdDwnKSA+IC0xKSB7XG4gICAgaGVhZGVyICs9IGBcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEV4dGVybmFsT2JqZWN0PFQ+IHtcbiAgcmVhZG9ubHkgJyc6IHtcbiAgICByZWFkb25seSAnJzogdW5pcXVlIHN5bWJvbFxuICAgIFtLOiBzeW1ib2xdOiBUXG4gIH1cbn1cbmBcbiAgfVxuXG4gIGlmIChkdHMuaW5kZXhPZignVHlwZWRBcnJheScpID4gLTEpIHtcbiAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IHR5cGUgVHlwZWRBcnJheSA9IEludDhBcnJheSB8IFVpbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheSB8IEJpZ0ludDY0QXJyYXkgfCBCaWdVaW50NjRBcnJheVxuYFxuICB9XG5cbiAgZHRzID0gaGVhZGVyICsgZHRzXG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzLFxuICAgIGR0cyxcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydjcmVhdGUtbnBtLWRpcnMnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgbnBtIHBhY2thZ2UgZGlycyBmb3IgZGlmZmVyZW50IHBsYXRmb3Jtc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU5wbURpcnNPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnMoXG4gIG9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zLFxuKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnc2VtdmVyJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbiAgdHlwZSBDcmVhdGVOcG1EaXJzT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL2NyZWF0ZS1ucG0tZGlycy5qcydcbmltcG9ydCB7XG4gIGRlYnVnRmFjdG9yeSxcbiAgcmVhZE5hcGlDb25maWcsXG4gIG1rZGlyQXN5bmMgYXMgcmF3TWtkaXJBc3luYyxcbiAgcGljayxcbiAgd3JpdGVGaWxlQXN5bmMgYXMgcmF3V3JpdGVGaWxlQXN5bmMsXG4gIHR5cGUgVGFyZ2V0LFxuICB0eXBlIENvbW1vblBhY2thZ2VKc29uRmllbGRzLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2NyZWF0ZS1ucG0tZGlycycpXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFja2FnZU1ldGEge1xuICAnZGlzdC10YWdzJzogeyBbaW5kZXg6IHN0cmluZ106IHN0cmluZyB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVOcG1EaXJzKHVzZXJPcHRpb25zOiBDcmVhdGVOcG1EaXJzT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0Q3JlYXRlTnBtRGlyc09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgYXN5bmMgZnVuY3Rpb24gbWtkaXJBc3luYyhkaXI6IHN0cmluZykge1xuICAgIGRlYnVnKCdUcnkgdG8gY3JlYXRlIGRpcjogJWknLCBkaXIpXG4gICAgaWYgKG9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdNa2RpckFzeW5jKGRpciwge1xuICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgIH0pXG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB3cml0ZUZpbGVBc3luYyhmaWxlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xuICAgIGRlYnVnKCdXcml0aW5nIGZpbGUgJWknLCBmaWxlKVxuXG4gICAgaWYgKG9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICBkZWJ1Zyhjb250ZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXdhaXQgcmF3V3JpdGVGaWxlQXN5bmMoZmlsZSwgY29udGVudClcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCBucG1QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5ucG1EaXIpXG5cbiAgZGVidWcoYFJlYWQgY29udGVudCBmcm9tIFske29wdGlvbnMuY29uZmlnUGF0aCA/PyBwYWNrYWdlSnNvblBhdGh9XWApXG5cbiAgY29uc3QgeyB0YXJnZXRzLCBiaW5hcnlOYW1lLCBwYWNrYWdlTmFtZSwgcGFja2FnZUpzb24gfSA9XG4gICAgYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICAgIClcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgY29uc3QgdGFyZ2V0RGlyID0gam9pbihucG1QYXRoLCBgJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWApXG4gICAgYXdhaXQgbWtkaXJBc3luYyh0YXJnZXREaXIpXG5cbiAgICBjb25zdCBiaW5hcnlGaWxlTmFtZSA9XG4gICAgICB0YXJnZXQuYXJjaCA9PT0gJ3dhc20zMidcbiAgICAgICAgPyBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lndhc21gXG4gICAgICAgIDogYCR7YmluYXJ5TmFtZX0uJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfS5ub2RlYFxuICAgIGNvbnN0IHNjb3BlZFBhY2thZ2VKc29uOiBDb21tb25QYWNrYWdlSnNvbkZpZWxkcyA9IHtcbiAgICAgIG5hbWU6IGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YCxcbiAgICAgIHZlcnNpb246IHBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgICBjcHU6IHRhcmdldC5hcmNoICE9PSAndW5pdmVyc2FsJyA/IFt0YXJnZXQuYXJjaF0gOiB1bmRlZmluZWQsXG4gICAgICBtYWluOiBiaW5hcnlGaWxlTmFtZSxcbiAgICAgIGZpbGVzOiBbYmluYXJ5RmlsZU5hbWVdLFxuICAgICAgLi4ucGljayhcbiAgICAgICAgcGFja2FnZUpzb24sXG4gICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICdrZXl3b3JkcycsXG4gICAgICAgICdhdXRob3InLFxuICAgICAgICAnYXV0aG9ycycsXG4gICAgICAgICdob21lcGFnZScsXG4gICAgICAgICdsaWNlbnNlJyxcbiAgICAgICAgJ2VuZ2luZXMnLFxuICAgICAgICAncmVwb3NpdG9yeScsXG4gICAgICAgICdidWdzJyxcbiAgICAgICksXG4gICAgfVxuICAgIGlmIChwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnID0gcGljayhcbiAgICAgICAgcGFja2FnZUpzb24ucHVibGlzaENvbmZpZyxcbiAgICAgICAgJ3JlZ2lzdHJ5JyxcbiAgICAgICAgJ2FjY2VzcycsXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0YXJnZXQuYXJjaCAhPT0gJ3dhc20zMicpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLm9zID0gW3RhcmdldC5wbGF0Zm9ybV1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZW50cnkgPSBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2BcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLm1haW4gPSBlbnRyeVxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uYnJvd3NlciA9IGAke2JpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2BcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmZpbGVzPy5wdXNoKFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgc2NvcGVkUGFja2FnZUpzb24uYnJvd3NlcixcbiAgICAgICAgYHdhc2ktd29ya2VyLm1qc2AsXG4gICAgICAgIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2AsXG4gICAgICApXG4gICAgICBsZXQgbmVlZFJlc3RyaWN0Tm9kZVZlcnNpb24gPSB0cnVlXG4gICAgICBpZiAoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcz8ubm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgbWFqb3IgfSA9IHBhcnNlKHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMubm9kZSkgPz8ge1xuICAgICAgICAgICAgbWFqb3I6IDAsXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYWpvciA+PSAxNCkge1xuICAgICAgICAgICAgbmVlZFJlc3RyaWN0Tm9kZVZlcnNpb24gPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbikge1xuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzID0ge1xuICAgICAgICAgIG5vZGU6ICc+PTE0LjAuMCcsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhc21SdW50aW1lID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIGBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9AbmFwaS1ycy93YXNtLXJ1bnRpbWVgLFxuICAgICAgKS50aGVuKChyZXMpID0+IHJlcy5qc29uKCkgYXMgUHJvbWlzZTxQYWNrYWdlTWV0YT4pXG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgICdAbmFwaS1ycy93YXNtLXJ1bnRpbWUnOiBgXiR7d2FzbVJ1bnRpbWVbJ2Rpc3QtdGFncyddLmxhdGVzdH1gLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0YXJnZXQuYWJpID09PSAnZ251Jykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubGliYyA9IFsnZ2xpYmMnXVxuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmFiaSA9PT0gJ211c2wnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydtdXNsJ11cbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRQYWNrYWdlSnNvbiA9IGpvaW4odGFyZ2V0RGlyLCAncGFja2FnZS5qc29uJylcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIHRhcmdldFBhY2thZ2VKc29uLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoc2NvcGVkUGFja2FnZUpzb24sIG51bGwsIDIpICsgJ1xcbicsXG4gICAgKVxuICAgIGNvbnN0IHRhcmdldFJlYWRtZSA9IGpvaW4odGFyZ2V0RGlyLCAnUkVBRE1FLm1kJylcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyh0YXJnZXRSZWFkbWUsIHJlYWRtZShwYWNrYWdlTmFtZSwgdGFyZ2V0KSlcblxuICAgIGRlYnVnLmluZm8oYCR7cGFja2FnZU5hbWV9IC0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9IGNyZWF0ZWRgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRtZShwYWNrYWdlTmFtZTogc3RyaW5nLCB0YXJnZXQ6IFRhcmdldCkge1xuICByZXR1cm4gYCMgXFxgJHtwYWNrYWdlTmFtZX0tJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfVxcYFxuXG5UaGlzIGlzIHRoZSAqKiR7dGFyZ2V0LnRyaXBsZX0qKiBiaW5hcnkgZm9yIFxcYCR7cGFja2FnZU5hbWV9XFxgXG5gXG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuaW1wb3J0ICogYXMgdHlwYW5pb24gZnJvbSAndHlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlTmV3Q29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyduZXcnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBhIG5ldyBwcm9qZWN0IHdpdGggcHJlLWNvbmZpZ3VyZWQgYm9pbGVycGxhdGUnLFxuICB9KVxuXG4gICQkcGF0aCA9IE9wdGlvbi5TdHJpbmcoeyByZXF1aXJlZDogZmFsc2UgfSlcblxuICAkJG5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLW5hbWUsLW4nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIG5hbWUgb2YgdGhlIHByb2plY3QsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSBpZiBub3QgcHJvdmlkZWQnLFxuICB9KVxuXG4gIG1pbk5vZGVBcGlWZXJzaW9uID0gT3B0aW9uLlN0cmluZygnLS1taW4tbm9kZS1hcGksLXYnLCAnNCcsIHtcbiAgICB2YWxpZGF0b3I6IHR5cGFuaW9uLmlzTnVtYmVyKCksXG4gICAgZGVzY3JpcHRpb246ICdUaGUgbWluaW11bSBOb2RlLUFQSSB2ZXJzaW9uIHRvIHN1cHBvcnQnLFxuICB9KVxuXG4gIHBhY2thZ2VNYW5hZ2VyID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLW1hbmFnZXInLCAneWFybicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBwYWNrYWdlIG1hbmFnZXIgdG8gdXNlLiBPbmx5IHN1cHBvcnQgeWFybiA0LnggZm9yIG5vdy4nLFxuICB9KVxuXG4gIGxpY2Vuc2UgPSBPcHRpb24uU3RyaW5nKCctLWxpY2Vuc2UsLWwnLCAnTUlUJywge1xuICAgIGRlc2NyaXB0aW9uOiAnTGljZW5zZSBmb3Igb3Blbi1zb3VyY2VkIHByb2plY3QnLFxuICB9KVxuXG4gIHRhcmdldHMgPSBPcHRpb24uQXJyYXkoJy0tdGFyZ2V0cywtdCcsIFtdLCB7XG4gICAgZGVzY3JpcHRpb246ICdBbGwgdGFyZ2V0cyB0aGUgY3JhdGUgd2lsbCBiZSBjb21waWxlZCBmb3IuJyxcbiAgfSlcblxuICBlbmFibGVEZWZhdWx0VGFyZ2V0cyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1kZWZhdWx0LXRhcmdldHMnLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGVuYWJsZSBkZWZhdWx0IHRhcmdldHMnLFxuICB9KVxuXG4gIGVuYWJsZUFsbFRhcmdldHMgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtYWxsLXRhcmdldHMnLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBlbmFibGUgYWxsIHRhcmdldHMnLFxuICB9KVxuXG4gIGVuYWJsZVR5cGVEZWYgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtdHlwZS1kZWYnLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnV2hldGhlciBlbmFibGUgdGhlIGB0eXBlLWRlZmAgZmVhdHVyZSBmb3IgdHlwZXNjcmlwdCBkZWZpbml0aW9ucyBhdXRvLWdlbmVyYXRpb24nLFxuICB9KVxuXG4gIGVuYWJsZUdpdGh1YkFjdGlvbnMgPSBPcHRpb24uQm9vbGVhbignLS1lbmFibGUtZ2l0aHViLWFjdGlvbnMnLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGdlbmVyYXRlIHByZWNvbmZpZ3VyZWQgR2l0SHViIEFjdGlvbnMgd29ya2Zsb3cnLFxuICB9KVxuXG4gIHRlc3RGcmFtZXdvcmsgPSBPcHRpb24uU3RyaW5nKCctLXRlc3QtZnJhbWV3b3JrJywgJ2F2YScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgSmF2YVNjcmlwdCB0ZXN0IGZyYW1ld29yayB0byB1c2UsIG9ubHkgc3VwcG9ydCBgYXZhYCBmb3Igbm93JyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gcnVuIHRoZSBjb21tYW5kIGluIGRyeS1ydW4gbW9kZScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogdGhpcy4kJHBhdGgsXG4gICAgICBuYW1lOiB0aGlzLiQkbmFtZSxcbiAgICAgIG1pbk5vZGVBcGlWZXJzaW9uOiB0aGlzLm1pbk5vZGVBcGlWZXJzaW9uLFxuICAgICAgcGFja2FnZU1hbmFnZXI6IHRoaXMucGFja2FnZU1hbmFnZXIsXG4gICAgICBsaWNlbnNlOiB0aGlzLmxpY2Vuc2UsXG4gICAgICB0YXJnZXRzOiB0aGlzLnRhcmdldHMsXG4gICAgICBlbmFibGVEZWZhdWx0VGFyZ2V0czogdGhpcy5lbmFibGVEZWZhdWx0VGFyZ2V0cyxcbiAgICAgIGVuYWJsZUFsbFRhcmdldHM6IHRoaXMuZW5hYmxlQWxsVGFyZ2V0cyxcbiAgICAgIGVuYWJsZVR5cGVEZWY6IHRoaXMuZW5hYmxlVHlwZURlZixcbiAgICAgIGVuYWJsZUdpdGh1YkFjdGlvbnM6IHRoaXMuZW5hYmxlR2l0aHViQWN0aW9ucyxcbiAgICAgIHRlc3RGcmFtZXdvcms6IHRoaXMudGVzdEZyYW1ld29yayxcbiAgICAgIGRyeVJ1bjogdGhpcy5kcnlSdW4sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHByb2plY3Qgd2l0aCBwcmUtY29uZmlndXJlZCBib2lsZXJwbGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ld09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggd2hlcmUgdGhlIE5BUEktUlMgcHJvamVjdCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBwYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IGlmIG5vdCBwcm92aWRlZFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gTm9kZS1BUEkgdmVyc2lvbiB0byBzdXBwb3J0XG4gICAqXG4gICAqIEBkZWZhdWx0IDRcbiAgICovXG4gIG1pbk5vZGVBcGlWZXJzaW9uPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUaGUgcGFja2FnZSBtYW5hZ2VyIHRvIHVzZS4gT25seSBzdXBwb3J0IHlhcm4gNC54IGZvciBub3cuXG4gICAqXG4gICAqIEBkZWZhdWx0ICd5YXJuJ1xuICAgKi9cbiAgcGFja2FnZU1hbmFnZXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIExpY2Vuc2UgZm9yIG9wZW4tc291cmNlZCBwcm9qZWN0XG4gICAqXG4gICAqIEBkZWZhdWx0ICdNSVQnXG4gICAqL1xuICBsaWNlbnNlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgdGFyZ2V0cyB0aGUgY3JhdGUgd2lsbCBiZSBjb21waWxlZCBmb3IuXG4gICAqXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqL1xuICB0YXJnZXRzPzogc3RyaW5nW11cbiAgLyoqXG4gICAqIFdoZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0c1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGVEZWZhdWx0VGFyZ2V0cz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZW5hYmxlIGFsbCB0YXJnZXRzXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBlbmFibGVBbGxUYXJnZXRzPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgdGhlIGB0eXBlLWRlZmAgZmVhdHVyZSBmb3IgdHlwZXNjcmlwdCBkZWZpbml0aW9ucyBhdXRvLWdlbmVyYXRpb25cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlVHlwZURlZj86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZ2VuZXJhdGUgcHJlY29uZmlndXJlZCBHaXRIdWIgQWN0aW9ucyB3b3JrZmxvd1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGVHaXRodWJBY3Rpb25zPzogYm9vbGVhblxuICAvKipcbiAgICogVGhlIEphdmFTY3JpcHQgdGVzdCBmcmFtZXdvcmsgdG8gdXNlLCBvbmx5IHN1cHBvcnQgYGF2YWAgZm9yIG5vd1xuICAgKlxuICAgKiBAZGVmYXVsdCAnYXZhJ1xuICAgKi9cbiAgdGVzdEZyYW1ld29yaz86IHN0cmluZ1xuICAvKipcbiAgICogV2hldGhlciB0byBydW4gdGhlIGNvbW1hbmQgaW4gZHJ5LXJ1biBtb2RlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHROZXdPcHRpb25zKG9wdGlvbnM6IE5ld09wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBtaW5Ob2RlQXBpVmVyc2lvbjogNCxcbiAgICBwYWNrYWdlTWFuYWdlcjogJ3lhcm4nLFxuICAgIGxpY2Vuc2U6ICdNSVQnLFxuICAgIHRhcmdldHM6IFtdLFxuICAgIGVuYWJsZURlZmF1bHRUYXJnZXRzOiB0cnVlLFxuICAgIGVuYWJsZUFsbFRhcmdldHM6IGZhbHNlLFxuICAgIGVuYWJsZVR5cGVEZWY6IHRydWUsXG4gICAgZW5hYmxlR2l0aHViQWN0aW9uczogdHJ1ZSxcbiAgICB0ZXN0RnJhbWV3b3JrOiAnYXZhJyxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG4vLyBCYXJlIGtleXMgbWF5IG9ubHkgY29udGFpbiBBU0NJSSBsZXR0ZXJzLFxuLy8gQVNDSUkgZGlnaXRzLCB1bmRlcnNjb3JlcywgYW5kIGRhc2hlcyAoQS1aYS16MC05Xy0pLlxuZnVuY3Rpb24gam9pbktleXMoa2V5cykge1xuICAvLyBEb3R0ZWQga2V5cyBhcmUgYSBzZXF1ZW5jZSBvZiBiYXJlIG9yIHF1b3RlZCBrZXlzIGpvaW5lZCB3aXRoIGEgZG90LlxuICAvLyBUaGlzIGFsbG93cyBmb3IgZ3JvdXBpbmcgc2ltaWxhciBwcm9wZXJ0aWVzIHRvZ2V0aGVyOlxuICByZXR1cm4ga2V5cy5tYXAoKHN0cik9PntcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMCB8fCBzdHIubWF0Y2goL1teQS1aYS16MC05Xy1dLykgPyBKU09OLnN0cmluZ2lmeShzdHIpIDogc3RyO1xuICB9KS5qb2luKFwiLlwiKTtcbn1cbmNsYXNzIER1bXBlciB7XG4gIG1heFBhZCA9IDA7XG4gIHNyY09iamVjdDtcbiAgb3V0cHV0ID0gW107XG4gICNhcnJheVR5cGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3Ioc3JjT2JqYyl7XG4gICAgdGhpcy5zcmNPYmplY3QgPSBzcmNPYmpjO1xuICB9XG4gIGR1bXAoZm10T3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuI3ByaW50T2JqZWN0KHRoaXMuc3JjT2JqZWN0KTtcbiAgICB0aGlzLm91dHB1dCA9IHRoaXMuI2Zvcm1hdChmbXRPcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQ7XG4gIH1cbiAgI3ByaW50T2JqZWN0KG9iaiwga2V5cyA9IFtdKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGlubGluZVByb3BzID0gW107XG4gICAgY29uc3QgbXVsdGlsaW5lUHJvcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpe1xuICAgICAgaWYgKHRoaXMuI2lzU2ltcGx5U2VyaWFsaXphYmxlKG9ialtwcm9wXSkpIHtcbiAgICAgICAgaW5saW5lUHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpbGluZVByb3BzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvcnRlZFByb3BzID0gaW5saW5lUHJvcHMuY29uY2F0KG11bHRpbGluZVByb3BzKTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc29ydGVkUHJvcHMpe1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2RhdGVEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jc3RyRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jbnVtYmVyRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNib29sRGVjbGFyYXRpb24oW1xuICAgICAgICAgIHByb3BcbiAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBjb25zdCBhcnJheVR5cGUgPSB0aGlzLiNnZXRUeXBlT2ZBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChhcnJheVR5cGUgPT09IFwiT05MWV9QUklNSVRJVkVcIikge1xuICAgICAgICAgIG91dC5wdXNoKHRoaXMuI2FycmF5RGVjbGFyYXRpb24oW1xuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXlUeXBlID09PSBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBvdXQucHVzaChcIlwiKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHRoaXMuI2hlYWRlckdyb3VwKFtcbiAgICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgb3V0LnB1c2goLi4udGhpcy4jcHJpbnRPYmplY3QodmFsdWVbaV0sIFtcbiAgICAgICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgY29tcGxleCBhcnJheSwgdXNlIHRoZSBpbmxpbmUgZm9ybWF0LlxuICAgICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLm1hcCgoeCk9PnRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh4KSkuam9pbihcIixcIik7XG4gICAgICAgICAgb3V0LnB1c2goYCR7dGhpcy4jZGVjbGFyYXRpb24oW1xuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0pfVske3N0cn1dYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG91dC5wdXNoKFwiXCIpO1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNoZWFkZXIoW1xuICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdKSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHRvUGFyc2UgPSB2YWx1ZTtcbiAgICAgICAgICBvdXQucHVzaCguLi50aGlzLiNwcmludE9iamVjdCh0b1BhcnNlLCBbXG4gICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgIF0pKTtcbiAgICAgICAgfVxuICAgICAgLy8gb3V0LnB1c2goLi4udGhpcy5fcGFyc2UodmFsdWUsIGAke3BhdGh9JHtwcm9wfS5gKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dC5wdXNoKFwiXCIpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgI2lzUHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBbXG4gICAgICBcInN0cmluZ1wiLFxuICAgICAgXCJudW1iZXJcIixcbiAgICAgIFwiYm9vbGVhblwiXG4gICAgXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpO1xuICB9XG4gICNnZXRUeXBlT2ZBcnJheShhcnIpIHtcbiAgICBpZiAodGhpcy4jYXJyYXlUeXBlQ2FjaGUuaGFzKGFycikpIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcnJheVR5cGVDYWNoZS5nZXQoYXJyKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuI2RvR2V0VHlwZU9mQXJyYXkoYXJyKTtcbiAgICB0aGlzLiNhcnJheVR5cGVDYWNoZS5zZXQoYXJyLCB0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICAjZG9HZXRUeXBlT2ZBcnJheShhcnIpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgIC8vIGFueSB0eXBlIHNob3VsZCBiZSBmaW5lXG4gICAgICByZXR1cm4gXCJPTkxZX1BSSU1JVElWRVwiO1xuICAgIH1cbiAgICBjb25zdCBvbmx5UHJpbWl0aXZlID0gdGhpcy4jaXNQcmltaXRpdmUoYXJyWzBdKTtcbiAgICBpZiAoYXJyWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiBcIk1JWEVEXCI7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgICAgaWYgKG9ubHlQcmltaXRpdmUgIT09IHRoaXMuI2lzUHJpbWl0aXZlKGFycltpXSkgfHwgYXJyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwiTUlYRURcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9ubHlQcmltaXRpdmUgPyBcIk9OTFlfUFJJTUlUSVZFXCIgOiBcIk9OTFlfT0JKRUNUX0VYQ0xVRElOR19BUlJBWVwiO1xuICB9XG4gICNwcmludEFzSW5saW5lVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gYFwiJHt0aGlzLiNwcmludERhdGUodmFsdWUpfVwiYDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLm1hcCgoeCk9PnRoaXMuI3ByaW50QXNJbmxpbmVWYWx1ZSh4KSkuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYFske3N0cn1dYDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2hcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHIgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChrZXkpPT57XG4gICAgICAgIHJldHVybiBgJHtqb2luS2V5cyhbXG4gICAgICAgICAga2V5XG4gICAgICAgIF0pfSA9ICR7Ly8gZGVuby1saW50LWlnbm9yZSBuby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHZhbHVlW2tleV0pfWA7XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBgeyR7c3RyfX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2hcIik7XG4gIH1cbiAgI2lzU2ltcGx5U2VyaWFsaXphYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB0aGlzLiNnZXRUeXBlT2ZBcnJheSh2YWx1ZSkgIT09IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCI7XG4gIH1cbiAgI2hlYWRlcihrZXlzKSB7XG4gICAgcmV0dXJuIGBbJHtqb2luS2V5cyhrZXlzKX1dYDtcbiAgfVxuICAjaGVhZGVyR3JvdXAoa2V5cykge1xuICAgIHJldHVybiBgW1ske2pvaW5LZXlzKGtleXMpfV1dYDtcbiAgfVxuICAjZGVjbGFyYXRpb24oa2V5cykge1xuICAgIGNvbnN0IHRpdGxlID0gam9pbktleXMoa2V5cyk7XG4gICAgaWYgKHRpdGxlLmxlbmd0aCA+IHRoaXMubWF4UGFkKSB7XG4gICAgICB0aGlzLm1heFBhZCA9IHRpdGxlLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RpdGxlfSA9IGA7XG4gIH1cbiAgI2FycmF5RGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgfVxuICAjc3RyRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgfVxuICAjbnVtYmVyRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfW5hbmA7XG4gICAgfVxuICAgIHN3aXRjaCh2YWx1ZSl7XG4gICAgICBjYXNlIEluZmluaXR5OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9aW5mYDtcbiAgICAgIGNhc2UgLUluZmluaXR5OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9LWluZmA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt2YWx1ZX1gO1xuICAgIH1cbiAgfVxuICAjYm9vbERlY2xhcmF0aW9uKGtleXMsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuI2RlY2xhcmF0aW9uKGtleXMpfSR7dmFsdWV9YDtcbiAgfVxuICAjcHJpbnREYXRlKHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gZHRQYWQodiwgbFBhZCA9IDIpIHtcbiAgICAgIHJldHVybiB2LnBhZFN0YXJ0KGxQYWQsIFwiMFwiKTtcbiAgICB9XG4gICAgY29uc3QgbSA9IGR0UGFkKCh2YWx1ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgZCA9IGR0UGFkKHZhbHVlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBoID0gZHRQYWQodmFsdWUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBtaW4gPSBkdFBhZCh2YWx1ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgcyA9IGR0UGFkKHZhbHVlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBtcyA9IGR0UGFkKHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCksIDMpO1xuICAgIC8vIGZvcm1hdHRlZCBkYXRlXG4gICAgY29uc3QgZkRhdGEgPSBgJHt2YWx1ZS5nZXRVVENGdWxsWWVhcigpfS0ke219LSR7ZH1UJHtofToke21pbn06JHtzfS4ke21zfWA7XG4gICAgcmV0dXJuIGZEYXRhO1xuICB9XG4gICNkYXRlRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt0aGlzLiNwcmludERhdGUodmFsdWUpfWA7XG4gIH1cbiAgI2Zvcm1hdChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGtleUFsaWdubWVudCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJEZWNsYXJhdGlvbiA9IC9eKFxcXCIuKlxcXCJ8W149XSopXFxzPS87XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0Lmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLm91dHB1dFtpXTtcbiAgICAgIC8vIHdlIGtlZXAgZW1wdHkgZW50cnkgZm9yIGFycmF5IG9mIG9iamVjdHNcbiAgICAgIGlmIChsWzBdID09PSBcIltcIiAmJiBsWzFdICE9PSBcIltcIikge1xuICAgICAgICAvLyBub24tZW1wdHkgb2JqZWN0IHdpdGggb25seSBzdWJvYmplY3RzIGFzIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0W2kgKyAxXSA9PT0gXCJcIiAmJiB0aGlzLm91dHB1dFtpICsgMl0/LnNsaWNlKDAsIGwubGVuZ3RoKSA9PT0gbC5zbGljZSgwLCAtMSkgKyBcIi5cIikge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXlBbGlnbm1lbnQpIHtcbiAgICAgICAgICBjb25zdCBtID0gckRlY2xhcmF0aW9uLmV4ZWMobCk7XG4gICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgb3V0LnB1c2gobC5yZXBsYWNlKG1bMV0sIG1bMV0ucGFkRW5kKHRoaXMubWF4UGFkKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0LnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYW5pbmcgbXVsdGlwbGUgc3BhY2VzXG4gICAgY29uc3QgY2xlYW5lZE91dHB1dCA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspe1xuICAgICAgY29uc3QgbCA9IG91dFtpXTtcbiAgICAgIGlmICghKGwgPT09IFwiXCIgJiYgb3V0W2kgKyAxXSA9PT0gXCJcIikpIHtcbiAgICAgICAgY2xlYW5lZE91dHB1dC5wdXNoKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xlYW5lZE91dHB1dDtcbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgdG8gYSB7QGxpbmsgaHR0cHM6Ly90b21sLmlvIHwgVE9NTH0gc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSBcIkBzdGQvdG9tbC9zdHJpbmdpZnlcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IG9iaiA9IHtcbiAqICAgdGl0bGU6IFwiVE9NTCBFeGFtcGxlXCIsXG4gKiAgIG93bmVyOiB7XG4gKiAgICAgbmFtZTogXCJCb2JcIixcbiAqICAgICBiaW86IFwiQm9iIGlzIGEgY29vbCBndXlcIixcbiAqICB9XG4gKiB9O1xuICogY29uc3QgdG9tbFN0cmluZyA9IHN0cmluZ2lmeShvYmopO1xuICogYXNzZXJ0RXF1YWxzKHRvbWxTdHJpbmcsIGB0aXRsZSA9IFwiVE9NTCBFeGFtcGxlXCJcXG5cXG5bb3duZXJdXFxubmFtZSA9IFwiQm9iXCJcXG5iaW8gPSBcIkJvYiBpcyBhIGNvb2wgZ3V5XCJcXG5gKTtcbiAqIGBgYFxuICogQHBhcmFtIG9iaiBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciBzdHJpbmdpZnlpbmcuXG4gKiBAcmV0dXJucyBUT01MIHN0cmluZ1xuICovIGV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkob2JqLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRHVtcGVyKG9iaikuZHVtcChvcHRpb25zKS5qb2luKFwiXFxuXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5naWZ5LmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG4vKipcbiAqIEZpbHRlcnMgdGhlIGdpdmVuIGFycmF5LCByZW1vdmluZyBhbGwgZWxlbWVudHMgdGhhdCBkbyBub3QgbWF0Y2ggdGhlIGdpdmVuIHByZWRpY2F0ZVxuICogKippbiBwbGFjZS4gVGhpcyBtZWFucyBgYXJyYXlgIHdpbGwgYmUgbW9kaWZpZWQhKiouXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckluUGxhY2UoYXJyYXksIHByZWRpY2F0ZSkge1xuICBsZXQgb3V0cHV0SW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGN1ciBvZiBhcnJheSl7XG4gICAgaWYgKCFwcmVkaWNhdGUoY3VyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFycmF5W291dHB1dEluZGV4XSA9IGN1cjtcbiAgICBvdXRwdXRJbmRleCArPSAxO1xuICB9XG4gIGFycmF5LnNwbGljZShvdXRwdXRJbmRleCk7XG4gIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91dGlscy5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuaW1wb3J0IHsgZmlsdGVySW5QbGFjZSB9IGZyb20gXCIuL191dGlscy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBNZXJnZShyZWNvcmQsIG90aGVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBkZWVwTWVyZ2VJbnRlcm5hbChyZWNvcmQsIG90aGVyLCBuZXcgU2V0KCksIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlSW50ZXJuYWwocmVjb3JkLCBvdGhlciwgc2Vlbiwgb3B0aW9ucykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoW1xuICAgIC4uLmdldEtleXMocmVjb3JkKSxcbiAgICAuLi5nZXRLZXlzKG90aGVyKVxuICBdKTtcbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2gga2V5IG9mIG90aGVyIG9iamVjdCBhbmQgdXNlIGNvcnJlY3QgbWVyZ2luZyBzdHJhdGVneVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKXtcbiAgICAvLyBTa2lwIHRvIHByZXZlbnQgT2JqZWN0LnByb3RvdHlwZS5fX3Byb3RvX18gYWNjZXNzb3IgcHJvcGVydHkgY2FsbHMgb24gbm9uLURlbm8gcGxhdGZvcm1zXG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGEgPSByZWNvcmRba2V5XTtcbiAgICBpZiAoIU9iamVjdC5oYXNPd24ob3RoZXIsIGtleSkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gYTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBiID0gb3RoZXJba2V5XTtcbiAgICBpZiAoaXNOb25OdWxsT2JqZWN0KGEpICYmIGlzTm9uTnVsbE9iamVjdChiKSAmJiAhc2Vlbi5oYXMoYSkgJiYgIXNlZW4uaGFzKGIpKSB7XG4gICAgICBzZWVuLmFkZChhKTtcbiAgICAgIHNlZW4uYWRkKGIpO1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9iamVjdHMoYSwgYiwgc2Vlbiwgb3B0aW9ucyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGUgdmFsdWVcbiAgICByZXN1bHRba2V5XSA9IGI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhsZWZ0LCByaWdodCwgc2Vlbiwgb3B0aW9ucyA9IHtcbiAgYXJyYXlzOiBcIm1lcmdlXCIsXG4gIHNldHM6IFwibWVyZ2VcIixcbiAgbWFwczogXCJtZXJnZVwiXG59KSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG1lcmdlYWJsZSBvYmplY3RzXG4gIGlmIChpc01lcmdlYWJsZShsZWZ0KSAmJiBpc01lcmdlYWJsZShyaWdodCkpIHtcbiAgICByZXR1cm4gZGVlcE1lcmdlSW50ZXJuYWwobGVmdCwgcmlnaHQsIHNlZW4sIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0l0ZXJhYmxlKGxlZnQpICYmIGlzSXRlcmFibGUocmlnaHQpKSB7XG4gICAgLy8gSGFuZGxlIGFycmF5c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlZnQpICYmIEFycmF5LmlzQXJyYXkocmlnaHQpKSB7XG4gICAgICBpZiAob3B0aW9ucy5hcnJheXMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgICAvLyBIYW5kbGUgbWFwc1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgTWFwICYmIHJpZ2h0IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBpZiAob3B0aW9ucy5tYXBzID09PSBcIm1lcmdlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoW1xuICAgICAgICAgIC4uLmxlZnQsXG4gICAgICAgICAgLi4ucmlnaHRcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBzZXRzXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBTZXQgJiYgcmlnaHQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGlmIChvcHRpb25zLnNldHMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbmV3IFNldChbXG4gICAgICAgICAgLi4ubGVmdCxcbiAgICAgICAgICAuLi5yaWdodFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJpZ2h0O1xufVxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYSB2YWx1ZSBpcyBtZXJnZWFibGUgb3Igbm90XG4gKiBCdWlsdGlucyB0aGF0IGxvb2sgbGlrZSBvYmplY3RzLCBudWxsIGFuZCB1c2VyIGRlZmluZWQgY2xhc3Nlc1xuICogYXJlIG5vdCBjb25zaWRlcmVkIG1lcmdlYWJsZSAoaXQgbWVhbnMgdGhhdCByZWZlcmVuY2Ugd2lsbCBiZSBjb3BpZWQpXG4gKi8gZnVuY3Rpb24gaXNNZXJnZWFibGUodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBnZXRLZXlzKHJlY29yZCkge1xuICBjb25zdCByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHJlY29yZCk7XG4gIGZpbHRlckluUGxhY2UocmVzdWx0LCAoa2V5KT0+T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHJlY29yZCwga2V5KSk7XG4gIHJlc3VsdC5wdXNoKC4uLk9iamVjdC5rZXlzKHJlY29yZCkpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVlcF9tZXJnZS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxOC0yMDI1IHRoZSBEZW5vIGF1dGhvcnMuIE1JVCBsaWNlbnNlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYnJvd3NlciBjb21wYXRpYmxlLlxuaW1wb3J0IHsgZGVlcE1lcmdlIH0gZnJvbSBcIkBqc3Ivc3RkX19jb2xsZWN0aW9ucy9kZWVwLW1lcmdlXCI7XG4vKipcbiAqIENvcHkgb2YgYGltcG9ydCB7IGlzTGVhcCB9IGZyb20gXCJAc3RkL2RhdGV0aW1lXCI7YCBiZWNhdXNlIGl0IGNhbm5vdCBiZSBpbXBvdGVkIGFzIGxvbmcgYXMgaXQgaXMgdW5zdGFibGUuXG4gKi8gZnVuY3Rpb24gaXNMZWFwKHllYXJOdW1iZXIpIHtcbiAgcmV0dXJuIHllYXJOdW1iZXIgJSA0ID09PSAwICYmIHllYXJOdW1iZXIgJSAxMDAgIT09IDAgfHwgeWVhck51bWJlciAlIDQwMCA9PT0gMDtcbn1cbmV4cG9ydCBjbGFzcyBTY2FubmVyIHtcbiAgI3doaXRlc3BhY2UgPSAvWyBcXHRdLztcbiAgI3Bvc2l0aW9uID0gMDtcbiAgI3NvdXJjZTtcbiAgY29uc3RydWN0b3Ioc291cmNlKXtcbiAgICB0aGlzLiNzb3VyY2UgPSBzb3VyY2U7XG4gIH1cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbjtcbiAgfVxuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGNoYXJhY3RlclxuICAgKiBAcGFyYW0gaW5kZXggLSByZWxhdGl2ZSBpbmRleCBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICovIGNoYXIoaW5kZXggPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZVt0aGlzLiNwb3NpdGlvbiArIGluZGV4XSA/PyBcIlwiO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc2xpY2VkIHN0cmluZ1xuICAgKiBAcGFyYW0gc3RhcnQgLSBzdGFydCBwb3NpdGlvbiByZWxhdGl2ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICogQHBhcmFtIGVuZCAtIGVuZCBwb3NpdGlvbiByZWxhdGl2ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb25cbiAgICovIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlLnNsaWNlKHRoaXMuI3Bvc2l0aW9uICsgc3RhcnQsIHRoaXMuI3Bvc2l0aW9uICsgZW5kKTtcbiAgfVxuICAvKipcbiAgICogTW92ZSBwb3NpdGlvbiB0byBuZXh0XG4gICAqLyBuZXh0KGNvdW50ID0gMSkge1xuICAgIHRoaXMuI3Bvc2l0aW9uICs9IGNvdW50O1xuICB9XG4gIHNraXBXaGl0ZXNwYWNlcygpIHtcbiAgICB3aGlsZSh0aGlzLiN3aGl0ZXNwYWNlLnRlc3QodGhpcy5jaGFyKCkpICYmICF0aGlzLmVvZigpKXtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICAvLyBJbnZhbGlkIGlmIGN1cnJlbnQgY2hhciBpcyBvdGhlciBraW5kcyBvZiB3aGl0ZXNwYWNlXG4gICAgaWYgKCF0aGlzLmlzQ3VycmVudENoYXJFT0woKSAmJiAvXFxzLy50ZXN0KHRoaXMuY2hhcigpKSkge1xuICAgICAgY29uc3QgZXNjYXBlZCA9IFwiXFxcXHVcIiArIHRoaXMuY2hhcigpLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNwb3NpdGlvbjtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQ2Fubm90IHBhcnNlIHRoZSBUT01MOiBJdCBjb250YWlucyBpbnZhbGlkIHdoaXRlc3BhY2UgYXQgcG9zaXRpb24gJyR7cG9zaXRpb259JzogXFxgJHtlc2NhcGVkfVxcYGApO1xuICAgIH1cbiAgfVxuICBuZXh0VW50aWxDaGFyKG9wdGlvbnMgPSB7XG4gICAgc2tpcENvbW1lbnRzOiB0cnVlXG4gIH0pIHtcbiAgICB3aGlsZSghdGhpcy5lb2YoKSl7XG4gICAgICBjb25zdCBjaGFyID0gdGhpcy5jaGFyKCk7XG4gICAgICBpZiAodGhpcy4jd2hpdGVzcGFjZS50ZXN0KGNoYXIpIHx8IHRoaXMuaXNDdXJyZW50Q2hhckVPTCgpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNraXBDb21tZW50cyAmJiB0aGlzLmNoYXIoKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgLy8gZW50ZXJpbmcgY29tbWVudFxuICAgICAgICB3aGlsZSghdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkgJiYgIXRoaXMuZW9mKCkpe1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHJlYWNoZWQgRU9GIG9yIG5vdFxuICAgKi8gZW9mKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA+PSB0aGlzLiNzb3VyY2UubGVuZ3RoO1xuICB9XG4gIGlzQ3VycmVudENoYXJFT0woKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcigpID09PSBcIlxcblwiIHx8IHRoaXMuc3RhcnRzV2l0aChcIlxcclxcblwiKTtcbiAgfVxuICBzdGFydHNXaXRoKHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2Uuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcsIHRoaXMuI3Bvc2l0aW9uKTtcbiAgfVxuICBtYXRjaChyZWdFeHApIHtcbiAgICBpZiAoIXJlZ0V4cC5zdGlja3kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVnRXhwICR7cmVnRXhwfSBkb2VzIG5vdCBoYXZlIGEgc3RpY2t5ICd5JyBmbGFnYCk7XG4gICAgfVxuICAgIHJlZ0V4cC5sYXN0SW5kZXggPSB0aGlzLiNwb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlLm1hdGNoKHJlZ0V4cCk7XG4gIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBVdGlsaXRpZXNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzdWNjZXNzKGJvZHkpIHtcbiAgcmV0dXJuIHtcbiAgICBvazogdHJ1ZSxcbiAgICBib2R5XG4gIH07XG59XG5mdW5jdGlvbiBmYWlsdXJlKCkge1xuICByZXR1cm4ge1xuICAgIG9rOiBmYWxzZVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoZSBrZXlzIGFuZCB2YWx1ZXMuXG4gKlxuICogZS5nLiBgdW5mbGF0KFtcImFcIiwgXCJiXCIsIFwiY1wiXSwgMSlgIHJldHVybnMgYHsgYTogeyBiOiB7IGM6IDEgfSB9IH1gXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHVuZmxhdChrZXlzLCB2YWx1ZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbFxufSkge1xuICByZXR1cm4ga2V5cy5yZWR1Y2VSaWdodCgoYWNjLCBrZXkpPT4oe1xuICAgICAgW2tleV06IGFjY1xuICAgIH0pLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldFZhbHVlKHRhcmdldCwga2V5cykge1xuICBjb25zdCBrZXkgPSBrZXlzWzBdO1xuICBpZiAoIWtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXJzZSB0aGUgVE9NTDoga2V5IGxlbmd0aCBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gIH1cbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuZnVuY3Rpb24gZGVlcEFzc2lnblRhYmxlKHRhcmdldCwgdGFibGUpIHtcbiAgY29uc3QgeyBrZXlzLCB0eXBlLCB2YWx1ZSB9ID0gdGFibGU7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldFRhcmdldFZhbHVlKHRhcmdldCwga2V5cyk7XG4gIGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgdW5mbGF0KGtleXMsIHZhbHVlKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgIGNvbnN0IGxhc3QgPSBjdXJyZW50VmFsdWUuYXQoLTEpO1xuICAgIGRlZXBBc3NpZ24obGFzdCwge1xuICAgICAgdHlwZSxcbiAgICAgIGtleXM6IGtleXMuc2xpY2UoMSksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBkZWVwQXNzaWduKGN1cnJlbnRWYWx1ZSwge1xuICAgICAgdHlwZSxcbiAgICAgIGtleXM6IGtleXMuc2xpY2UoMSksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBhc3NpZ25cIik7XG59XG5mdW5jdGlvbiBkZWVwQXNzaWduVGFibGVBcnJheSh0YXJnZXQsIHRhYmxlKSB7XG4gIGNvbnN0IHsgdHlwZSwga2V5cywgdmFsdWUgfSA9IHRhYmxlO1xuICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRUYXJnZXRWYWx1ZSh0YXJnZXQsIGtleXMpO1xuICBpZiAoY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHVuZmxhdChrZXlzLCBbXG4gICAgICB2YWx1ZVxuICAgIF0pKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgaWYgKHRhYmxlLmtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3QgPSBjdXJyZW50VmFsdWUuYXQoLTEpO1xuICAgICAgZGVlcEFzc2lnbihsYXN0LCB7XG4gICAgICAgIHR5cGU6IHRhYmxlLnR5cGUsXG4gICAgICAgIGtleXM6IHRhYmxlLmtleXMuc2xpY2UoMSksXG4gICAgICAgIHZhbHVlOiB0YWJsZS52YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBkZWVwQXNzaWduKGN1cnJlbnRWYWx1ZSwge1xuICAgICAgdHlwZSxcbiAgICAgIGtleXM6IGtleXMuc2xpY2UoMSksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBhc3NpZ25cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQsIGJvZHkpIHtcbiAgc3dpdGNoKGJvZHkudHlwZSl7XG4gICAgY2FzZSBcIkJsb2NrXCI6XG4gICAgICByZXR1cm4gZGVlcE1lcmdlKHRhcmdldCwgYm9keS52YWx1ZSk7XG4gICAgY2FzZSBcIlRhYmxlXCI6XG4gICAgICByZXR1cm4gZGVlcEFzc2lnblRhYmxlKHRhcmdldCwgYm9keSk7XG4gICAgY2FzZSBcIlRhYmxlQXJyYXlcIjpcbiAgICAgIHJldHVybiBkZWVwQXNzaWduVGFibGVBcnJheSh0YXJnZXQsIGJvZHkpO1xuICB9XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlciBjb21iaW5hdG9ycyBhbmQgZ2VuZXJhdG9yc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gb3IocGFyc2Vycykge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgZm9yIChjb25zdCBwYXJzZSBvZiBwYXJzZXJzKXtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlKHNjYW5uZXIpO1xuICAgICAgaWYgKHJlc3VsdC5vaykgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGZhaWx1cmUoKTtcbiAgfTtcbn1cbi8qKiBKb2luIHRoZSBwYXJzZSByZXN1bHRzIG9mIHRoZSBnaXZlbiBwYXJzZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBJZiB0aGUgcGFyc2VyIGZhaWxzIGF0IHRoZSBmaXJzdCBhdHRlbXB0LCBpdCB3aWxsIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAqLyBmdW5jdGlvbiBqb2luKHBhcnNlciwgc2VwYXJhdG9yKSB7XG4gIGNvbnN0IFNlcGFyYXRvciA9IGNoYXJhY3RlcihzZXBhcmF0b3IpO1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgZmlyc3QgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFmaXJzdC5vaykgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgICBvdXQucHVzaChmaXJzdC5ib2R5KTtcbiAgICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgICBpZiAoIVNlcGFyYXRvcihzY2FubmVyKS5vaykgYnJlYWs7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke3NlcGFyYXRvcn1cImApO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICB9O1xufVxuLyoqIEpvaW4gdGhlIHBhcnNlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHBhcnNlciBpbnRvIGFuIGFycmF5LlxuICpcbiAqIFRoaXMgcmVxdWlyZXMgdGhlIHBhcnNlciB0byBzdWNjZWVkIGF0IGxlYXN0IG9uY2UuXG4gKi8gZnVuY3Rpb24gam9pbjEocGFyc2VyLCBzZXBhcmF0b3IpIHtcbiAgY29uc3QgU2VwYXJhdG9yID0gY2hhcmFjdGVyKHNlcGFyYXRvcik7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBmaXJzdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWZpcnN0Lm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIGNvbnN0IG91dCA9IFtcbiAgICAgIGZpcnN0LmJvZHlcbiAgICBdO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGlmICghU2VwYXJhdG9yKHNjYW5uZXIpLm9rKSBicmVhaztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChyZXN1bHQuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG91dCk7XG4gIH07XG59XG5mdW5jdGlvbiBrdihrZXlQYXJzZXIsIHNlcGFyYXRvciwgdmFsdWVQYXJzZXIpIHtcbiAgY29uc3QgU2VwYXJhdG9yID0gY2hhcmFjdGVyKHNlcGFyYXRvcik7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBwb3NpdGlvbiA9IHNjYW5uZXIucG9zaXRpb247XG4gICAgY29uc3Qga2V5ID0ga2V5UGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICgha2V5Lm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIGNvbnN0IHNlcCA9IFNlcGFyYXRvcihzY2FubmVyKTtcbiAgICBpZiAoIXNlcC5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBrZXkvdmFsdWUgcGFpciBkb2Vzbid0IGhhdmUgXCIke3NlcGFyYXRvcn1cImApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlUGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghdmFsdWUub2spIHtcbiAgICAgIGNvbnN0IGxpbmVFbmRJbmRleCA9IHNjYW5uZXIuc291cmNlLmluZGV4T2YoXCJcXG5cIiwgc2Nhbm5lci5wb3NpdGlvbik7XG4gICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IGxpbmVFbmRJbmRleCA+IDAgPyBsaW5lRW5kSW5kZXggOiBzY2FubmVyLnNvdXJjZS5sZW5ndGg7XG4gICAgICBjb25zdCBsaW5lID0gc2Nhbm5lci5zb3VyY2Uuc2xpY2UocG9zaXRpb24sIGVuZFBvc2l0aW9uKTtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgQ2Fubm90IHBhcnNlIHZhbHVlIG9uIGxpbmUgJyR7bGluZX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKHVuZmxhdChrZXkuYm9keSwgdmFsdWUuYm9keSkpO1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2UocGFyc2VyKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFyZXN1bHQub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgbGV0IGJvZHkgPSB7XG4gICAgICBfX3Byb3RvX186IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlc3VsdC5ib2R5KXtcbiAgICAgIGlmICh0eXBlb2YgcmVjb3JkID09PSBcIm9iamVjdFwiICYmIHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gZGVlcE1lcmdlKGJvZHksIHJlY29yZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVwZWF0KHBhcnNlcikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICAgIGJvZHkucHVzaChyZXN1bHQuYm9keSk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgICB9XG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHJldHVybiBzdWNjZXNzKGJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gc3Vycm91bmQobGVmdCwgcGFyc2VyLCByaWdodCkge1xuICBjb25zdCBMZWZ0ID0gY2hhcmFjdGVyKGxlZnQpO1xuICBjb25zdCBSaWdodCA9IGNoYXJhY3RlcihyaWdodCk7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBpZiAoIUxlZnQoc2Nhbm5lcikub2spIHtcbiAgICAgIHJldHVybiBmYWlsdXJlKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIGlmICghUmlnaHQoc2Nhbm5lcikub2spIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTm90IGNsb3NlZCBieSBcIiR7cmlnaHR9XCIgYWZ0ZXIgc3RhcnRlZCB3aXRoIFwiJHtsZWZ0fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKHJlc3VsdC5ib2R5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlcihzdHIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoc3RyKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBzY2FubmVyLm5leHQoc3RyLmxlbmd0aCk7XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICByZXR1cm4gc3VjY2Vzcyh1bmRlZmluZWQpO1xuICB9O1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlciBjb21wb25lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgQkFSRV9LRVlfUkVHRVhQID0gL1tBLVphLXowLTlfLV0rL3k7XG5leHBvcnQgZnVuY3Rpb24gYmFyZUtleShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IGtleSA9IHNjYW5uZXIubWF0Y2goQkFSRV9LRVlfUkVHRVhQKT8uWzBdO1xuICBpZiAoIWtleSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KGtleS5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhrZXkpO1xufVxuZnVuY3Rpb24gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcikge1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXFxcXFwiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgLy8gU2VlIGh0dHBzOi8vdG9tbC5pby9lbi92MS4wLjAtcmMuMyNzdHJpbmdcbiAgc3dpdGNoKHNjYW5uZXIuY2hhcigpKXtcbiAgICBjYXNlIFwiYlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcYlwiKTtcbiAgICBjYXNlIFwidFwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcdFwiKTtcbiAgICBjYXNlIFwiblwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcblwiKTtcbiAgICBjYXNlIFwiZlwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcZlwiKTtcbiAgICBjYXNlIFwiclwiOlxuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICByZXR1cm4gc3VjY2VzcyhcIlxcclwiKTtcbiAgICBjYXNlIFwidVwiOlxuICAgIGNhc2UgXCJVXCI6XG4gICAgICB7XG4gICAgICAgIC8vIFVuaWNvZGUgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGNvZGVQb2ludExlbiA9IHNjYW5uZXIuY2hhcigpID09PSBcInVcIiA/IDQgOiA2O1xuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBwYXJzZUludChcIjB4XCIgKyBzY2FubmVyLnNsaWNlKDEsIDEgKyBjb2RlUG9pbnRMZW4pLCAxNik7XG4gICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICAgIHNjYW5uZXIubmV4dChjb2RlUG9pbnRMZW4gKyAxKTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moc3RyKTtcbiAgICAgIH1cbiAgICBjYXNlICdcIic6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKCdcIicpO1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxcXFwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogXFxcXCR7c2Nhbm5lci5jaGFyKCl9YCk7XG4gIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBiYXNpY1N0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gJ1wiJyAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgU2luZ2xlLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICBzY2FubmVyLm5leHQoKTsgLy8gc2tpcCBsYXN0ICdcIlwiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIikgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KCk7XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZShzY2FubmVyLmNoYXIoKSAhPT0gXCInXCIgJiYgIXNjYW5uZXIuZW9mKCkpe1xuICAgIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiU2luZ2xlLWxpbmUgc3RyaW5nIGNhbm5vdCBjb250YWluIEVPTFwiKTtcbiAgICB9XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgXCInXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKCdcIlwiXCInKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgLy8gbGluZSBlbmRpbmcgYmFja3NsYXNoXG4gICAgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcXFxcXHJcXG5cIikpIHtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKHtcbiAgICAgICAgc2tpcENvbW1lbnRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlZENoYXIgPSBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKTtcbiAgICBpZiAoZXNjYXBlZENoYXIub2spIHtcbiAgICAgIGFjYy5wdXNoKGVzY2FwZWRDaGFyLmJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgXCJgLCBwdXNoIHRoZSBmaXN0IGBcImAgdG8gc3RyaW5nXG4gIGlmIChzY2FubmVyLmNoYXIoMykgPT09ICdcIicpIHtcbiAgICBhY2MucHVzaCgnXCInKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCAnXCJcIlwiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpbGluZUxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KDMpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfSBlbHNlIGlmIChzY2FubmVyLnN0YXJ0c1dpdGgoXCJcXHJcXG5cIikpIHtcbiAgICAvLyBUaGUgZmlyc3QgbmV3bGluZSAoQ1JMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgyKTtcbiAgfVxuICBjb25zdCBhY2MgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuc3RhcnRzV2l0aChcIicnJ1wiKSAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBNdWx0aS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgLy8gaWYgZW5kcyB3aXRoIDQgYCdgLCBwdXNoIHRoZSBmaXN0IGAnYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gXCInXCIpIHtcbiAgICBhY2MucHVzaChcIidcIik7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KDMpOyAvLyBza2lwIGxhc3QgXCInJydcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5jb25zdCBCT09MRUFOX1JFR0VYUCA9IC8oPzp0cnVlfGZhbHNlKVxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goQk9PTEVBTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IHN0cmluZyA9PT0gXCJ0cnVlXCI7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IElORklOSVRZX01BUCA9IG5ldyBNYXAoW1xuICBbXG4gICAgXCJpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCIraW5mXCIsXG4gICAgSW5maW5pdHlcbiAgXSxcbiAgW1xuICAgIFwiLWluZlwiLFxuICAgIC1JbmZpbml0eVxuICBdXG5dKTtcbmNvbnN0IElORklOSVRZX1JFR0VYUCA9IC9bKy1dP2luZlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGluZmluaXR5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElORklOSVRZX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gSU5GSU5JVFlfTUFQLmdldChzdHJpbmcpO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5jb25zdCBOQU5fUkVHRVhQID0gL1srLV0/bmFuXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbmFuKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE5BTl9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IE5hTjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0IGRvdHRlZEtleSA9IGpvaW4xKG9yKFtcbiAgYmFyZUtleSxcbiAgYmFzaWNTdHJpbmcsXG4gIGxpdGVyYWxTdHJpbmdcbl0pLCBcIi5cIik7XG5jb25zdCBCSU5BUllfUkVHRVhQID0gLzBiWzAxXSsoPzpfWzAxXSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCSU5BUllfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDIpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IE9DVEFMX1JFR0VYUCA9IC8wb1swLTddKyg/Ol9bMC03XSspKlxcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIG9jdGFsKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKE9DVEFMX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2guc2xpY2UoMikucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBIRVhfUkVHRVhQID0gLzB4WzAtOWEtZl0rKD86X1swLTlhLWZdKykqXFxiL3lpO1xuZXhwb3J0IGZ1bmN0aW9uIGhleChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChIRVhfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWlsdXJlKCkgOiBzdWNjZXNzKG51bWJlcik7XG59XG5jb25zdCBJTlRFR0VSX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlcihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChJTlRFR0VSX1JFR0VYUCk/LlswXTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0KG1hdGNoLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gbWF0Y2gucmVwbGFjZUFsbChcIl9cIiwgXCJcIik7XG4gIGNvbnN0IGludCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiBzdWNjZXNzKGludCk7XG59XG5jb25zdCBGTE9BVF9SRUdFWFAgPSAvWystXT8oPzowfFsxLTldWzAtOV0qKD86X1swLTldKykqKSg/OlxcLlswLTldKyg/Ol9bMC05XSspKik/KD86ZVsrLV0/WzAtOV0rKD86X1swLTldKykqKT9cXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goRkxPQVRfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgZmxvYXQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgaWYgKGlzTmFOKGZsb2F0KSkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoZmxvYXQpO1xufVxuY29uc3QgREFURV9USU1FX1JFR0VYUCA9IC8oPzx5ZWFyPlxcZHs0fSktKD88bW9udGg+XFxkezJ9KS0oPzxkYXk+XFxkezJ9KSg/OlsgMC05VFouOistXSspP1xcYi95O1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKERBVEVfVElNRV9SRUdFWFApO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBjb25zdCBzdHJpbmcgPSBtYXRjaFswXTtcbiAgc2Nhbm5lci5uZXh0KHN0cmluZy5sZW5ndGgpO1xuICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gIC8vIHNwZWNpYWwgY2FzZSBpZiBtb250aCBpcyBGZWJydWFyeVxuICBpZiAoZ3JvdXBzLm1vbnRoID09IFwiMDJcIikge1xuICAgIGNvbnN0IGRheXMgPSBwYXJzZUludChncm91cHMuZGF5KTtcbiAgICBpZiAoZGF5cyA+IDI5KSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChncm91cHMueWVhcik7XG4gICAgaWYgKGRheXMgPiAyOCAmJiAhaXNMZWFwKHllYXIpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcudHJpbSgpKTtcbiAgLy8gaW52YWxpZCBkYXRlXG4gIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZGF0ZSBzdHJpbmcgXCIke21hdGNofVwiYCk7XG4gIH1cbiAgcmV0dXJuIHN1Y2Nlc3MoZGF0ZSk7XG59XG5jb25zdCBMT0NBTF9USU1FX1JFR0VYUCA9IC8oXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KSg/OlxcLlswLTldKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gbG9jYWxUaW1lKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKExPQ0FMX1RJTUVfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MobWF0Y2gpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VmFsdWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiW1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSBicmVhaztcbiAgICBhcnJheS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIC8vIG1heSBoYXZlIGEgbmV4dCBpdGVtLCBidXQgdHJhaWxpbmcgY29tbWEgaXMgYWxsb3dlZCBhdCBhcnJheVxuICAgIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiXVwiKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBcnJheSBpcyBub3QgY2xvc2VkXCIpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYXJyYXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVRhYmxlKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoMSkgPT09IFwifVwiKSB7XG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICAgIHJldHVybiBzdWNjZXNzKHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBhaXJzID0gc3Vycm91bmQoXCJ7XCIsIGpvaW4ocGFpciwgXCIsXCIpLCBcIn1cIikoc2Nhbm5lcik7XG4gIGlmICghcGFpcnMub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIGxldCB0YWJsZSA9IHtcbiAgICBfX3Byb3RvX186IG51bGxcbiAgfTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzLmJvZHkpe1xuICAgIHRhYmxlID0gZGVlcE1lcmdlKHRhYmxlLCBwYWlyKTtcbiAgfVxuICByZXR1cm4gc3VjY2Vzcyh0YWJsZSk7XG59XG5leHBvcnQgY29uc3QgdmFsdWUgPSBvcihbXG4gIG11bHRpbGluZUJhc2ljU3RyaW5nLFxuICBtdWx0aWxpbmVMaXRlcmFsU3RyaW5nLFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZyxcbiAgYm9vbGVhbixcbiAgaW5maW5pdHksXG4gIG5hbixcbiAgZGF0ZVRpbWUsXG4gIGxvY2FsVGltZSxcbiAgYmluYXJ5LFxuICBvY3RhbCxcbiAgaGV4LFxuICBmbG9hdCxcbiAgaW50ZWdlcixcbiAgYXJyYXlWYWx1ZSxcbiAgaW5saW5lVGFibGVcbl0pO1xuZXhwb3J0IGNvbnN0IHBhaXIgPSBrdihkb3R0ZWRLZXksIFwiPVwiLCB2YWx1ZSk7XG5leHBvcnQgZnVuY3Rpb24gYmxvY2soc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgcmVzdWx0ID0gbWVyZ2UocmVwZWF0KHBhaXIpKShzY2FubmVyKTtcbiAgaWYgKHJlc3VsdC5vaykgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiQmxvY2tcIixcbiAgICB2YWx1ZTogcmVzdWx0LmJvZHlcbiAgfSk7XG4gIHJldHVybiBmYWlsdXJlKCk7XG59XG5leHBvcnQgY29uc3QgdGFibGVIZWFkZXIgPSBzdXJyb3VuZChcIltcIiwgZG90dGVkS2V5LCBcIl1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgaGVhZGVyID0gdGFibGVIZWFkZXIoc2Nhbm5lcik7XG4gIGlmICghaGVhZGVyLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgYiA9IGJsb2NrKHNjYW5uZXIpO1xuICByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJUYWJsZVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge1xuICAgICAgX19wcm90b19fOiBudWxsXG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUFycmF5SGVhZGVyID0gc3Vycm91bmQoXCJbW1wiLCBkb3R0ZWRLZXksIFwiXV1cIik7XG5leHBvcnQgZnVuY3Rpb24gdGFibGVBcnJheShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUFycmF5SGVhZGVyKHNjYW5uZXIpO1xuICBpZiAoIWhlYWRlci5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGNvbnN0IGIgPSBibG9jayhzY2FubmVyKTtcbiAgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIHR5cGU6IFwiVGFibGVBcnJheVwiLFxuICAgIGtleXM6IGhlYWRlci5ib2R5LFxuICAgIHZhbHVlOiBiLm9rID8gYi5ib2R5LnZhbHVlIDoge1xuICAgICAgX19wcm90b19fOiBudWxsXG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b21sKHNjYW5uZXIpIHtcbiAgY29uc3QgYmxvY2tzID0gcmVwZWF0KG9yKFtcbiAgICBibG9jayxcbiAgICB0YWJsZUFycmF5LFxuICAgIHRhYmxlXG4gIF0pKShzY2FubmVyKTtcbiAgaWYgKCFibG9ja3Mub2spIHJldHVybiBzdWNjZXNzKHtcbiAgICBfX3Byb3RvX186IG51bGxcbiAgfSk7XG4gIGNvbnN0IGJvZHkgPSBibG9ja3MuYm9keS5yZWR1Y2UoZGVlcEFzc2lnbiwge1xuICAgIF9fcHJvdG9fXzogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSB7XG4gIGNvbnN0IHN0cmluZyA9IHNjYW5uZXIuc291cmNlLnNsaWNlKDAsIHNjYW5uZXIucG9zaXRpb24pO1xuICBjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgY29uc3Qgcm93ID0gbGluZXMubGVuZ3RoO1xuICBjb25zdCBjb2x1bW4gPSBsaW5lcy5hdCgtMSk/Lmxlbmd0aCA/PyAwO1xuICByZXR1cm4gYFBhcnNlIGVycm9yIG9uIGxpbmUgJHtyb3d9LCBjb2x1bW4gJHtjb2x1bW59OiAke21lc3NhZ2V9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZXJGYWN0b3J5KHBhcnNlcikge1xuICByZXR1cm4gKHRvbWxTdHJpbmcpPT57XG4gICAgY29uc3Qgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRvbWxTdHJpbmcpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rICYmIHNjYW5uZXIuZW9mKCkpIHJldHVybiByZXN1bHQuYm9keTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJHtzY2FubmVyLmNoYXIoKX1cImA7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBlcnJvciB0eXBlIGNhdWdodFwiO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpKTtcbiAgICB9XG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcGFyc2VyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBwYXJzZXJGYWN0b3J5LCB0b21sIH0gZnJvbSBcIi4vX3BhcnNlci5qc1wiO1xuLyoqXG4gKiBQYXJzZXMgYSB7QGxpbmsgaHR0cHM6Ly90b21sLmlvIHwgVE9NTH0gc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlIFVzYWdlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQHN0ZC90b21sL3BhcnNlXCI7XG4gKiBpbXBvcnQgeyBhc3NlcnRFcXVhbHMgfSBmcm9tIFwiQHN0ZC9hc3NlcnRcIjtcbiAqXG4gKiBjb25zdCB0b21sU3RyaW5nID0gYHRpdGxlID0gXCJUT01MIEV4YW1wbGVcIlxuICogW293bmVyXVxuICogbmFtZSA9IFwiQWxpY2VcIlxuICogYmlvID0gXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCJgO1xuICpcbiAqIGNvbnN0IG9iaiA9IHBhcnNlKHRvbWxTdHJpbmcpO1xuICogYXNzZXJ0RXF1YWxzKG9iaiwgeyB0aXRsZTogXCJUT01MIEV4YW1wbGVcIiwgb3duZXI6IHsgbmFtZTogXCJBbGljZVwiLCBiaW86IFwiQWxpY2UgaXMgYSBwcm9ncmFtbWVyLlwiIH0gfSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB0b21sU3RyaW5nIFRPTUwgc3RyaW5nIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgSlMgb2JqZWN0LlxuICovIGV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0b21sU3RyaW5nKSB7XG4gIHJldHVybiBwYXJzZXJGYWN0b3J5KHRvbWwpKHRvbWxTdHJpbmcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlUmVxdWlyZSB9IGZyb20gXCJub2RlOm1vZHVsZVwiO1xuaW1wb3J0IHsgaXNBYnNvbHV0ZSwgam9pbiwgcmVzb2x2ZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tIFwibm9kZTp1cmxcIjtcbi8qKlxuKiBSZXNvbHZlIGFuIGFic29sdXRlIHBhdGggZnJvbSB7QGxpbmsgcm9vdH0sIGJ1dCBvbmx5XG4qIGlmIHtAbGluayBpbnB1dH0gaXNuJ3QgYWxyZWFkeSBhYnNvbHV0ZS5cbipcbiogQHBhcmFtIGlucHV0IFRoZSBwYXRoIHRvIHJlc29sdmUuXG4qIEBwYXJhbSByb290IFRoZSBiYXNlIHBhdGg7IGRlZmF1bHQgPSBwcm9jZXNzLmN3ZCgpXG4qIEByZXR1cm5zIFRoZSByZXNvbHZlZCBhYnNvbHV0ZSBwYXRoLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnNvbHV0ZShpbnB1dCwgcm9vdCkge1xuXHRyZXR1cm4gaXNBYnNvbHV0ZShpbnB1dCkgPyBpbnB1dCA6IHJlc29sdmUocm9vdCB8fCBcIi5cIiwgaW5wdXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb20ocm9vdCwgaWRlbnQsIHNpbGVudCkge1xuXHR0cnkge1xuXHRcdC8vIE5PVEU6IGRpcnMgbmVlZCBhIHRyYWlsaW5nIFwiL1wiIE9SIGZpbGVuYW1lLiBXaXRoIFwiL1wiIHJvdXRlLFxuXHRcdC8vIE5vZGUgYWRkcyBcIm5vb3AuanNcIiBhcyBtYWluIGZpbGUsIHNvIGp1c3QgZG8gXCJub29wLmpzXCIgYW55d2F5LlxuXHRcdGxldCByID0gcm9vdCBpbnN0YW5jZW9mIFVSTCB8fCByb290LnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpID8gam9pbihmaWxlVVJMVG9QYXRoKHJvb3QpLCBcIm5vb3AuanNcIikgOiBqb2luKGFic29sdXRlKHJvb3QpLCBcIm5vb3AuanNcIik7XG5cdFx0cmV0dXJuIGNyZWF0ZVJlcXVpcmUocikucmVzb2x2ZShpZGVudCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdGlmICghc2lsZW50KSB0aHJvdyBlcnI7XG5cdH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjd2QoaWRlbnQsIHNpbGVudCkge1xuXHRyZXR1cm4gZnJvbShyZXNvbHZlKCksIGlkZW50LCBzaWxlbnQpO1xufVxuIiwiaW1wb3J0IHsgZGlybmFtZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGFic29sdXRlIH0gZnJvbSBcImVtcGF0aGljL3Jlc29sdmVcIjtcbi8qKlxuKiBHZXQgYWxsIHBhcmVudCBkaXJlY3RvcmllcyBvZiB7QGxpbmsgYmFzZX0uXG4qIFN0b3BzIGFmdGVyIHtAbGluayBPcHRpb25zWydsYXN0J119IGlzIHByb2Nlc3NlZC5cbipcbiogQHJldHVybnMgQW4gYXJyYXkgb2YgYWJzb2x1dGUgcGF0aHMgb2YgYWxsIHBhcmVudCBkaXJlY3Rvcmllcy5cbiovXG5leHBvcnQgZnVuY3Rpb24gdXAoYmFzZSwgb3B0aW9ucykge1xuXHRsZXQgeyBsYXN0LCBjd2QgfSA9IG9wdGlvbnMgfHwge307XG5cdGxldCB0bXAgPSBhYnNvbHV0ZShiYXNlLCBjd2QpO1xuXHRsZXQgcm9vdCA9IGFic29sdXRlKGxhc3QgfHwgXCIvXCIsIGN3ZCk7XG5cdGxldCBwcmV2LCBhcnIgPSBbXTtcblx0d2hpbGUgKHByZXYgIT09IHJvb3QpIHtcblx0XHRhcnIucHVzaCh0bXApO1xuXHRcdHRtcCA9IGRpcm5hbWUocHJldiA9IHRtcCk7XG5cdFx0aWYgKHRtcCA9PT0gcHJldikgYnJlYWs7XG5cdH1cblx0cmV0dXJuIGFycjtcbn1cbiIsImltcG9ydCB7IGpvaW4gfSBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgeyBleGlzdHNTeW5jLCBzdGF0U3luYyB9IGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgKiBhcyB3YWxrIGZyb20gXCJlbXBhdGhpYy93YWxrXCI7XG4vKipcbiogRmluZCBhbiBpdGVtIGJ5IG5hbWUsIHdhbGtpbmcgcGFyZW50IGRpcmVjdG9yaWVzIHVudGlsIGZvdW5kLlxuKlxuKiBAcGFyYW0gbmFtZSBUaGUgaXRlbSBuYW1lIHRvIGZpbmQuXG4qIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBpdGVtLCBpZiBmb3VuZC5cbiovXG5leHBvcnQgZnVuY3Rpb24gdXAobmFtZSwgb3B0aW9ucykge1xuXHRsZXQgZGlyLCB0bXA7XG5cdGxldCBzdGFydCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jd2QgfHwgXCJcIjtcblx0Zm9yIChkaXIgb2Ygd2Fsay51cChzdGFydCwgb3B0aW9ucykpIHtcblx0XHR0bXAgPSBqb2luKGRpciwgbmFtZSk7XG5cdFx0aWYgKGV4aXN0c1N5bmModG1wKSkgcmV0dXJuIHRtcDtcblx0fVxufVxuLyoqXG4qIEdldCB0aGUgZmlyc3QgcGF0aCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBuYW1lcyBwcm92aWRlZC5cbipcbiogPiBbTk9URV1cbiogPiBUaGUgb3JkZXIgb2Yge0BsaW5rIG5hbWVzfSBpcyByZXNwZWN0ZWQuXG4qXG4qIEBwYXJhbSBuYW1lcyBUaGUgaXRlbSBuYW1lcyB0byBmaW5kLlxuKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgZmlyc3QgaXRlbSBmb3VuZCwgaWYgYW55LlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnkobmFtZXMsIG9wdGlvbnMpIHtcblx0bGV0IGRpciwgc3RhcnQgPSBvcHRpb25zICYmIG9wdGlvbnMuY3dkIHx8IFwiXCI7XG5cdGxldCBqID0gMCwgbGVuID0gbmFtZXMubGVuZ3RoLCB0bXA7XG5cdGZvciAoZGlyIG9mIHdhbGsudXAoc3RhcnQsIG9wdGlvbnMpKSB7XG5cdFx0Zm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG5cdFx0XHR0bXAgPSBqb2luKGRpciwgbmFtZXNbal0pO1xuXHRcdFx0aWYgKGV4aXN0c1N5bmModG1wKSkgcmV0dXJuIHRtcDtcblx0XHR9XG5cdH1cbn1cbi8qKlxuKiBGaW5kIGEgZmlsZSBieSBuYW1lLCB3YWxraW5nIHBhcmVudCBkaXJlY3RvcmllcyB1bnRpbCBmb3VuZC5cbipcbiogPiBbTk9URV1cbiogPiBUaGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyBhIHZhbHVlIGZvciBmaWxlIG1hdGNoZXMuXG4qID4gQSBkaXJlY3RvcnkgbWF0Y2ggd2l0aCB0aGUgc2FtZSBuYW1lIHdpbGwgYmUgaWdub3JlZC5cbipcbiogQHBhcmFtIG5hbWUgVGhlIGZpbGUgbmFtZSB0byBmaW5kLlxuKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgZmlsZSwgaWYgZm91bmQuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGUobmFtZSwgb3B0aW9ucykge1xuXHRsZXQgZGlyLCB0bXA7XG5cdGxldCBzdGFydCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jd2QgfHwgXCJcIjtcblx0Zm9yIChkaXIgb2Ygd2Fsay51cChzdGFydCwgb3B0aW9ucykpIHtcblx0XHR0cnkge1xuXHRcdFx0dG1wID0gam9pbihkaXIsIG5hbWUpO1xuXHRcdFx0aWYgKHN0YXRTeW5jKHRtcCkuaXNGaWxlKCkpIHJldHVybiB0bXA7XG5cdFx0fSBjYXRjaCB7fVxuXHR9XG59XG4vKipcbiogRmluZCBhIGRpcmVjdG9yeSBieSBuYW1lLCB3YWxraW5nIHBhcmVudCBkaXJlY3RvcmllcyB1bnRpbCBmb3VuZC5cbipcbiogPiBbTk9URV1cbiogPiBUaGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyBhIHZhbHVlIGZvciBkaXJlY3RvcnkgbWF0Y2hlcy5cbiogPiBBIGZpbGUgbWF0Y2ggd2l0aCB0aGUgc2FtZSBuYW1lIHdpbGwgYmUgaWdub3JlZC5cbipcbiogQHBhcmFtIG5hbWUgVGhlIGRpcmVjdG9yeSBuYW1lIHRvIGZpbmQuXG4qIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlLCBpZiBmb3VuZC5cbiovXG5leHBvcnQgZnVuY3Rpb24gZGlyKG5hbWUsIG9wdGlvbnMpIHtcblx0bGV0IGRpciwgdG1wO1xuXHRsZXQgc3RhcnQgPSBvcHRpb25zICYmIG9wdGlvbnMuY3dkIHx8IFwiXCI7XG5cdGZvciAoZGlyIG9mIHdhbGsudXAoc3RhcnQsIG9wdGlvbnMpKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHRtcCA9IGpvaW4oZGlyLCBuYW1lKTtcblx0XHRcdGlmIChzdGF0U3luYyh0bXApLmlzRGlyZWN0b3J5KCkpIHJldHVybiB0bXA7XG5cdFx0fSBjYXRjaCB7fVxuXHR9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sncmVuYW1lJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdSZW5hbWUgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgJCRuYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1uYW1lLC1uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9qZWN0JyxcbiAgfSlcblxuICBiaW5hcnlOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1iaW5hcnktbmFtZSwtYicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgYmluYXJ5IG5hbWUgKi5ub2RlIGZpbGVzJyxcbiAgfSlcblxuICBwYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBwYWNrYWdlIG5hbWUgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsICdDYXJnby50b21sJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgQ2FyZ28udG9tbGAnLFxuICB9KVxuXG4gIHJlcG9zaXRvcnk/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXJlcG9zaXRvcnknLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IHJlcG9zaXRvcnkgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1kZXNjcmlwdGlvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgYmluYXJ5TmFtZTogdGhpcy5iaW5hcnlOYW1lLFxuICAgICAgcGFja2FnZU5hbWU6IHRoaXMucGFja2FnZU5hbWUsXG4gICAgICBtYW5pZmVzdFBhdGg6IHRoaXMubWFuaWZlc3RQYXRoLFxuICAgICAgcmVwb3NpdG9yeTogdGhpcy5yZXBvc2l0b3J5LFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBOQVBJLVJTIHByb2plY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZW5hbWVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgbmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBiaW5hcnkgbmFtZSAqLm5vZGUgZmlsZXNcbiAgICovXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcGFja2FnZSBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBwYWNrYWdlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgQ2FyZ28udG9tbGBcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NhcmdvLnRvbWwnXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuZXcgcmVwb3NpdG9yeSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgcmVwb3NpdG9yeT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnMob3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgbWFuaWZlc3RQYXRoOiAnQ2FyZ28udG9tbCcsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyByZW5hbWUgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJ1xuaW1wb3J0IHsgcmVzb2x2ZSwgam9pbiB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VUb21sLCBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5VG9tbCB9IGZyb20gJ0BzdGQvdG9tbCdcbmltcG9ydCB7IGxvYWQgYXMgeWFtbFBhcnNlLCBkdW1wIGFzIHlhbWxTdHJpbmdpZnkgfSBmcm9tICdqcy15YW1sJ1xuaW1wb3J0IHsgaXNOaWwsIG1lcmdlLCBvbWl0QnksIHBpY2sgfSBmcm9tICdlcy10b29sa2l0J1xuaW1wb3J0ICogYXMgZmluZCBmcm9tICdlbXBhdGhpYy9maW5kJ1xuXG5pbXBvcnQgeyBhcHBseURlZmF1bHRSZW5hbWVPcHRpb25zLCB0eXBlIFJlbmFtZU9wdGlvbnMgfSBmcm9tICcuLi9kZWYvcmVuYW1lLmpzJ1xuaW1wb3J0IHsgcmVhZENvbmZpZywgcmVhZEZpbGVBc3luYywgd3JpdGVGaWxlQXN5bmMgfSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZVByb2plY3QodXNlck9wdGlvbnM6IFJlbmFtZU9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnModXNlck9wdGlvbnMpXG4gIGNvbnN0IG5hcGlDb25maWcgPSBhd2FpdCByZWFkQ29uZmlnKG9wdGlvbnMpXG4gIGNvbnN0IG9sZE5hbWUgPSBuYXBpQ29uZmlnLmJpbmFyeU5hbWVcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcbiAgY29uc3QgY2FyZ29Ub21sUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMubWFuaWZlc3RQYXRoKVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMocGFja2FnZUpzb25QYXRoLCAndXRmOCcpXG4gIGNvbnN0IHBhY2thZ2VKc29uRGF0YSA9IEpTT04ucGFyc2UocGFja2FnZUpzb25Db250ZW50KVxuXG4gIG1lcmdlKFxuICAgIG1lcmdlKFxuICAgICAgcGFja2FnZUpzb25EYXRhLFxuICAgICAgb21pdEJ5KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG1pc3NpbmcgZmllbGRzOiBhdXRob3IgYW5kIGxpY2Vuc2VcbiAgICAgICAgcGljayhvcHRpb25zLCBbJ25hbWUnLCAnZGVzY3JpcHRpb24nLCAnYXV0aG9yJywgJ2xpY2Vuc2UnXSksXG4gICAgICAgIGlzTmlsLFxuICAgICAgKSxcbiAgICApLFxuICAgIHtcbiAgICAgIG5hcGk6IG9taXRCeShcbiAgICAgICAge1xuICAgICAgICAgIGJpbmFyeU5hbWU6IG9wdGlvbnMuYmluYXJ5TmFtZSxcbiAgICAgICAgICBwYWNrYWdlTmFtZTogb3B0aW9ucy5wYWNrYWdlTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNOaWwsXG4gICAgICApLFxuICAgIH0sXG4gIClcblxuICBpZiAob3B0aW9ucy5jb25maWdQYXRoKSB7XG4gICAgY29uc3QgY29uZmlnUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aClcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgY29uc3QgY29uZmlnRGF0YSA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudClcbiAgICBjb25maWdEYXRhLmJpbmFyeU5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICBjb25maWdEYXRhLnBhY2thZ2VOYW1lID0gb3B0aW9ucy5wYWNrYWdlTmFtZVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGNvbmZpZ0RhdGEsIG51bGwsIDIpKVxuICB9XG5cbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uRGF0YSwgbnVsbCwgMiksXG4gIClcblxuICBjb25zdCB0b21sQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoY2FyZ29Ub21sUGF0aCwgJ3V0ZjgnKVxuICBjb25zdCBjYXJnb1RvbWwgPSBwYXJzZVRvbWwodG9tbENvbnRlbnQpIGFzIGFueVxuXG4gIC8vIFVwZGF0ZSB0aGUgcGFja2FnZSBuYW1lXG4gIGlmIChjYXJnb1RvbWwucGFja2FnZSAmJiBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICAvLyBTYW5pdGl6ZSB0aGUgYmluYXJ5IG5hbWUgZm9yIFJ1c3QgcGFja2FnZSBuYW1pbmcgY29udmVudGlvbnNcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAucmVwbGFjZSgnQCcsICcnKVxuICAgICAgLnJlcGxhY2UoJy8nLCAnXycpXG4gICAgICAucmVwbGFjZSgvLS9nLCAnXycpXG4gICAgICAudG9Mb3dlckNhc2UoKVxuICAgIGNhcmdvVG9tbC5wYWNrYWdlLm5hbWUgPSBzYW5pdGl6ZWROYW1lXG4gIH1cblxuICAvLyBTdHJpbmdpZnkgdGhlIHVwZGF0ZWQgVE9NTFxuICBjb25zdCB1cGRhdGVkVG9tbENvbnRlbnQgPSBzdHJpbmdpZnlUb21sKGNhcmdvVG9tbClcblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCB1cGRhdGVkVG9tbENvbnRlbnQpXG4gIGlmIChvbGROYW1lICE9PSBvcHRpb25zLmJpbmFyeU5hbWUpIHtcbiAgICBjb25zdCBnaXRodWJBY3Rpb25zUGF0aCA9IGZpbmQuZGlyKCcuZ2l0aHViJywge1xuICAgICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgICB9KVxuICAgIGlmIChnaXRodWJBY3Rpb25zUGF0aCkge1xuICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCA9IGpvaW4oXG4gICAgICAgIGdpdGh1YkFjdGlvbnNQYXRoLFxuICAgICAgICAnd29ya2Zsb3dzJyxcbiAgICAgICAgJ0NJLnltbCcsXG4gICAgICApXG4gICAgICBpZiAoZXhpc3RzU3luYyhnaXRodWJBY3Rpb25zQ0lZbWxQYXRoKSkge1xuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAndXRmOCcsXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgZ2l0aHViQWN0aW9uc0RhdGEgPSB5YW1sUGFyc2UoZ2l0aHViQWN0aW9uc0NvbnRlbnQpIGFzIGFueVxuICAgICAgICBpZiAoZ2l0aHViQWN0aW9uc0RhdGEuZW52Py5BUFBfTkFNRSkge1xuICAgICAgICAgIGdpdGh1YkFjdGlvbnNEYXRhLmVudi5BUFBfTkFNRSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZ2l0aHViQWN0aW9uc0NJWW1sUGF0aCxcbiAgICAgICAgICAgIHlhbWxTdHJpbmdpZnkoZ2l0aHViQWN0aW9uc0RhdGEsIHtcbiAgICAgICAgICAgICAgbGluZVdpZHRoOiAtMSxcbiAgICAgICAgICAgICAgbm9SZWZzOiB0cnVlLFxuICAgICAgICAgICAgICBzb3J0S2V5czogZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIGAke29sZE5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCcm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGpvaW4ob3B0aW9ucy5jd2QsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IG9sZFdhc2lCaW5kaW5nUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsIGAke29sZE5hbWV9Lndhc2kuY2pzYClcbiAgICBpZiAoZXhpc3RzU3luYyhvbGRXYXNpQmluZGluZ1BhdGgpKSB7XG4gICAgICBhd2FpdCByZW5hbWUoXG4gICAgICAgIG9sZFdhc2lCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCBnaXRBdHRyaWJ1dGVzUGF0aCA9IGpvaW4ob3B0aW9ucy5jd2QsICcuZ2l0YXR0cmlidXRlcycpXG4gICAgaWYgKGV4aXN0c1N5bmMoZ2l0QXR0cmlidXRlc1BhdGgpKSB7XG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgIGdpdEF0dHJpYnV0ZXNQYXRoLFxuICAgICAgICAndXRmOCcsXG4gICAgICApXG4gICAgICBjb25zdCBnaXRBdHRyaWJ1dGVzRGF0YSA9IGdpdEF0dHJpYnV0ZXNDb250ZW50XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBsaW5lXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgICAgICAgICAgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnJlcGxhY2UoYCR7b2xkTmFtZX0ud2FzaS5janNgLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhnaXRBdHRyaWJ1dGVzUGF0aCwgZ2l0QXR0cmlidXRlc0RhdGEpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBleGVjLCBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnXG5pbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ25vZGU6ZnMnXG5cbmltcG9ydCB7IGxvYWQgYXMgeWFtbExvYWQsIGR1bXAgYXMgeWFtbER1bXAgfSBmcm9tICdqcy15YW1sJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHROZXdPcHRpb25zLFxuICB0eXBlIE5ld09wdGlvbnMgYXMgUmF3TmV3T3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL25ldy5qcydcbmltcG9ydCB7XG4gIEFWQUlMQUJMRV9UQVJHRVRTLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIERFRkFVTFRfVEFSR0VUUyxcbiAgbWtkaXJBc3luYyxcbiAgcmVhZGRpckFzeW5jLFxuICBzdGF0QXN5bmMsXG4gIHR5cGUgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuaW1wb3J0IHsgbmFwaUVuZ2luZVJlcXVpcmVtZW50IH0gZnJvbSAnLi4vdXRpbHMvdmVyc2lvbi5qcydcbmltcG9ydCB7IHJlbmFtZVByb2plY3QgfSBmcm9tICcuL3JlbmFtZS5qcydcblxuLy8gVGVtcGxhdGUgaW1wb3J0cyByZW1vdmVkIGFzIHdlJ3JlIG5vdyB1c2luZyBleHRlcm5hbCB0ZW1wbGF0ZXNcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ25ldycpXG5cbnR5cGUgTmV3T3B0aW9ucyA9IFJlcXVpcmVkPFJhd05ld09wdGlvbnM+XG5cbmNvbnN0IFRFTVBMQVRFX1JFUE9TID0ge1xuICB5YXJuOiAnaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvcGFja2FnZS10ZW1wbGF0ZScsXG4gIHBucG06ICdodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9wYWNrYWdlLXRlbXBsYXRlLXBucG0nLFxufSBhcyBjb25zdFxuXG5hc3luYyBmdW5jdGlvbiBjaGVja0dpdENvbW1hbmQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGNwID0gZXhlYygnZ2l0IC0tdmVyc2lvbicpXG4gICAgICBjcC5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgICB9KVxuICAgICAgY3Aub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlQ2FjaGVEaXIoXG4gIHBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGNhY2hlRGlyID0gcGF0aC5qb2luKGhvbWVkaXIoKSwgJy5uYXBpLXJzJywgJ3RlbXBsYXRlJywgcGFja2FnZU1hbmFnZXIpXG4gIGF3YWl0IG1rZGlyQXN5bmMoY2FjaGVEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gIHJldHVybiBjYWNoZURpclxufVxuXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZFRlbXBsYXRlKFxuICBwYWNrYWdlTWFuYWdlcjogU3VwcG9ydGVkUGFja2FnZU1hbmFnZXIsXG4gIGNhY2hlRGlyOiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVwb1VybCA9IFRFTVBMQVRFX1JFUE9TW3BhY2thZ2VNYW5hZ2VyXVxuICBjb25zdCB0ZW1wbGF0ZVBhdGggPSBwYXRoLmpvaW4oY2FjaGVEaXIsICdyZXBvJylcblxuICBpZiAoZXhpc3RzU3luYyh0ZW1wbGF0ZVBhdGgpKSB7XG4gICAgZGVidWcoYFRlbXBsYXRlIGNhY2hlIGZvdW5kIGF0ICR7dGVtcGxhdGVQYXRofSwgdXBkYXRpbmcuLi5gKVxuICAgIHRyeSB7XG4gICAgICAvLyBGZXRjaCBsYXRlc3QgY2hhbmdlcyBhbmQgcmVzZXQgdG8gcmVtb3RlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNwID0gZXhlYygnZ2l0IGZldGNoIG9yaWdpbicsIHsgY3dkOiB0ZW1wbGF0ZVBhdGggfSlcbiAgICAgICAgY3Aub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICBjcC5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGZldGNoIGxhdGVzdCBjaGFuZ2VzLCBnaXQgcHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBleGVjU3luYygnZ2l0IHJlc2V0IC0taGFyZCBvcmlnaW4vbWFpbicsIHtcbiAgICAgICAgY3dkOiB0ZW1wbGF0ZVBhdGgsXG4gICAgICAgIHN0ZGlvOiAnaWdub3JlJyxcbiAgICAgIH0pXG4gICAgICBkZWJ1ZygnVGVtcGxhdGUgdXBkYXRlZCBzdWNjZXNzZnVsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkZWJ1ZyhgRmFpbGVkIHRvIHVwZGF0ZSB0ZW1wbGF0ZTogJHtlcnJvcn1gKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfTogJHtlcnJvcn1gKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZyhgQ2xvbmluZyB0ZW1wbGF0ZSBmcm9tICR7cmVwb1VybH0uLi5gKVxuICAgIHRyeSB7XG4gICAgICBleGVjU3luYyhgZ2l0IGNsb25lICR7cmVwb1VybH0gcmVwb2AsIHsgY3dkOiBjYWNoZURpciwgc3RkaW86ICdpbmhlcml0JyB9KVxuICAgICAgZGVidWcoJ1RlbXBsYXRlIGNsb25lZCBzdWNjZXNzZnVsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjbG9uZSB0ZW1wbGF0ZSBmcm9tICR7cmVwb1VybH06ICR7ZXJyb3J9YClcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY29weURpcmVjdG9yeShcbiAgc3JjOiBzdHJpbmcsXG4gIGRlc3Q6IHN0cmluZyxcbiAgaW5jbHVkZVdhc2lCaW5kaW5nczogYm9vbGVhbixcbik6IFByb21pc2U8dm9pZD4ge1xuICBhd2FpdCBta2RpckFzeW5jKGRlc3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHNyYywgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG5cbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3Qgc3JjUGF0aCA9IHBhdGguam9pbihzcmMsIGVudHJ5Lm5hbWUpXG4gICAgY29uc3QgZGVzdFBhdGggPSBwYXRoLmpvaW4oZGVzdCwgZW50cnkubmFtZSlcblxuICAgIC8vIFNraXAgLmdpdCBkaXJlY3RvcnlcbiAgICBpZiAoZW50cnkubmFtZSA9PT0gJy5naXQnKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBhd2FpdCBjb3B5RGlyZWN0b3J5KHNyY1BhdGgsIGRlc3RQYXRoLCBpbmNsdWRlV2FzaUJpbmRpbmdzKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpbmNsdWRlV2FzaUJpbmRpbmdzICYmXG4gICAgICAgIChlbnRyeS5uYW1lLmVuZHNXaXRoKCcud2FzaS1icm93c2VyLmpzJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCcud2FzaS5janMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ3dhc2ktd29ya2VyLmJyb3dzZXIubWpzICcpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnd2FzaS13b3JrZXIubWpzJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCdicm93c2VyLmpzJykpXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGF3YWl0IGZzLmNvcHlGaWxlKHNyY1BhdGgsIGRlc3RQYXRoKVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXJUYXJnZXRzSW5QYWNrYWdlSnNvbihcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgZW5hYmxlZFRhcmdldHM6IHN0cmluZ1tdLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0Zi04JylcbiAgY29uc3QgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKGNvbnRlbnQpXG5cbiAgLy8gRmlsdGVyIG5hcGkudGFyZ2V0c1xuICBpZiAocGFja2FnZUpzb24ubmFwaT8udGFyZ2V0cykge1xuICAgIHBhY2thZ2VKc29uLm5hcGkudGFyZ2V0cyA9IHBhY2thZ2VKc29uLm5hcGkudGFyZ2V0cy5maWx0ZXIoXG4gICAgICAodGFyZ2V0OiBzdHJpbmcpID0+IGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCksXG4gICAgKVxuICB9XG5cbiAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShwYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJylcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmlsdGVyVGFyZ2V0c0luR2l0aHViQWN0aW9ucyhcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgZW5hYmxlZFRhcmdldHM6IHN0cmluZ1tdLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0Zi04JylcbiAgY29uc3QgeWFtbCA9IHlhbWxMb2FkKGNvbnRlbnQpIGFzIGFueVxuXG4gIGNvbnN0IG1hY09TQW5kV2luZG93c1RhcmdldHMgPSBuZXcgU2V0KFtcbiAgICAneDg2XzY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICAgJ3g4Nl82NC1wYy13aW5kb3dzLWdudScsXG4gICAgJ2FhcmNoNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgICAneDg2XzY0LWFwcGxlLWRhcndpbicsXG4gIF0pXG5cbiAgY29uc3QgbGludXhUYXJnZXRzID0gbmV3IFNldChbXG4gICAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ3g4Nl82NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAgICdhYXJjaDY0LXVua25vd24tbGludXgtZ251JyxcbiAgICAnYWFyY2g2NC11bmtub3duLWxpbnV4LW11c2wnLFxuICAgICdhcm12Ny11bmtub3duLWxpbnV4LWdudWVhYmloZicsXG4gICAgJ2FybXY3LXVua25vd24tbGludXgtbXVzbGVhYmloZicsXG4gICAgJ2xvb25nYXJjaDY0LXVua25vd24tbGludXgtZ251JyxcbiAgICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JyxcbiAgICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdzMzkweC11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ2FhcmNoNjQtbGludXgtYW5kcm9pZCcsXG4gICAgJ2FybXY3LWxpbnV4LWFuZHJvaWRlYWJpJyxcbiAgXSlcblxuICAvLyBDaGVjayBpZiBhbnkgTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZFxuICBjb25zdCBoYXNMaW51eFRhcmdldHMgPSBlbmFibGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+XG4gICAgbGludXhUYXJnZXRzLmhhcyh0YXJnZXQpLFxuICApXG5cbiAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIGJ1aWxkIGpvYlxuICBpZiAoeWFtbD8uam9icz8uYnVpbGQ/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzKSB7XG4gICAgeWFtbC5qb2JzLmJ1aWxkLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncyA9XG4gICAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcigoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgIGlmIChzZXR0aW5nLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgfVxuXG4gIGNvbnN0IGpvYnNUb1JlbW92ZTogc3RyaW5nW10gPSBbXVxuXG4gIGlmIChlbmFibGVkVGFyZ2V0cy5ldmVyeSgodGFyZ2V0KSA9PiAhbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cy5oYXModGFyZ2V0KSkpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyBqb2JcbiAgICBpZiAoXG4gICAgICB5YW1sPy5qb2JzPy5bJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10/LnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzXG4gICAgKSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgICAgeWFtbC5qb2JzWyd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5ncy5maWx0ZXIoXG4gICAgICAgICAgKHNldHRpbmc6IGFueSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyhzZXR0aW5nLnRhcmdldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIExpbnV4IHRhcmdldHMgYXJlIGVuYWJsZWQsIHJlbW92ZSBMaW51eC1zcGVjaWZpYyBqb2JzXG4gIGlmICghaGFzTGludXhUYXJnZXRzKSB7XG4gICAgLy8gUmVtb3ZlIHRlc3QtbGludXgtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXSkge1xuICAgICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3QtbGludXgtYmluZGluZycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbHRlciB0aGUgbWF0cml4IGNvbmZpZ3VyYXRpb25zIGluIHRoZSB0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZyBqb2JcbiAgICBpZiAoeWFtbD8uam9icz8uWyd0ZXN0LWxpbnV4LWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8udGFyZ2V0KSB7XG4gICAgICB5YW1sLmpvYnNbJ3Rlc3QtbGludXgtYmluZGluZyddLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQgPSB5YW1sLmpvYnNbXG4gICAgICAgICd0ZXN0LWxpbnV4LWJpbmRpbmcnXG4gICAgICBdLnN0cmF0ZWd5Lm1hdHJpeC50YXJnZXQuZmlsdGVyKCh0YXJnZXQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LXdhc2knKVxuICB9XG5cbiAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcygneDg2XzY0LXVua25vd24tZnJlZWJzZCcpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ2J1aWxkLWZyZWVic2QnKVxuICB9XG5cbiAgLy8gRmlsdGVyIG90aGVyIHRlc3Qgam9icyBiYXNlZCBvbiB0YXJnZXRcbiAgZm9yIChjb25zdCBbam9iTmFtZSwgam9iQ29uZmlnXSBvZiBPYmplY3QuZW50cmllcyh5YW1sLmpvYnMgfHwge30pKSB7XG4gICAgaWYgKFxuICAgICAgam9iTmFtZS5zdGFydHNXaXRoKCd0ZXN0LScpICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnICYmXG4gICAgICBqb2JOYW1lICE9PSAndGVzdC1saW51eC14NjQtZ251LWJpbmRpbmcnXG4gICAgKSB7XG4gICAgICAvLyBFeHRyYWN0IHRhcmdldCBmcm9tIGpvYiBuYW1lIG9yIGNvbmZpZ1xuICAgICAgY29uc3Qgam9iID0gam9iQ29uZmlnIGFzIGFueVxuICAgICAgaWYgKGpvYi5zdHJhdGVneT8ubWF0cml4Py5zZXR0aW5ncz8uWzBdPy50YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gam9iLnN0cmF0ZWd5Lm1hdHJpeC5zZXR0aW5nc1swXS50YXJnZXRcbiAgICAgICAgaWYgKCFlbmFibGVkVGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgam9ic1RvUmVtb3ZlLnB1c2goam9iTmFtZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBqb2JzIGZvciBkaXNhYmxlZCB0YXJnZXRzXG4gIGZvciAoY29uc3Qgam9iTmFtZSBvZiBqb2JzVG9SZW1vdmUpIHtcbiAgICBkZWxldGUgeWFtbC5qb2JzW2pvYk5hbWVdXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh5YW1sLmpvYnM/LnB1Ymxpc2g/Lm5lZWRzKSkge1xuICAgIHlhbWwuam9icy5wdWJsaXNoLm5lZWRzID0geWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMuZmlsdGVyKFxuICAgICAgKG5lZWQ6IHN0cmluZykgPT4gIWpvYnNUb1JlbW92ZS5pbmNsdWRlcyhuZWVkKSxcbiAgICApXG4gIH1cblxuICAvLyBXcml0ZSBiYWNrIHRoZSBmaWx0ZXJlZCBZQU1MXG4gIGNvbnN0IHVwZGF0ZWRZYW1sID0geWFtbER1bXAoeWFtbCwge1xuICAgIGxpbmVXaWR0aDogLTEsXG4gICAgbm9SZWZzOiB0cnVlLFxuICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgfSlcbiAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCB1cGRhdGVkWWFtbClcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnUHJvY2Vzc2luZyBvcHRpb25zLi4uJylcbiAgaWYgKCFvcHRpb25zLnBhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIHRoZSBwYXRoIGFzIHRoZSBhcmd1bWVudCcpXG4gIH1cbiAgb3B0aW9ucy5wYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIG9wdGlvbnMucGF0aClcbiAgZGVidWcoYFJlc29sdmVkIHRhcmdldCBwYXRoIHRvOiAke29wdGlvbnMucGF0aH1gKVxuXG4gIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgb3B0aW9ucy5uYW1lID0gcGF0aC5wYXJzZShvcHRpb25zLnBhdGgpLmJhc2VcbiAgICBkZWJ1ZyhgTm8gcHJvamVjdCBuYW1lIHByb3ZpZGVkLCBmaXggaXQgdG8gZGlyIG5hbWU6ICR7b3B0aW9ucy5uYW1lfWApXG4gIH1cblxuICBpZiAoIW9wdGlvbnMudGFyZ2V0cz8ubGVuZ3RoKSB7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gQVZBSUxBQkxFX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgYWxsIHRhcmdldHMnKVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5lbmFibGVEZWZhdWx0VGFyZ2V0cykge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gREVGQVVMVF9UQVJHRVRTLmNvbmNhdCgpXG4gICAgICBkZWJ1ZygnRW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHRhcmdldCBtdXN0IGJlIGVuYWJsZWQnKVxuICAgIH1cbiAgfVxuICBpZiAoXG4gICAgb3B0aW9ucy50YXJnZXRzLnNvbWUoKHRhcmdldCkgPT4gdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycpXG4gICkge1xuICAgIGNvbnN0IG91dCA9IGV4ZWNTeW5jKGBydXN0dXAgdGFyZ2V0IGxpc3RgLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIH0pXG4gICAgaWYgKG91dC5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJykpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0cyA9IG9wdGlvbnMudGFyZ2V0cy5tYXAoKHRhcmdldCkgPT5cbiAgICAgICAgdGFyZ2V0ID09PSAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcydcbiAgICAgICAgICA/ICd3YXNtMzItd2FzaXAxLXRocmVhZHMnXG4gICAgICAgICAgOiB0YXJnZXQsXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9ucykgYXMgTmV3T3B0aW9uc1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmV3UHJvamVjdCh1c2VyT3B0aW9uczogUmF3TmV3T3B0aW9ucykge1xuICBkZWJ1ZygnV2lsbCBjcmVhdGUgbmFwaS1ycyBwcm9qZWN0IHdpdGggZ2l2ZW4gb3B0aW9uczonKVxuICBkZWJ1Zyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zID0gcHJvY2Vzc09wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgZGVidWcoJ1RhcmdldHMgdG8gYmUgZW5hYmxlZDonKVxuICBkZWJ1ZyhvcHRpb25zLnRhcmdldHMpXG5cbiAgLy8gQ2hlY2sgaWYgZ2l0IGlzIGF2YWlsYWJsZVxuICBpZiAoIShhd2FpdCBjaGVja0dpdENvbW1hbmQoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnR2l0IGlzIG5vdCBpbnN0YWxsZWQgb3Igbm90IGF2YWlsYWJsZSBpbiBQQVRILiBQbGVhc2UgaW5zdGFsbCBHaXQgdG8gY29udGludWUuJyxcbiAgICApXG4gIH1cblxuICBjb25zdCBwYWNrYWdlTWFuYWdlciA9IG9wdGlvbnMucGFja2FnZU1hbmFnZXIgYXMgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJcblxuICAvLyBFbnN1cmUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGVtcHR5XG4gIGF3YWl0IGVuc3VyZVBhdGgob3B0aW9ucy5wYXRoLCBvcHRpb25zLmRyeVJ1bilcblxuICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERvd25sb2FkIG9yIHVwZGF0ZSB0ZW1wbGF0ZVxuICAgICAgY29uc3QgY2FjaGVEaXIgPSBhd2FpdCBlbnN1cmVDYWNoZURpcihwYWNrYWdlTWFuYWdlcilcbiAgICAgIGF3YWl0IGRvd25sb2FkVGVtcGxhdGUocGFja2FnZU1hbmFnZXIsIGNhY2hlRGlyKVxuXG4gICAgICAvLyBDb3B5IHRlbXBsYXRlIGZpbGVzIHRvIHRhcmdldCBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuICAgICAgYXdhaXQgY29weURpcmVjdG9yeShcbiAgICAgICAgdGVtcGxhdGVQYXRoLFxuICAgICAgICBvcHRpb25zLnBhdGgsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0cy5pbmNsdWRlcygnd2FzbTMyLXdhc2lwMS10aHJlYWRzJyksXG4gICAgICApXG5cbiAgICAgIC8vIFJlbmFtZSBwcm9qZWN0IHVzaW5nIHRoZSByZW5hbWUgQVBJXG4gICAgICBhd2FpdCByZW5hbWVQcm9qZWN0KHtcbiAgICAgICAgY3dkOiBvcHRpb25zLnBhdGgsXG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgYmluYXJ5TmFtZTogZ2V0QmluYXJ5TmFtZShvcHRpb25zLm5hbWUpLFxuICAgICAgfSlcblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gcGFja2FnZS5qc29uXG4gICAgICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAncGFja2FnZS5qc29uJylcbiAgICAgIGlmIChleGlzdHNTeW5jKHBhY2thZ2VKc29uUGF0aCkpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciB0YXJnZXRzIGluIEdpdEh1YiBBY3Rpb25zIENJXG4gICAgICBjb25zdCBjaVBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicsICd3b3JrZmxvd3MnLCAnQ0kueW1sJylcbiAgICAgIGlmIChleGlzdHNTeW5jKGNpUGF0aCkgJiYgb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zKSB7XG4gICAgICAgIGF3YWl0IGZpbHRlclRhcmdldHNJbkdpdGh1YkFjdGlvbnMoY2lQYXRoLCBvcHRpb25zLnRhcmdldHMpXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhb3B0aW9ucy5lbmFibGVHaXRodWJBY3Rpb25zICYmXG4gICAgICAgIGV4aXN0c1N5bmMocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSlcbiAgICAgICkge1xuICAgICAgICAvLyBSZW1vdmUgLmdpdGh1YiBkaXJlY3RvcnkgaWYgR2l0SHViIEFjdGlvbnMgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgYXdhaXQgZnMucm0ocGF0aC5qb2luKG9wdGlvbnMucGF0aCwgJy5naXRodWInKSwge1xuICAgICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHBhY2thZ2UuanNvbiB3aXRoIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbnNcbiAgICAgIGNvbnN0IHBrZ0pzb25Db250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUocGFja2FnZUpzb25QYXRoLCAndXRmLTgnKVxuICAgICAgY29uc3QgcGtnSnNvbiA9IEpTT04ucGFyc2UocGtnSnNvbkNvbnRlbnQpXG5cbiAgICAgIC8vIFVwZGF0ZSBlbmdpbmUgcmVxdWlyZW1lbnRcbiAgICAgIGlmICghcGtnSnNvbi5lbmdpbmVzKSB7XG4gICAgICAgIHBrZ0pzb24uZW5naW5lcyA9IHt9XG4gICAgICB9XG4gICAgICBwa2dKc29uLmVuZ2luZXMubm9kZSA9IG5hcGlFbmdpbmVSZXF1aXJlbWVudChvcHRpb25zLm1pbk5vZGVBcGlWZXJzaW9uKVxuXG4gICAgICAvLyBVcGRhdGUgbGljZW5zZSBpZiBkaWZmZXJlbnQgZnJvbSB0ZW1wbGF0ZVxuICAgICAgaWYgKG9wdGlvbnMubGljZW5zZSAmJiBwa2dKc29uLmxpY2Vuc2UgIT09IG9wdGlvbnMubGljZW5zZSkge1xuICAgICAgICBwa2dKc29uLmxpY2Vuc2UgPSBvcHRpb25zLmxpY2Vuc2VcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRlc3QgZnJhbWV3b3JrIGlmIG5lZWRlZFxuICAgICAgaWYgKG9wdGlvbnMudGVzdEZyYW1ld29yayAhPT0gJ2F2YScpIHtcbiAgICAgICAgLy8gVGhpcyB3b3VsZCByZXF1aXJlIG1vcmUgY29tcGxleCBsb2dpYyB0byB1cGRhdGUgdGVzdCBzY3JpcHRzIGFuZCBkZXBlbmRlbmNpZXNcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYFRlc3QgZnJhbWV3b3JrICR7b3B0aW9ucy50ZXN0RnJhbWV3b3JrfSByZXF1ZXN0ZWQgYnV0IG5vdCB5ZXQgaW1wbGVtZW50ZWRgLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShwa2dKc29uLCBudWxsLCAyKSArICdcXG4nLFxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcHJvamVjdDogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKGBQcm9qZWN0IGNyZWF0ZWQgYXQ6ICR7b3B0aW9ucy5wYXRofWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZVBhdGgocGF0aDogc3RyaW5nLCBkcnlSdW4gPSBmYWxzZSkge1xuICBjb25zdCBzdGF0ID0gYXdhaXQgc3RhdEFzeW5jKHBhdGgsIHt9KS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpXG5cbiAgLy8gZmlsZSBkZXNjcmlwdG9yIGV4aXN0c1xuICBpZiAoc3RhdCkge1xuICAgIGlmIChzdGF0LmlzRmlsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LmAsXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgcmVhZGRpckFzeW5jKHBhdGgpXG4gICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgUGF0aCAke3BhdGh9IGZvciBjcmVhdGluZyBuZXcgbmFwaS1ycyBwcm9qZWN0IGFscmVhZHkgZXhpc3RzIGFuZCBpdCdzIG5vdCBlbXB0eS5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFkcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgZGVidWcoYFRyeSB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWApXG4gICAgICBpZiAoIWRyeVJ1bikge1xuICAgICAgICBhd2FpdCBta2RpckFzeW5jKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRhcmdldCBkaXJlY3Rvcnk6ICR7cGF0aH1gLCB7XG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5TmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gbmFtZS5zcGxpdCgnLycpLnBvcCgpIVxufVxuXG5leHBvcnQgdHlwZSB7IE5ld09wdGlvbnMgfVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcmVQdWJsaXNoQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydwcmUtcHVibGlzaCddLCBbJ3ByZXB1Ymxpc2gnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdVcGRhdGUgcGFja2FnZS5qc29uIGFuZCBjb3B5IGFkZG9ucyBpbnRvIHBlciBwbGF0Zm9ybSBwYWNrYWdlcycsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyLC1wJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgdGFnU3R5bGUgPSBPcHRpb24uU3RyaW5nKCctLXRhZy1zdHlsZSwtLXRhZ3N0eWxlLC10JywgJ2xlcm5hJywge1xuICAgIGRlc2NyaXB0aW9uOiAnZ2l0IHRhZyBzdHlsZSwgYG5wbWAgb3IgYGxlcm5hYCcsXG4gIH0pXG5cbiAgZ2hSZWxlYXNlID0gT3B0aW9uLkJvb2xlYW4oJy0tZ2gtcmVsZWFzZScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgY3JlYXRlIEdpdEh1YiByZWxlYXNlJyxcbiAgfSlcblxuICBnaFJlbGVhc2VOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1naC1yZWxlYXNlLW5hbWUnLCB7XG4gICAgZGVzY3JpcHRpb246ICdHaXRIdWIgcmVsZWFzZSBuYW1lJyxcbiAgfSlcblxuICBnaFJlbGVhc2VJZD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZ2gtcmVsZWFzZS1pZCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0V4aXN0aW5nIEdpdEh1YiByZWxlYXNlIGlkJyxcbiAgfSlcblxuICBza2lwT3B0aW9uYWxQdWJsaXNoID0gT3B0aW9uLkJvb2xlYW4oJy0tc2tpcC1vcHRpb25hbC1wdWJsaXNoJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgc2tpcCBvcHRpb25hbERlcGVuZGVuY2llcyBwYWNrYWdlcyBwdWJsaXNoJyxcbiAgfSlcblxuICBkcnlSdW4gPSBPcHRpb24uQm9vbGVhbignLS1kcnktcnVuJywgZmFsc2UsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgdGFnU3R5bGU6IHRoaXMudGFnU3R5bGUsXG4gICAgICBnaFJlbGVhc2U6IHRoaXMuZ2hSZWxlYXNlLFxuICAgICAgZ2hSZWxlYXNlTmFtZTogdGhpcy5naFJlbGVhc2VOYW1lLFxuICAgICAgZ2hSZWxlYXNlSWQ6IHRoaXMuZ2hSZWxlYXNlSWQsXG4gICAgICBza2lwT3B0aW9uYWxQdWJsaXNoOiB0aGlzLnNraXBPcHRpb25hbFB1Ymxpc2gsXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBwYWNrYWdlLmpzb24gYW5kIGNvcHkgYWRkb25zIGludG8gcGVyIHBsYXRmb3JtIHBhY2thZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlUHVibGlzaE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogZ2l0IHRhZyBzdHlsZSwgYG5wbWAgb3IgYGxlcm5hYFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbGVybmEnXG4gICAqL1xuICB0YWdTdHlsZT86ICducG0nIHwgJ2xlcm5hJ1xuICAvKipcbiAgICogV2hldGhlciBjcmVhdGUgR2l0SHViIHJlbGVhc2VcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2hSZWxlYXNlPzogYm9vbGVhblxuICAvKipcbiAgICogR2l0SHViIHJlbGVhc2UgbmFtZVxuICAgKi9cbiAgZ2hSZWxlYXNlTmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogRXhpc3RpbmcgR2l0SHViIHJlbGVhc2UgaWRcbiAgICovXG4gIGdoUmVsZWFzZUlkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHNraXAgb3B0aW9uYWxEZXBlbmRlbmNpZXMgcGFja2FnZXMgcHVibGlzaFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2tpcE9wdGlvbmFsUHVibGlzaD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERyeSBydW4gd2l0aG91dCB0b3VjaGluZyBmaWxlIHN5c3RlbVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZHJ5UnVuPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnMob3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIHRhZ1N0eWxlOiAnbGVybmEnLFxuICAgIGdoUmVsZWFzZTogdHJ1ZSxcbiAgICBza2lwT3B0aW9uYWxQdWJsaXNoOiBmYWxzZSxcbiAgICBkcnlSdW46IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVmVyc2lvbkNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sndmVyc2lvbiddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlIHZlcnNpb24gaW4gY3JlYXRlZCBucG0gcGFja2FnZXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgbnBtRGlyOiB0aGlzLm5wbURpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgdmVyc2lvbiBpbiBjcmVhdGVkIG5wbSBwYWNrYWdlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0XG4gICAqXG4gICAqIEBkZWZhdWx0ICducG0nXG4gICAqL1xuICBucG1EaXI/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zKG9wdGlvbnM6IFZlcnNpb25PcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQge1xuICBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyxcbiAgdHlwZSBWZXJzaW9uT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL3ZlcnNpb24uanMnXG5pbXBvcnQge1xuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICB1cGRhdGVQYWNrYWdlSnNvbixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCd2ZXJzaW9uJylcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcnNpb24odXNlck9wdGlvbnM6IFZlcnNpb25PcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRWZXJzaW9uT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBmb3IgKGNvbnN0IHRhcmdldCBvZiBjb25maWcudGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMubnBtRGlyLCB0YXJnZXQucGxhdGZvcm1BcmNoQUJJKVxuXG4gICAgZGVidWcoYFVwZGF0ZSB2ZXJzaW9uIHRvICVpIGluIFslaV1gLCBjb25maWcucGFja2FnZUpzb24udmVyc2lvbiwgcGtnRGlyKVxuICAgIGF3YWl0IHVwZGF0ZVBhY2thZ2VKc29uKGpvaW4ocGtnRGlyLCAncGFja2FnZS5qc29uJyksIHtcbiAgICAgIHZlcnNpb246IGNvbmZpZy5wYWNrYWdlSnNvbi52ZXJzaW9uLFxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYywgc3RhdFN5bmMgfSBmcm9tICdub2RlOmZzJ1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgT2N0b2tpdCB9IGZyb20gJ0BvY3Rva2l0L3Jlc3QnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFByZVB1Ymxpc2hPcHRpb25zLFxuICB0eXBlIFByZVB1Ymxpc2hPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvcHJlLXB1Ymxpc2guanMnXG5pbXBvcnQge1xuICByZWFkRmlsZUFzeW5jLFxuICByZWFkTmFwaUNvbmZpZyxcbiAgZGVidWdGYWN0b3J5LFxuICB1cGRhdGVQYWNrYWdlSnNvbixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdwcmUtcHVibGlzaCcpXG5cbmludGVyZmFjZSBQYWNrYWdlSW5mbyB7XG4gIG5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgdGFnOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZVB1Ymxpc2godXNlck9wdGlvbnM6IFByZVB1Ymxpc2hPcHRpb25zKSB7XG4gIGRlYnVnKCdSZWNlaXZlIHByZS1wdWJsaXNoIG9wdGlvbnM6JylcbiAgZGVidWcoJyAgJU8nLCB1c2VyT3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgeyBwYWNrYWdlSnNvbiwgdGFyZ2V0cywgcGFja2FnZU5hbWUsIGJpbmFyeU5hbWUsIG5wbUNsaWVudCB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUdoUmVsZWFzZShwYWNrYWdlTmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICBpZiAoIW9wdGlvbnMuZ2hSZWxlYXNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyByZXBvLCBvd25lciwgcGtnSW5mbywgb2N0b2tpdCB9ID0gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWUsIHZlcnNpb24pXG5cbiAgICBpZiAoIXJlcG8gfHwgIW93bmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvY3Rva2l0LnJlcG9zLmNyZWF0ZVJlbGVhc2Uoe1xuICAgICAgICAgIG93bmVyLFxuICAgICAgICAgIHJlcG8sXG4gICAgICAgICAgdGFnX25hbWU6IHBrZ0luZm8udGFnLFxuICAgICAgICAgIG5hbWU6IG9wdGlvbnMuZ2hSZWxlYXNlTmFtZSxcbiAgICAgICAgICBwcmVyZWxlYXNlOlxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygnYWxwaGEnKSB8fFxuICAgICAgICAgICAgdmVyc2lvbi5pbmNsdWRlcygnYmV0YScpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdyYycpLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgUGFyYW1zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgeyBvd25lciwgcmVwbywgdGFnX25hbWU6IHBrZ0luZm8udGFnIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICApfWAsXG4gICAgICAgIClcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZTogc3RyaW5nLCB2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICBjb25zdCBoZWFkQ29tbWl0ID0gZXhlY1N5bmMoJ2dpdCBsb2cgLTEgLS1wcmV0dHk9JUInLCB7XG4gICAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICB9KS50cmltKClcblxuICAgIGNvbnN0IHsgR0lUSFVCX1JFUE9TSVRPUlkgfSA9IHByb2Nlc3MuZW52XG4gICAgaWYgKCFHSVRIVUJfUkVQT1NJVE9SWSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IG51bGwsXG4gICAgICAgIHJlcG86IG51bGwsXG4gICAgICAgIHBrZ0luZm86IHsgbmFtZTogbnVsbCwgdmVyc2lvbjogbnVsbCwgdGFnOiBudWxsIH0sXG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnKGBHaXRodWIgcmVwb3NpdG9yeTogJHtHSVRIVUJfUkVQT1NJVE9SWX1gKVxuICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSBHSVRIVUJfUkVQT1NJVE9SWS5zcGxpdCgnLycpXG4gICAgY29uc3Qgb2N0b2tpdCA9IG5ldyBPY3Rva2l0KHtcbiAgICAgIGF1dGg6IHByb2Nlc3MuZW52LkdJVEhVQl9UT0tFTixcbiAgICB9KVxuICAgIGxldCBwa2dJbmZvOiBQYWNrYWdlSW5mbyB8IHVuZGVmaW5lZFxuICAgIGlmIChvcHRpb25zLnRhZ1N0eWxlID09PSAnbGVybmEnKSB7XG4gICAgICBjb25zdCBwYWNrYWdlc1RvUHVibGlzaCA9IGhlYWRDb21taXRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnRyaW0oKSlcbiAgICAgICAgLmZpbHRlcigobGluZSwgaW5kZXgpID0+IGxpbmUubGVuZ3RoICYmIGluZGV4KVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnN1YnN0cmluZygyKSlcbiAgICAgICAgLm1hcChwYXJzZVRhZylcblxuICAgICAgcGtnSW5mbyA9IHBhY2thZ2VzVG9QdWJsaXNoLmZpbmQoXG4gICAgICAgIChwa2dJbmZvKSA9PiBwa2dJbmZvLm5hbWUgPT09IHBhY2thZ2VOYW1lLFxuICAgICAgKVxuXG4gICAgICBpZiAoIXBrZ0luZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgTm8gcmVsZWFzZSBjb21taXQgZm91bmQgd2l0aCAke3BhY2thZ2VOYW1lfSwgb3JpZ2luYWwgY29tbWl0IGluZm86ICR7aGVhZENvbW1pdH1gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBrZ0luZm8gPSB7XG4gICAgICAgIHRhZzogYHYke3ZlcnNpb259YCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgbmFtZTogcGFja2FnZU5hbWUsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICBhd2FpdCB2ZXJzaW9uKHVzZXJPcHRpb25zKVxuICAgIGF3YWl0IHVwZGF0ZVBhY2thZ2VKc29uKHBhY2thZ2VKc29uUGF0aCwge1xuICAgICAgb3B0aW9uYWxEZXBlbmRlbmNpZXM6IHRhcmdldHMucmVkdWNlKFxuICAgICAgICAoZGVwcywgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgZGVwc1tgJHtwYWNrYWdlTmFtZX0tJHt0YXJnZXQucGxhdGZvcm1BcmNoQUJJfWBdID0gcGFja2FnZUpzb24udmVyc2lvblxuXG4gICAgICAgICAgcmV0dXJuIGRlcHNcbiAgICAgICAgfSxcbiAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICAgICksXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfSA9IG9wdGlvbnMuZ2hSZWxlYXNlSWRcbiAgICA/IGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbi52ZXJzaW9uKVxuICAgIDogYXdhaXQgY3JlYXRlR2hSZWxlYXNlKHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbi52ZXJzaW9uKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCBwa2dEaXIgPSByZXNvbHZlKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm5wbURpcixcbiAgICAgIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YCxcbiAgICApXG4gICAgY29uc3QgZXh0ID1cbiAgICAgIHRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knIHx8IHRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc20nID8gJ3dhc20nIDogJ25vZGUnXG4gICAgY29uc3QgZmlsZW5hbWUgPSBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9LiR7ZXh0fWBcbiAgICBjb25zdCBkc3RQYXRoID0gam9pbihwa2dEaXIsIGZpbGVuYW1lKVxuXG4gICAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgICAgaWYgKCFleGlzdHNTeW5jKGRzdFBhdGgpKSB7XG4gICAgICAgIGRlYnVnLndhcm4oYCVzIGRvZXNuJ3QgZXhpc3RgLCBkc3RQYXRoKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2tpcE9wdGlvbmFsUHVibGlzaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKGAke25wbUNsaWVudH0gcHVibGlzaGAsIHtcbiAgICAgICAgICAgIGN3ZDogcGtnRGlyLFxuICAgICAgICAgICAgZW52OiBwcm9jZXNzLmVudixcbiAgICAgICAgICAgIHN0ZGlvOiAncGlwZScsXG4gICAgICAgICAgfSlcbiAgICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShvdXRwdXQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgIGUubWVzc2FnZS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgcHVibGlzaCBvdmVyIHRoZSBwcmV2aW91c2x5IHB1Ymxpc2hlZCB2ZXJzaW9ucycsXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZS5tZXNzYWdlKVxuICAgICAgICAgICAgZGVidWcud2FybihgJHtwa2dEaXJ9IGhhcyBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmdgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmdoUmVsZWFzZSAmJiByZXBvICYmIG93bmVyKSB7XG4gICAgICAgIGRlYnVnLmluZm8oYENyZWF0aW5nIEdpdEh1YiByZWxlYXNlICR7cGtnSW5mby50YWd9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZWxlYXNlSWQgPSBvcHRpb25zLmdoUmVsZWFzZUlkXG4gICAgICAgICAgICA/IE51bWJlcihvcHRpb25zLmdoUmVsZWFzZUlkKVxuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgYXdhaXQgb2N0b2tpdCEucmVwb3MuZ2V0UmVsZWFzZUJ5VGFnKHtcbiAgICAgICAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICAgICAgICBvd25lcjogb3duZXIsXG4gICAgICAgICAgICAgICAgICB0YWc6IHBrZ0luZm8udGFnLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICkuZGF0YS5pZFxuICAgICAgICAgIGNvbnN0IGRzdEZpbGVTdGF0cyA9IHN0YXRTeW5jKGRzdFBhdGgpXG4gICAgICAgICAgY29uc3QgYXNzZXRJbmZvID0gYXdhaXQgb2N0b2tpdCEucmVwb3MudXBsb2FkUmVsZWFzZUFzc2V0KHtcbiAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHJlcG8sXG4gICAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIHJlbGVhc2VfaWQ6IHJlbGVhc2VJZCxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogeyBmb3JtYXQ6ICdyYXcnIH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IGRzdEZpbGVTdGF0cy5zaXplLFxuICAgICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBvY3Rva2l0IHR5cGVzIGFyZSB3cm9uZ1xuICAgICAgICAgICAgZGF0YTogYXdhaXQgcmVhZEZpbGVBc3luYyhkc3RQYXRoKSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGRlYnVnLmluZm8oYEdpdEh1YiByZWxlYXNlIGNyZWF0ZWRgKVxuICAgICAgICAgIGRlYnVnLmluZm8oYERvd25sb2FkIFVSTDogJXNgLCBhc3NldEluZm8uZGF0YS5icm93c2VyX2Rvd25sb2FkX3VybClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLmVycm9yKFxuICAgICAgICAgICAgYFBhcmFtOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWc6IHBrZ0luZm8udGFnLCBmaWxlbmFtZTogZHN0UGF0aCB9LFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgKX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFnKHRhZzogc3RyaW5nKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gdGFnLnNwbGl0KCdAJylcbiAgY29uc3QgdmVyc2lvbiA9IHNlZ21lbnRzLnBvcCgpIVxuICBjb25zdCBuYW1lID0gc2VnbWVudHMuam9pbignQCcpXG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHZlcnNpb24sXG4gICAgdGFnLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQgZXh0ZW5kcyBDb21tYW5kIHtcbiAgc3RhdGljIHBhdGhzID0gW1sndW5pdmVyc2FsaXplJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnknLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG91dHB1dERpciA9IE9wdGlvbi5TdHJpbmcoJy0tb3V0cHV0LWRpciwtbycsICcuLycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmQnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb21iaWxlIGJ1aWx0IGJpbmFyaWVzIGludG8gb25lIHVuaXZlcnNhbCBiaW5hcnlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVbml2ZXJzYWxpemVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aFxuICAgKlxuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmN3ZCgpXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICpcbiAgICogQGRlZmF1bHQgJ3BhY2thZ2UuanNvbidcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIGFsbCBidWlsdCBgLm5vZGVgIGZpbGVzIHB1dCwgc2FtZSBhcyBgLS1vdXRwdXQtZGlyYCBvZiBidWlsZCBjb21tYW5kXG4gICAqXG4gICAqIEBkZWZhdWx0ICcuLydcbiAgICovXG4gIG91dHB1dERpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyhvcHRpb25zOiBVbml2ZXJzYWxpemVPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgb3V0cHV0RGlyOiAnLi8nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnMsXG4gIHR5cGUgVW5pdmVyc2FsaXplT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvY29uZmlnLmpzJ1xuaW1wb3J0IHsgZGVidWdGYWN0b3J5IH0gZnJvbSAnLi4vdXRpbHMvbG9nLmpzJ1xuaW1wb3J0IHsgZmlsZUV4aXN0cyB9IGZyb20gJy4uL3V0aWxzL21pc2MuanMnXG5pbXBvcnQgeyBVbmlBcmNoc0J5UGxhdGZvcm0gfSBmcm9tICcuLi91dGlscy90YXJnZXQuanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCd1bml2ZXJzYWxpemUnKVxuXG5jb25zdCB1bml2ZXJzYWxpemVyczogUGFydGlhbDxcbiAgUmVjb3JkPE5vZGVKUy5QbGF0Zm9ybSwgKGlucHV0czogc3RyaW5nW10sIG91dHB1dDogc3RyaW5nKSA9PiB2b2lkPlxuPiA9IHtcbiAgZGFyd2luOiAoaW5wdXRzLCBvdXRwdXQpID0+IHtcbiAgICBzcGF3blN5bmMoJ2xpcG8nLCBbJy1jcmVhdGUnLCAnLW91dHB1dCcsIG91dHB1dCwgLi4uaW5wdXRzXSwge1xuICAgICAgc3RkaW86ICdpbmhlcml0JyxcbiAgICB9KVxuICB9LFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdW5pdmVyc2FsaXplQmluYXJpZXModXNlck9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFVuaXZlcnNhbGl6ZU9wdGlvbnModXNlck9wdGlvbnMpXG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG5cbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBjb25zdCB0YXJnZXQgPSBjb25maWcudGFyZ2V0cy5maW5kKFxuICAgICh0KSA9PiB0LnBsYXRmb3JtID09PSBwcm9jZXNzLnBsYXRmb3JtICYmIHQuYXJjaCA9PT0gJ3VuaXZlcnNhbCcsXG4gIClcblxuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAndW5pdmVyc2FsJyBhcmNoIGZvciBwbGF0Zm9ybSAnJHtwcm9jZXNzLnBsYXRmb3JtfScgbm90IGZvdW5kIGluIGNvbmZpZyFgLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHNyY0ZpbGVzID0gVW5pQXJjaHNCeVBsYXRmb3JtW3Byb2Nlc3MucGxhdGZvcm1dPy5tYXAoKGFyY2gpID0+XG4gICAgcmVzb2x2ZShcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgb3B0aW9ucy5vdXRwdXREaXIsXG4gICAgICBgJHtjb25maWcuYmluYXJ5TmFtZX0uJHtwcm9jZXNzLnBsYXRmb3JtfS0ke2FyY2h9Lm5vZGVgLFxuICAgICksXG4gIClcblxuICBpZiAoIXNyY0ZpbGVzIHx8ICF1bml2ZXJzYWxpemVyc1twcm9jZXNzLnBsYXRmb3JtXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAndW5pdmVyc2FsJyBhcmNoIGZvciBwbGF0Zm9ybSAnJHtwcm9jZXNzLnBsYXRmb3JtfScgbm90IHN1cHBvcnRlZC5gLFxuICAgIClcbiAgfVxuXG4gIGRlYnVnKGBMb29raW5nIHVwIHNvdXJjZSBiaW5hcmllcyB0byBjb21iaW5lOiBgKVxuICBkZWJ1ZygnICAlTycsIHNyY0ZpbGVzKVxuXG4gIGNvbnN0IHNyY0ZpbGVMb29rdXAgPSBhd2FpdCBQcm9taXNlLmFsbChzcmNGaWxlcy5tYXAoKGYpID0+IGZpbGVFeGlzdHMoZikpKVxuXG4gIGNvbnN0IG5vdEZvdW5kRmlsZXMgPSBzcmNGaWxlcy5maWx0ZXIoKF8sIGkpID0+ICFzcmNGaWxlTG9va3VwW2ldKVxuXG4gIGlmIChub3RGb3VuZEZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTb21lIGJpbmFyeSBmaWxlcyB3ZXJlIG5vdCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeShub3RGb3VuZEZpbGVzKX1gLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IHJlc29sdmUoXG4gICAgb3B0aW9ucy5jd2QsXG4gICAgb3B0aW9ucy5vdXRwdXREaXIsXG4gICAgYCR7Y29uZmlnLmJpbmFyeU5hbWV9LiR7cHJvY2Vzcy5wbGF0Zm9ybX0tdW5pdmVyc2FsLm5vZGVgLFxuICApXG5cbiAgdW5pdmVyc2FsaXplcnNbcHJvY2Vzcy5wbGF0Zm9ybV0/LihzcmNGaWxlcywgb3V0cHV0KVxuXG4gIGRlYnVnKGBQcm9kdWNlZCB1bml2ZXJzYWwgYmluYXJ5OiAke291dHB1dH1gKVxufVxuIiwiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgY29sbGVjdEFydGlmYWN0cyB9IGZyb20gJy4uL2FwaS9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9hcnRpZmFjdHMuanMnXG5cbmV4cG9ydCBjbGFzcyBBcnRpZmFjdHNDb21tYW5kIGV4dGVuZHMgQmFzZUFydGlmYWN0c0NvbW1hbmQge1xuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBzcGVjaWZpZWQgZGlyJyxcbiAgICBleGFtcGxlczogW1xuICAgICAgW1xuICAgICAgICAnJDAgYXJ0aWZhY3RzIC0tb3V0cHV0LWRpciAuL2FydGlmYWN0cyAtLWRpc3QgLi9ucG0nLFxuICAgICAgICBgQ29weSBbYmluYXJ5TmFtZV0uW3BsYXRmb3JtXS5ub2RlIHVuZGVyIGN1cnJlbnQgZGlyKC4pIGludG8gcGFja2FnZXMgdW5kZXIgbnBtIGRpci5cbmUuZzogaW5kZXgubGludXgteDY0LWdudS5ub2RlIC0tPiAuL25wbS9saW51eC14NjQtZ251L2luZGV4LmxpbnV4LXg2NC1nbnUubm9kZWAsXG4gICAgICBdLFxuICAgIF0sXG4gIH0pXG5cbiAgc3RhdGljIHBhdGhzID0gW1snYXJ0aWZhY3RzJ11dXG5cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCBjb2xsZWN0QXJ0aWZhY3RzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUJ1aWxkQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydidWlsZCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0Pzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS10YXJnZXQsLXQnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQnVpbGQgZm9yIHRoZSB0YXJnZXQgdHJpcGxlLCBieXBhc3NlZCB0byBgY2FyZ28gYnVpbGQgLS10YXJnZXRgJyxcbiAgfSlcblxuICBjd2Q/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIG1hbmlmZXN0UGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbWFuaWZlc3QtcGF0aCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYENhcmdvLnRvbWxgJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICB0YXJnZXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXRhcmdldC1kaXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgJyxcbiAgfSlcblxuICBvdXRwdXREaXI/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLW91dHB1dC1kaXIsLW8nLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCB0byB3aGVyZSBhbGwgdGhlIGJ1aWx0IGZpbGVzIHdvdWxkIGJlIHB1dC4gRGVmYXVsdCB0byB0aGUgY3JhdGUgZm9sZGVyJyxcbiAgfSlcblxuICBwbGF0Zm9ybT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1wbGF0Zm9ybScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYCcsXG4gIH0pXG5cbiAganNQYWNrYWdlTmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tanMtcGFja2FnZS1uYW1lJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhY2thZ2UgbmFtZSBpbiBnZW5lcmF0ZWQganMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcnLFxuICB9KVxuXG4gIGNvbnN0RW51bT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1jb25zdC1lbnVtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzJyxcbiAgfSlcblxuICBqc0JpbmRpbmc/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWpzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuJyxcbiAgfSlcblxuICBub0pzQmluZGluZz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1uby1qcycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGdlbmVyYXRpb24gSlMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuJyxcbiAgfSlcblxuICBkdHM/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWR0cycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIGFuZCBmaWxlbmFtZSBvZiBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAnLFxuICB9KVxuXG4gIGR0c0hlYWRlcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZHRzLWhlYWRlcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdDdXN0b20gZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC4nLFxuICB9KVxuXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLW5vLWR0cy1oZWFkZXInLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnV2hldGhlciB0byBkaXNhYmxlIHRoZSBkZWZhdWx0IGZpbGUgaGVhZGVyIGZvciBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gT25seSB3b3JrcyB3aGVuIGB0eXBlZGVmYCBmZWF0dXJlIGVuYWJsZWQuJyxcbiAgfSlcblxuICBkdHNDYWNoZSA9IE9wdGlvbi5Cb29sZWFuKCctLWR0cy1jYWNoZScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gZW5hYmxlIHRoZSBkdHMgY2FjaGUsIGRlZmF1bHQgdG8gdHJ1ZScsXG4gIH0pXG5cbiAgZXNtPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWVzbScsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGVtaXQgYW4gRVNNIEpTIGJpbmRpbmcgZmlsZSBpbnN0ZWFkIG9mIENKUyBmb3JtYXQuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4nLFxuICB9KVxuXG4gIHN0cmlwPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXN0cmlwLC1zJywge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBzdHJpcCB0aGUgbGlicmFyeSB0byBhY2hpZXZlIHRoZSBtaW5pbXVtIGZpbGUgc2l6ZScsXG4gIH0pXG5cbiAgcmVsZWFzZT86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1yZWxlYXNlLC1yJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgaW4gcmVsZWFzZSBtb2RlJyxcbiAgfSlcblxuICB2ZXJib3NlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXZlcmJvc2UsLXYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdWZXJib3NlbHkgbG9nIGJ1aWxkIGNvbW1hbmQgdHJhY2UnLFxuICB9KVxuXG4gIGJpbj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tYmluJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgb25seSB0aGUgc3BlY2lmaWVkIGJpbmFyeScsXG4gIH0pXG5cbiAgcGFja2FnZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZSwtcCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIHRoZSBzcGVjaWZpZWQgbGlicmFyeSBvciB0aGUgb25lIGF0IGN3ZCcsXG4gIH0pXG5cbiAgcHJvZmlsZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcHJvZmlsZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0J1aWxkIGFydGlmYWN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvZmlsZScsXG4gIH0pXG5cbiAgY3Jvc3NDb21waWxlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWNyb3NzLWNvbXBpbGUsLXgnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gY3Jvc3MtY29tcGlsZSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgd2l0aCBgY2FyZ28teHdpbmAgb24gd2luZG93cyBhbmQgYGNhcmdvLXppZ2J1aWxkYCBvbiBvdGhlciBwbGF0Zm9ybScsXG4gIH0pXG5cbiAgdXNlQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLWNyb3NzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1tleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gJyxcbiAgfSlcblxuICB1c2VOYXBpQ3Jvc3M/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdXNlLW5hcGktY3Jvc3MnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gdXNlIEBuYXBpLXJzL2Nyb3NzLXRvb2xjaGFpbiB0byBjcm9zcy1jb21waWxlIExpbnV4IGFybS9hcm02NC94NjQgZ251IHRhcmdldHMuJyxcbiAgfSlcblxuICB3YXRjaD86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS13YXRjaCwtdycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICd3YXRjaCB0aGUgY3JhdGUgY2hhbmdlcyBhbmQgYnVpbGQgY29udGludW91c2x5IHdpdGggYGNhcmdvLXdhdGNoYCBjcmF0ZXMnLFxuICB9KVxuXG4gIGZlYXR1cmVzPzogc3RyaW5nW10gPSBPcHRpb24uQXJyYXkoJy0tZmVhdHVyZXMsLUYnLCB7XG4gICAgZGVzY3JpcHRpb246ICdTcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBmZWF0dXJlcyB0byBhY3RpdmF0ZScsXG4gIH0pXG5cbiAgYWxsRmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tYWxsLWZlYXR1cmVzJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQWN0aXZhdGUgYWxsIGF2YWlsYWJsZSBmZWF0dXJlcycsXG4gIH0pXG5cbiAgbm9EZWZhdWx0RmVhdHVyZXM/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0RvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmUnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgbWFuaWZlc3RQYXRoOiB0aGlzLm1hbmlmZXN0UGF0aCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICB0YXJnZXREaXI6IHRoaXMudGFyZ2V0RGlyLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAganNQYWNrYWdlTmFtZTogdGhpcy5qc1BhY2thZ2VOYW1lLFxuICAgICAgY29uc3RFbnVtOiB0aGlzLmNvbnN0RW51bSxcbiAgICAgIGpzQmluZGluZzogdGhpcy5qc0JpbmRpbmcsXG4gICAgICBub0pzQmluZGluZzogdGhpcy5ub0pzQmluZGluZyxcbiAgICAgIGR0czogdGhpcy5kdHMsXG4gICAgICBkdHNIZWFkZXI6IHRoaXMuZHRzSGVhZGVyLFxuICAgICAgbm9EdHNIZWFkZXI6IHRoaXMubm9EdHNIZWFkZXIsXG4gICAgICBkdHNDYWNoZTogdGhpcy5kdHNDYWNoZSxcbiAgICAgIGVzbTogdGhpcy5lc20sXG4gICAgICBzdHJpcDogdGhpcy5zdHJpcCxcbiAgICAgIHJlbGVhc2U6IHRoaXMucmVsZWFzZSxcbiAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSxcbiAgICAgIGJpbjogdGhpcy5iaW4sXG4gICAgICBwYWNrYWdlOiB0aGlzLnBhY2thZ2UsXG4gICAgICBwcm9maWxlOiB0aGlzLnByb2ZpbGUsXG4gICAgICBjcm9zc0NvbXBpbGU6IHRoaXMuY3Jvc3NDb21waWxlLFxuICAgICAgdXNlQ3Jvc3M6IHRoaXMudXNlQ3Jvc3MsXG4gICAgICB1c2VOYXBpQ3Jvc3M6IHRoaXMudXNlTmFwaUNyb3NzLFxuICAgICAgd2F0Y2g6IHRoaXMud2F0Y2gsXG4gICAgICBmZWF0dXJlczogdGhpcy5mZWF0dXJlcyxcbiAgICAgIGFsbEZlYXR1cmVzOiB0aGlzLmFsbEZlYXR1cmVzLFxuICAgICAgbm9EZWZhdWx0RmVhdHVyZXM6IHRoaXMubm9EZWZhdWx0RmVhdHVyZXMsXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIE5BUEktUlMgcHJvamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBCdWlsZCBmb3IgdGhlIHRhcmdldCB0cmlwbGUsIGJ5cGFzc2VkIHRvIGBjYXJnbyBidWlsZCAtLXRhcmdldGBcbiAgICovXG4gIHRhcmdldD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqL1xuICBjd2Q/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYENhcmdvLnRvbWxgXG4gICAqL1xuICBtYW5pZmVzdFBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGVcbiAgICovXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gYHBhY2thZ2UuanNvbmBcbiAgICovXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogRGlyZWN0b3J5IGZvciBhbGwgY3JhdGUgZ2VuZXJhdGVkIGFydGlmYWN0cywgc2VlIGBjYXJnbyBidWlsZCAtLXRhcmdldC1kaXJgXG4gICAqL1xuICB0YXJnZXREaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gd2hlcmUgYWxsIHRoZSBidWlsdCBmaWxlcyB3b3VsZCBiZSBwdXQuIERlZmF1bHQgdG8gdGhlIGNyYXRlIGZvbGRlclxuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBZGQgcGxhdGZvcm0gdHJpcGxlIHRvIHRoZSBnZW5lcmF0ZWQgbm9kZWpzIGJpbmRpbmcgZmlsZSwgZWc6IGBbbmFtZV0ubGludXgteDY0LWdudS5ub2RlYFxuICAgKi9cbiAgcGxhdGZvcm0/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUgaW4gZ2VuZXJhdGVkIGpzIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnXG4gICAqL1xuICBqc1BhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIGdlbmVyYXRlIGNvbnN0IGVudW0gZm9yIHR5cGVzY3JpcHQgYmluZGluZ3NcbiAgICovXG4gIGNvbnN0RW51bT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFBhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmAuXG4gICAqL1xuICBqc0JpbmRpbmc/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgZ2VuZXJhdGlvbiBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy5cbiAgICovXG4gIG5vSnNCaW5kaW5nPzogYm9vbGVhblxuICAvKipcbiAgICogUGF0aCBhbmQgZmlsZW5hbWUgb2YgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIFJlbGF0aXZlIHRvIGAtLW91dHB1dC1kaXJgXG4gICAqL1xuICBkdHM/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEN1c3RvbSBmaWxlIGhlYWRlciBmb3IgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIE9ubHkgd29ya3Mgd2hlbiBgdHlwZWRlZmAgZmVhdHVyZSBlbmFibGVkLlxuICAgKi9cbiAgZHRzSGVhZGVyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC5cbiAgICovXG4gIG5vRHRzSGVhZGVyPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgdGhlIGR0cyBjYWNoZSwgZGVmYXVsdCB0byB0cnVlXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGR0c0NhY2hlPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciB0byBlbWl0IGFuIEVTTSBKUyBiaW5kaW5nIGZpbGUgaW5zdGVhZCBvZiBDSlMgZm9ybWF0LiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWcuXG4gICAqL1xuICBlc20/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN0cmlwIHRoZSBsaWJyYXJ5IHRvIGFjaGlldmUgdGhlIG1pbmltdW0gZmlsZSBzaXplXG4gICAqL1xuICBzdHJpcD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIGluIHJlbGVhc2UgbW9kZVxuICAgKi9cbiAgcmVsZWFzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFZlcmJvc2VseSBsb2cgYnVpbGQgY29tbWFuZCB0cmFjZVxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEJ1aWxkIG9ubHkgdGhlIHNwZWNpZmllZCBiaW5hcnlcbiAgICovXG4gIGJpbj86IHN0cmluZ1xuICAvKipcbiAgICogQnVpbGQgdGhlIHNwZWNpZmllZCBsaWJyYXJ5IG9yIHRoZSBvbmUgYXQgY3dkXG4gICAqL1xuICBwYWNrYWdlPzogc3RyaW5nXG4gIC8qKlxuICAgKiBCdWlsZCBhcnRpZmFjdHMgd2l0aCB0aGUgc3BlY2lmaWVkIHByb2ZpbGVcbiAgICovXG4gIHByb2ZpbGU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIGNyb3NzLWNvbXBpbGUgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IHdpdGggYGNhcmdvLXh3aW5gIG9uIHdpbmRvd3MgYW5kIGBjYXJnby16aWdidWlsZGAgb24gb3RoZXIgcGxhdGZvcm1cbiAgICovXG4gIGNyb3NzQ29tcGlsZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBbY3Jvc3NdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcm9zcy1ycy9jcm9zcykgaW5zdGVhZCBvZiBgY2FyZ29gXG4gICAqL1xuICB1c2VDcm9zcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFtleHBlcmltZW50YWxdIHVzZSBAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4gdG8gY3Jvc3MtY29tcGlsZSBMaW51eCBhcm0vYXJtNjQveDY0IGdudSB0YXJnZXRzLlxuICAgKi9cbiAgdXNlTmFwaUNyb3NzPzogYm9vbGVhblxuICAvKipcbiAgICogd2F0Y2ggdGhlIGNyYXRlIGNoYW5nZXMgYW5kIGJ1aWxkIGNvbnRpbnVvdXNseSB3aXRoIGBjYXJnby13YXRjaGAgY3JhdGVzXG4gICAqL1xuICB3YXRjaD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGZlYXR1cmVzIHRvIGFjdGl2YXRlXG4gICAqL1xuICBmZWF0dXJlcz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzXG4gICAqL1xuICBhbGxGZWF0dXJlcz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERvIG5vdCBhY3RpdmF0ZSB0aGUgYGRlZmF1bHRgIGZlYXR1cmVcbiAgICovXG4gIG5vRGVmYXVsdEZlYXR1cmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0QnVpbGRPcHRpb25zKG9wdGlvbnM6IEJ1aWxkT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGR0c0NhY2hlOiB0cnVlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuXG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmltcG9ydCB7IGJ1aWxkUHJvamVjdCB9IGZyb20gJy4uL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IEJhc2VCdWlsZENvbW1hbmQgfSBmcm9tICcuLi9kZWYvYnVpbGQuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ2J1aWxkJylcblxuZXhwb3J0IGNsYXNzIEJ1aWxkQ29tbWFuZCBleHRlbmRzIEJhc2VCdWlsZENvbW1hbmQge1xuICBwaXBlID0gT3B0aW9uLlN0cmluZygnLS1waXBlJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BpcGUgYWxsIG91dHB1dHMgZmlsZSB0byBnaXZlbiBjb21tYW5kLiBlLmcuIGBuYXBpIGJ1aWxkIC0tcGlwZSBcIm5weCBwcmV0dGllciAtLXdyaXRlXCJgJyxcbiAgfSlcblxuICBjYXJnb09wdGlvbnMgPSBPcHRpb24uUmVzdCgpXG5cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBjb25zdCB7IHRhc2sgfSA9IGF3YWl0IGJ1aWxkUHJvamVjdCh7XG4gICAgICAuLi50aGlzLmdldE9wdGlvbnMoKSxcbiAgICAgIGNhcmdvT3B0aW9uczogdGhpcy5jYXJnb09wdGlvbnMsXG4gICAgfSlcblxuICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCB0YXNrXG5cbiAgICBpZiAodGhpcy5waXBlKSB7XG4gICAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIGRlYnVnKCdQaXBpbmcgb3V0cHV0IGZpbGUgdG8gY29tbWFuZDogJXMnLCB0aGlzLnBpcGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhlY1N5bmMoYCR7dGhpcy5waXBlfSAke291dHB1dC5wYXRofWAsIHtcbiAgICAgICAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihgRmFpbGVkIHRvIHBpcGUgb3V0cHV0IGZpbGUgJHtvdXRwdXQucGF0aH0gdG8gY29tbWFuZGApXG4gICAgICAgICAgZGVidWcuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlTnBtRGlycyB9IGZyb20gJy4uL2FwaS9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBCYXNlQ3JlYXRlTnBtRGlyc0NvbW1hbmQgfSBmcm9tICcuLi9kZWYvY3JlYXRlLW5wbS1kaXJzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ3JlYXRlTnBtRGlyc0NvbW1hbmQgZXh0ZW5kcyBCYXNlQ3JlYXRlTnBtRGlyc0NvbW1hbmQge1xuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IGNyZWF0ZU5wbURpcnModGhpcy5nZXRPcHRpb25zKCkpXG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1hbmQgfSBmcm9tICdjbGlwYW5pb24nXG5cbi8qKlxuICogQSBjb21tYW5kIHRoYXQgcHJpbnRzIHRoZSB1c2FnZSBvZiBhbGwgY29tbWFuZHMuXG4gKlxuICogUGF0aHM6IGAtaGAsIGAtLWhlbHBgXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWxwQ29tbWFuZCBleHRlbmRzIENvbW1hbmQ8YW55PiB7XG4gIHN0YXRpYyBwYXRocyA9IFtbYC1oYF0sIFtgLS1oZWxwYF1dXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgYXdhaXQgdGhpcy5jb250ZXh0LnN0ZG91dC53cml0ZSh0aGlzLmNsaS51c2FnZSgpKVxuICB9XG59XG4iLCJpbXBvcnQgcGF0aCBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IGlucHV0LCBzZWxlY3QsIGNoZWNrYm94LCBjb25maXJtIH0gZnJvbSAnQGlucXVpcmVyL3Byb21wdHMnXG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmltcG9ydCB7IG5ld1Byb2plY3QgfSBmcm9tICcuLi9hcGkvbmV3LmpzJ1xuaW1wb3J0IHsgQmFzZU5ld0NvbW1hbmQgfSBmcm9tICcuLi9kZWYvbmV3LmpzJ1xuaW1wb3J0IHtcbiAgQVZBSUxBQkxFX1RBUkdFVFMsXG4gIGRlYnVnRmFjdG9yeSxcbiAgREVGQVVMVF9UQVJHRVRTLFxuICB0eXBlIFRhcmdldFRyaXBsZSxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5pbXBvcnQgeyBuYXBpRW5naW5lUmVxdWlyZW1lbnQgfSBmcm9tICcuLi91dGlscy92ZXJzaW9uLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnbmV3JylcblxuZXhwb3J0IGNsYXNzIE5ld0NvbW1hbmQgZXh0ZW5kcyBCYXNlTmV3Q29tbWFuZCB7XG4gIGludGVyYWN0aXZlID0gT3B0aW9uLkJvb2xlYW4oJy0taW50ZXJhY3RpdmUsLWknLCB0cnVlLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnQXNrIHByb2plY3QgYmFzaWMgaW5mb3JtYXRpb24gaW50ZXJhY3RpdmVseSB3aXRob3V0IGp1c3QgdXNpbmcgdGhlIGRlZmF1bHQuJyxcbiAgfSlcblxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgdGhpcy5mZXRjaE9wdGlvbnMoKVxuICAgICAgYXdhaXQgbmV3UHJvamVjdChvcHRpb25zKVxuICAgICAgcmV0dXJuIDBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnRmFpbGVkIHRvIGNyZWF0ZSBuZXcgcHJvamVjdCcpXG4gICAgICBkZWJ1Zy5lcnJvcihlKVxuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoT3B0aW9ucygpIHtcbiAgICBjb25zdCBjbWRPcHRpb25zID0gc3VwZXIuZ2V0T3B0aW9ucygpXG5cbiAgICBpZiAodGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgY29uc3QgdGFyZ2V0UGF0aDogc3RyaW5nID0gY21kT3B0aW9ucy5wYXRoXG4gICAgICAgID8gY21kT3B0aW9ucy5wYXRoXG4gICAgICAgIDogYXdhaXQgaW5xdWlyZXJQcm9qZWN0UGF0aCgpXG4gICAgICBjbWRPcHRpb25zLnBhdGggPSB0YXJnZXRQYXRoXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5jbWRPcHRpb25zLFxuICAgICAgICBuYW1lOiBhd2FpdCB0aGlzLmZldGNoTmFtZShwYXRoLnBhcnNlKHRhcmdldFBhdGgpLmJhc2UpLFxuICAgICAgICBtaW5Ob2RlQXBpVmVyc2lvbjogYXdhaXQgdGhpcy5mZXRjaE5hcGlWZXJzaW9uKCksXG4gICAgICAgIHRhcmdldHM6IGF3YWl0IHRoaXMuZmV0Y2hUYXJnZXRzKCksXG4gICAgICAgIGxpY2Vuc2U6IGF3YWl0IHRoaXMuZmV0Y2hMaWNlbnNlKCksXG4gICAgICAgIGVuYWJsZVR5cGVEZWY6IGF3YWl0IHRoaXMuZmV0Y2hUeXBlRGVmKCksXG4gICAgICAgIGVuYWJsZUdpdGh1YkFjdGlvbnM6IGF3YWl0IHRoaXMuZmV0Y2hHaXRodWJBY3Rpb25zKCksXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtZE9wdGlvbnNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hOYW1lKGRlZmF1bHROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLiQkbmFtZSA/P1xuICAgICAgaW5wdXQoe1xuICAgICAgICBtZXNzYWdlOiAnUGFja2FnZSBuYW1lICh0aGUgbmFtZSBmaWVsZCBpbiB5b3VyIHBhY2thZ2UuanNvbiBmaWxlKScsXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHROYW1lLFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoTGljZW5zZSgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBpbnB1dCh7XG4gICAgICBtZXNzYWdlOiAnTGljZW5zZSBmb3Igb3Blbi1zb3VyY2VkIHByb2plY3QnLFxuICAgICAgZGVmYXVsdDogdGhpcy5saWNlbnNlLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoTmFwaVZlcnNpb24oKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gc2VsZWN0KHtcbiAgICAgIG1lc3NhZ2U6ICdNaW5pbXVtIG5vZGUtYXBpIHZlcnNpb24gKHdpdGggbm9kZSB2ZXJzaW9uIHJlcXVpcmVtZW50KScsXG4gICAgICBsb29wOiBmYWxzZSxcbiAgICAgIHBhZ2VTaXplOiAxMCxcbiAgICAgIGNob2ljZXM6IEFycmF5LmZyb20oeyBsZW5ndGg6IDggfSwgKF8sIGkpID0+ICh7XG4gICAgICAgIG5hbWU6IGBuYXBpJHtpICsgMX0gKCR7bmFwaUVuZ2luZVJlcXVpcmVtZW50KGkgKyAxKX0pYCxcbiAgICAgICAgdmFsdWU6IGkgKyAxLFxuICAgICAgfSkpLFxuICAgICAgLy8gY2hvaWNlIGluZGV4XG4gICAgICBkZWZhdWx0OiB0aGlzLm1pbk5vZGVBcGlWZXJzaW9uIC0gMSxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFRhcmdldHMoKTogUHJvbWlzZTxUYXJnZXRUcmlwbGVbXT4ge1xuICAgIGlmICh0aGlzLmVuYWJsZUFsbFRhcmdldHMpIHtcbiAgICAgIHJldHVybiBBVkFJTEFCTEVfVEFSR0VUUy5jb25jYXQoKVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldHMgPSBhd2FpdCBjaGVja2JveCh7XG4gICAgICBsb29wOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICdDaG9vc2UgdGFyZ2V0KHMpIHlvdXIgY3JhdGUgd2lsbCBiZSBjb21waWxlZCB0bycsXG4gICAgICBjaG9pY2VzOiBBVkFJTEFCTEVfVEFSR0VUUy5tYXAoKHRhcmdldCkgPT4gKHtcbiAgICAgICAgbmFtZTogdGFyZ2V0LFxuICAgICAgICB2YWx1ZTogdGFyZ2V0LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNoZWNrZWQ6IERFRkFVTFRfVEFSR0VUUy5pbmNsdWRlcyh0YXJnZXQpLFxuICAgICAgfSkpLFxuICAgIH0pXG5cbiAgICByZXR1cm4gdGFyZ2V0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaFR5cGVEZWYoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW5hYmxlVHlwZURlZiA9IGF3YWl0IGNvbmZpcm0oe1xuICAgICAgbWVzc2FnZTogJ0VuYWJsZSB0eXBlIGRlZmluaXRpb24gYXV0by1nZW5lcmF0aW9uJyxcbiAgICAgIGRlZmF1bHQ6IHRoaXMuZW5hYmxlVHlwZURlZixcbiAgICB9KVxuXG4gICAgcmV0dXJuIGVuYWJsZVR5cGVEZWZcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hHaXRodWJBY3Rpb25zKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGVuYWJsZUdpdGh1YkFjdGlvbnMgPSBhd2FpdCBjb25maXJtKHtcbiAgICAgIG1lc3NhZ2U6ICdFbmFibGUgR2l0aHViIEFjdGlvbnMgQ0knLFxuICAgICAgZGVmYXVsdDogdGhpcy5lbmFibGVHaXRodWJBY3Rpb25zLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZW5hYmxlR2l0aHViQWN0aW9uc1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlucXVpcmVyUHJvamVjdFBhdGgoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIGlucHV0KHtcbiAgICBtZXNzYWdlOiAnVGFyZ2V0IHBhdGggdG8gY3JlYXRlIHRoZSBwcm9qZWN0LCByZWxhdGl2ZSB0byBjd2QuJyxcbiAgfSkudGhlbigocGF0aCkgPT4ge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIGlucXVpcmVyUHJvamVjdFBhdGgoKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aFxuICB9KVxufVxuIiwiaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4uL2FwaS9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IEJhc2VQcmVQdWJsaXNoQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcblxuZXhwb3J0IGNsYXNzIFByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQmFzZVByZVB1Ymxpc2hDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNvbnN0ICducG0nIHwgJ2xlcm5hJyB0byBzdHJpbmdcbiAgICBhd2FpdCBwcmVQdWJsaXNoKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBpbnB1dCB9IGZyb20gJ0BpbnF1aXJlci9wcm9tcHRzJ1xuXG5pbXBvcnQgeyByZW5hbWVQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IEJhc2VSZW5hbWVDb21tYW5kIH0gZnJvbSAnLi4vZGVmL3JlbmFtZS5qcydcblxuZXhwb3J0IGNsYXNzIFJlbmFtZUNvbW1hbmQgZXh0ZW5kcyBCYXNlUmVuYW1lQ29tbWFuZCB7XG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpXG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCBpbnB1dCh7XG4gICAgICAgIG1lc3NhZ2U6IGBFbnRlciB0aGUgbmV3IHBhY2thZ2UgbmFtZSBpbiB0aGUgcGFja2FnZS5qc29uYCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICB9KVxuICAgICAgb3B0aW9ucy5uYW1lID0gbmFtZVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgICAgY29uc3QgYmluYXJ5TmFtZSA9IGF3YWl0IGlucHV0KHtcbiAgICAgICAgbWVzc2FnZTogYEVudGVyIHRoZSBuZXcgYmluYXJ5IG5hbWVgLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBvcHRpb25zLmJpbmFyeU5hbWUgPSBiaW5hcnlOYW1lXG4gICAgfVxuICAgIGF3YWl0IHJlbmFtZVByb2plY3Qob3B0aW9ucylcbiAgfVxufVxuIiwiaW1wb3J0IHsgdW5pdmVyc2FsaXplQmluYXJpZXMgfSBmcm9tICcuLi9hcGkvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQgfSBmcm9tICcuLi9kZWYvdW5pdmVyc2FsaXplLmpzJ1xuXG5leHBvcnQgY2xhc3MgVW5pdmVyc2FsaXplQ29tbWFuZCBleHRlbmRzIEJhc2VVbml2ZXJzYWxpemVDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCB1bml2ZXJzYWxpemVCaW5hcmllcyh0aGlzLmdldE9wdGlvbnMoKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL2FwaS92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgQmFzZVZlcnNpb25Db21tYW5kIH0gZnJvbSAnLi4vZGVmL3ZlcnNpb24uanMnXG5cbmV4cG9ydCBjbGFzcyBWZXJzaW9uQ29tbWFuZCBleHRlbmRzIEJhc2VWZXJzaW9uQ29tbWFuZCB7XG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgYXdhaXQgdmVyc2lvbih0aGlzLmdldE9wdGlvbnMoKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2xpIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5pbXBvcnQgeyBjb2xsZWN0QXJ0aWZhY3RzIH0gZnJvbSAnLi9hcGkvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHsgYnVpbGRQcm9qZWN0IH0gZnJvbSAnLi9hcGkvYnVpbGQuanMnXG5pbXBvcnQgeyBjcmVhdGVOcG1EaXJzIH0gZnJvbSAnLi9hcGkvY3JlYXRlLW5wbS1kaXJzLmpzJ1xuaW1wb3J0IHsgbmV3UHJvamVjdCB9IGZyb20gJy4vYXBpL25ldy5qcydcbmltcG9ydCB7IHByZVB1Ymxpc2ggfSBmcm9tICcuL2FwaS9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IHJlbmFtZVByb2plY3QgfSBmcm9tICcuL2FwaS9yZW5hbWUuanMnXG5pbXBvcnQgeyB1bml2ZXJzYWxpemVCaW5hcmllcyB9IGZyb20gJy4vYXBpL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2FwaS92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgQXJ0aWZhY3RzQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvYXJ0aWZhY3RzLmpzJ1xuaW1wb3J0IHsgQnVpbGRDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9idWlsZC5qcydcbmltcG9ydCB7IENyZWF0ZU5wbURpcnNDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBIZWxwQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvaGVscC5qcydcbmltcG9ydCB7IE5ld0NvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL25ldy5qcydcbmltcG9ydCB7IFByZVB1Ymxpc2hDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7IFJlbmFtZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3JlbmFtZS5qcydcbmltcG9ydCB7IFVuaXZlcnNhbGl6ZUNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3VuaXZlcnNhbGl6ZS5qcydcbmltcG9ydCB7IFZlcnNpb25Db21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgQ0xJX1ZFUlNJT04gfSBmcm9tICcuL3V0aWxzL21pc2MuanMnXG5cbmV4cG9ydCBjb25zdCBjbGkgPSBuZXcgQ2xpKHtcbiAgYmluYXJ5TmFtZTogJ25hcGknLFxuICBiaW5hcnlWZXJzaW9uOiBDTElfVkVSU0lPTixcbn0pXG5cbmNsaS5yZWdpc3RlcihOZXdDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKEJ1aWxkQ29tbWFuZClcbmNsaS5yZWdpc3RlcihDcmVhdGVOcG1EaXJzQ29tbWFuZClcbmNsaS5yZWdpc3RlcihBcnRpZmFjdHNDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFVuaXZlcnNhbGl6ZUNvbW1hbmQpXG5jbGkucmVnaXN0ZXIoUmVuYW1lQ29tbWFuZClcbmNsaS5yZWdpc3RlcihQcmVQdWJsaXNoQ29tbWFuZClcbmNsaS5yZWdpc3RlcihWZXJzaW9uQ29tbWFuZClcbmNsaS5yZWdpc3RlcihIZWxwQ29tbWFuZClcblxuLyoqXG4gKlxuICogQHVzYWdlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGNsaSA9IG5ldyBOYXBpQ2xpKClcbiAqXG4gKiBjbGkuYnVpbGQoe1xuICogICBjd2Q6ICcvcGF0aC90by95b3VyL3Byb2plY3QnLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTmFwaUNsaSB7XG4gIGFydGlmYWN0cyA9IGNvbGxlY3RBcnRpZmFjdHNcbiAgbmV3ID0gbmV3UHJvamVjdFxuICBidWlsZCA9IGJ1aWxkUHJvamVjdFxuICBjcmVhdGVOcG1EaXJzID0gY3JlYXRlTnBtRGlyc1xuICBwcmVQdWJsaXNoID0gcHJlUHVibGlzaFxuICByZW5hbWUgPSByZW5hbWVQcm9qZWN0XG4gIHVuaXZlcnNhbGl6ZSA9IHVuaXZlcnNhbGl6ZUJpbmFyaWVzXG4gIHZlcnNpb24gPSB2ZXJzaW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdWlsZENvbW1hbmQoYXJnczogc3RyaW5nW10pOiBCdWlsZENvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWydidWlsZCcsIC4uLmFyZ3NdKSBhcyBCdWlsZENvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFydGlmYWN0c0NvbW1hbmQoYXJnczogc3RyaW5nW10pOiBBcnRpZmFjdHNDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsnYXJ0aWZhY3RzJywgLi4uYXJnc10pIGFzIEFydGlmYWN0c0NvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNyZWF0ZU5wbURpcnNDb21tYW5kKFxuICBhcmdzOiBzdHJpbmdbXSxcbik6IENyZWF0ZU5wbURpcnNDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsnY3JlYXRlLW5wbS1kaXJzJywgLi4uYXJnc10pIGFzIENyZWF0ZU5wbURpcnNDb21tYW5kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVQdWJsaXNoQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IFByZVB1Ymxpc2hDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsncHJlLXB1Ymxpc2gnLCAuLi5hcmdzXSkgYXMgUHJlUHVibGlzaENvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlbmFtZUNvbW1hbmQoYXJnczogc3RyaW5nW10pOiBSZW5hbWVDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsncmVuYW1lJywgLi4uYXJnc10pIGFzIFJlbmFtZUNvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuaXZlcnNhbGl6ZUNvbW1hbmQoYXJnczogc3RyaW5nW10pOiBVbml2ZXJzYWxpemVDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsndW5pdmVyc2FsaXplJywgLi4uYXJnc10pIGFzIFVuaXZlcnNhbGl6ZUNvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db21tYW5kKGFyZ3M6IHN0cmluZ1tdKTogVmVyc2lvbkNvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWyd2ZXJzaW9uJywgLi4uYXJnc10pIGFzIFZlcnNpb25Db21tYW5kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdDb21tYW5kKGFyZ3M6IHN0cmluZ1tdKTogTmV3Q29tbWFuZCB7XG4gIHJldHVybiBjbGkucHJvY2VzcyhbJ25ldycsIC4uLmFyZ3NdKSBhcyBOZXdDb21tYW5kXG59XG5cbmV4cG9ydCB7IHBhcnNlVHJpcGxlIH0gZnJvbSAnLi91dGlscy90YXJnZXQuanMnXG5leHBvcnQge1xuICB0eXBlIEdlbmVyYXRlVHlwZURlZk9wdGlvbnMsXG4gIHR5cGUgV3JpdGVKc0JpbmRpbmdPcHRpb25zLFxuICB3cml0ZUpzQmluZGluZyxcbiAgZ2VuZXJhdGVUeXBlRGVmLFxufSBmcm9tICcuL2FwaS9idWlsZC5qcydcbmV4cG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi91dGlscy9jb25maWcuanMnXG4iLCIjIS91c3IvYmluL2VudiBub2RlXG5cbmltcG9ydCB7IGNsaSB9IGZyb20gJy4vaW5kZXguanMnXG5cbnZvaWQgY2xpLnJ1bkV4aXQocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKVxuIl0sInhfZ29vZ2xlX2lnbm9yZUxpc3QiOlsxOSwyMCwyMSwyMiwyMywyNCwyNSwyNl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQXNCLHVCQUF0QixjQUFtRCxRQUFRO0NBQ3pELE9BQU8sUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0NBRTlCLE9BQU8sUUFBUSxRQUFRLE1BQU0sRUFDM0IsYUFDRSw2RUFDSCxDQUFDO0NBRUYsTUFBTSxPQUFPLE9BQU8sU0FBUyxRQUFRLEtBQUssRUFBRSxFQUMxQyxhQUNFLHNIQUNILENBQUM7Q0FFRixhQUFzQixPQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsbUNBQ2QsQ0FBQztDQUVGLGtCQUFrQixPQUFPLE9BQU8sdUJBQXVCLGdCQUFnQixFQUNyRSxhQUFhLDBCQUNkLENBQUM7Q0FFRixZQUFZLE9BQU8sT0FBTyxzQkFBc0IsZUFBZSxFQUM3RCxhQUNFLGlHQUNILENBQUM7Q0FFRixTQUFTLE9BQU8sT0FBTyxhQUFhLE9BQU8sRUFDekMsYUFBYSxpREFDZCxDQUFDO0NBRUYsaUJBQTBCLE9BQU8sT0FBTyxzQkFBc0IsRUFDNUQsYUFDRSxtRkFDSCxDQUFDO0NBRUYsYUFBYTtBQUNYLFNBQU87R0FDTCxLQUFLLEtBQUs7R0FDVixZQUFZLEtBQUs7R0FDakIsaUJBQWlCLEtBQUs7R0FDdEIsV0FBVyxLQUFLO0dB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