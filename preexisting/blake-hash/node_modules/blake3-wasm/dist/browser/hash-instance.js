"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeriveKey = exports.createKeyed = exports.createHash = exports.BrowserHasher = void 0;
const blake3_internal_1 = require("@c4312/blake3-internal");
const encoding_js_1 = require("./encoding.js");
const hash_js_1 = require("./hash.js");
/**
 * @inheritdoc
 */
class BrowserHasher extends blake3_internal_1.WasmHasher {
    alloc(n) {
        return new hash_js_1.Hash(n);
    }
    /**
     * @inheritdoc
     * @override
     */
    update(data) {
        return super.update((0, blake3_internal_1.inputToArray)(data));
    }
    digest(encoding, options) {
        let resolvedOpts;
        let resolvedEnc;
        if (encoding && typeof encoding === 'object') {
            resolvedOpts = encoding;
            resolvedEnc = undefined;
        }
        else {
            resolvedOpts = options;
            resolvedEnc = encoding;
        }
        const result = super.digest(resolvedOpts);
        return resolvedEnc ? (0, encoding_js_1.mustGetEncoder)(resolvedEnc)(result) : result;
    }
}
exports.BrowserHasher = BrowserHasher;
/**
 * A Node.js crypto-like createHash method.
 */
const createHash = () => new BrowserHasher((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.default());
exports.createHash = createHash;
/**
 * A Node.js crypto-like createHash method.
 */
const createKeyed = (key) => new BrowserHasher((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.keyed((0, blake3_internal_1.inputToArray)(key)));
exports.createKeyed = createKeyed;
/**
 * Construct a new Hasher for the key derivation function.
 */
const createDeriveKey = (context) => new BrowserHasher((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.derive((0, blake3_internal_1.inputToArray)(context)));
exports.createDeriveKey = createDeriveKey;
//# sourceMappingURL=hash-instance.js.map