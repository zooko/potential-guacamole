"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDeriveKey = exports.createKeyed = exports.createHash = exports.NodeHash = void 0;
const blake3_internal_1 = require("@c4312/blake3-internal");
const stream_1 = require("stream");
class BufferHash extends blake3_internal_1.WasmHasher {
    alloc(n) {
        return Buffer.allocUnsafe(n);
    }
}
/**
 * @inheritdoc
 */
class NodeHash extends stream_1.Transform {
    constructor(wasmModule, hasher) {
        super();
        this.hash = new BufferHash(wasmModule, hasher);
    }
    /**
     * @reader
     */
    reader() {
        return this.hash.reader();
    }
    /**
     * @inheritdoc
     */
    update(data, encoding) {
        this.hash.update(encoding && typeof data === 'string' ? Buffer.from(data, encoding) : (0, blake3_internal_1.inputToArray)(data));
        return this;
    }
    /**
     * @inheritdoc
     */
    dispose() {
        this.hash.dispose();
    }
    digest(encoding, options) {
        let resolvedOpts;
        let resolvedEnc;
        if (encoding && typeof encoding === 'object') {
            resolvedOpts = encoding;
            resolvedEnc = undefined;
        }
        else {
            resolvedOpts = options;
            resolvedEnc = encoding;
        }
        const result = this.hash.digest(resolvedOpts);
        return resolvedEnc ? result.toString(resolvedEnc) : result;
    }
    /**
     * @inheritdoc
     * @hidden
     */
    _transform(chunk, encoding, callback) {
        this.update(chunk, encoding);
        callback();
    }
    /**
     * @inheritdoc
     * @hidden
     */
    _flush(callback) {
        callback(null, this.digest());
    }
}
exports.NodeHash = NodeHash;
/**
 * A Node.js crypto-like createHash method.
 */
const createHash = () => new NodeHash((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.default());
exports.createHash = createHash;
/**
 * Construct a new Hasher for the keyed hash function.
 */
const createKeyed = (key) => new NodeHash((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.keyed((0, blake3_internal_1.inputToArray)(key)));
exports.createKeyed = createKeyed;
/**
 * Construct a new Hasher for the key derivation function.
 */
const createDeriveKey = (context) => new NodeHash((0, blake3_internal_1.getWasm)(), blake3_internal_1.HashRaw.derive((0, blake3_internal_1.inputToArray)(context)));
exports.createDeriveKey = createDeriveKey;
//# sourceMappingURL=hash-instance.js.map