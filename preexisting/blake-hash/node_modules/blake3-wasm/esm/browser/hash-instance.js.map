{"version":3,"file":"hash-instance.js","sourceRoot":"","sources":["../../src/browser/hash-instance.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,OAAO,EAEP,OAAO,EAEP,YAAY,EACZ,UAAU,GACX,MAAM,wBAAwB,CAAC;AAChC,OAAO,EAAmB,cAAc,EAAE,MAAM,eAAe,CAAC;AAChE,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AAEjC;;GAEG;AACH,MAAM,OAAO,aAAc,SAAQ,UAAgB;IACvC,KAAK,CAAC,CAAS;QACvB,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC;IACrB,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,IAAe;QAC3B,OAAO,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1C,CAAC;IAQM,MAAM,CACX,QAA6C,EAC7C,OAA0B;QAE1B,IAAI,YAA0C,CAAC;QAC/C,IAAI,WAAwC,CAAC;QAC7C,IAAI,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YAC5C,YAAY,GAAG,QAAQ,CAAC;YACxB,WAAW,GAAG,SAAS,CAAC;SACzB;aAAM;YACL,YAAY,GAAG,OAAO,CAAC;YACvB,WAAW,GAAG,QAAQ,CAAC;SACxB;QAED,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QAC1C,OAAO,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IACpE,CAAC;CACF;AAED;;GAEG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,GAAG,EAAE,CAAC,IAAI,aAAa,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAEhF;;GAEG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,GAAc,EAAE,EAAE,CAC5C,IAAI,aAAa,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAEjE;;GAEG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,OAAkB,EAAE,EAAE,CACpD,IAAI,aAAa,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC","sourcesContent":["import {\n  getWasm,\n  HashInput,\n  HashRaw,\n  IBaseHashOptions,\n  inputToArray,\n  WasmHasher,\n} from '@c4312/blake3-internal';\nimport { BrowserEncoding, mustGetEncoder } from './encoding.js';\nimport { Hash } from './hash.js';\n\n/**\n * @inheritdoc\n */\nexport class BrowserHasher extends WasmHasher<Hash> {\n  protected alloc(n: number): Hash {\n    return new Hash(n);\n  }\n\n  /**\n   * @inheritdoc\n   * @override\n   */\n  public update(data: HashInput): this {\n    return super.update(inputToArray(data));\n  }\n\n  /**\n   * Returns a digest of the hash with the given encoding.\n   */\n  public digest(options?: IBaseHashOptions): Hash;\n  public digest(encoding: undefined, options: IBaseHashOptions): Hash;\n  public digest(encoding: BrowserEncoding, options?: IBaseHashOptions): string;\n  public digest(\n    encoding?: IBaseHashOptions | BrowserEncoding,\n    options?: IBaseHashOptions,\n  ): string | Hash {\n    let resolvedOpts: IBaseHashOptions | undefined;\n    let resolvedEnc: BrowserEncoding | undefined;\n    if (encoding && typeof encoding === 'object') {\n      resolvedOpts = encoding;\n      resolvedEnc = undefined;\n    } else {\n      resolvedOpts = options;\n      resolvedEnc = encoding;\n    }\n\n    const result = super.digest(resolvedOpts);\n    return resolvedEnc ? mustGetEncoder(resolvedEnc)(result) : result;\n  }\n}\n\n/**\n * A Node.js crypto-like createHash method.\n */\nexport const createHash = () => new BrowserHasher(getWasm(), HashRaw.default());\n\n/**\n * A Node.js crypto-like createHash method.\n */\nexport const createKeyed = (key: HashInput) =>\n  new BrowserHasher(getWasm(), HashRaw.keyed(inputToArray(key)));\n\n/**\n * Construct a new Hasher for the key derivation function.\n */\nexport const createDeriveKey = (context: HashInput) =>\n  new BrowserHasher(getWasm(), HashRaw.derive(inputToArray(context)));\n"]}