{"version":3,"file":"hash-instance.js","sourceRoot":"","sources":["../../src/node/hash-instance.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,OAAO,EAEP,OAAO,EAGP,YAAY,EACZ,UAAU,GACX,MAAM,wBAAwB,CAAC;AAChC,OAAO,EAAE,SAAS,EAAqB,MAAM,QAAQ,CAAC;AA0BtD,MAAM,UAAW,SAAQ,UAAkB;IAC/B,KAAK,CAAC,CAAS;QACvB,OAAO,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IAC/B,CAAC;CACF;AAED;;GAEG;AACH,MAAM,OAAO,QAAS,SAAQ,SAAS;IAGrC,YAAY,UAAe,EAAE,MAAe;QAC1C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,IAAI,GAAG,IAAI,UAAU,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,MAAM;QACX,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;IAC5B,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,IAAe,EAAE,QAAyB;QACtD,IAAI,CAAC,IAAI,CAAC,MAAM,CACd,QAAQ,IAAI,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CACxF,CAAC;QACF,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;IACtB,CAAC;IAQM,MAAM,CACX,QAA4C,EAC5C,OAA0B;QAE1B,IAAI,YAA0C,CAAC;QAC/C,IAAI,WAAuC,CAAC;QAC5C,IAAI,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;YAC5C,YAAY,GAAG,QAAQ,CAAC;YACxB,WAAW,GAAG,SAAS,CAAC;SACzB;aAAM;YACL,YAAY,GAAG,OAAO,CAAC;YACvB,WAAW,GAAG,QAAQ,CAAC;SACxB;QAED,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;QAC9C,OAAO,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IAC7D,CAAC;IAED;;;OAGG;IACM,UAAU,CAAC,KAAsB,EAAE,QAAgB,EAAE,QAA2B;QACvF,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,QAA0B,CAAC,CAAC;QAC/C,QAAQ,EAAE,CAAC;IACb,CAAC;IAED;;;OAGG;IACM,MAAM,CAAC,QAA2B;QACzC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;IAChC,CAAC;CACF;AAED;;GAEG;AACH,MAAM,CAAC,MAAM,UAAU,GAAG,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAE3E;;GAEG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,GAAc,EAAE,EAAE,CAC5C,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AAE5D;;GAEG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,OAAkB,EAAE,EAAE,CACpD,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC","sourcesContent":["import {\n  getWasm,\n  HashInput,\n  HashRaw,\n  IBaseHashOptions,\n  IHasher,\n  inputToArray,\n  WasmHasher,\n} from '@c4312/blake3-internal';\nimport { Transform, TransformCallback } from 'stream';\n\nexport interface INodeHash extends IHasher<Buffer> {\n  /**\n   * @inheritdoc\n   * @override\n   */\n  update(data: HashInput, encoding?: BufferEncoding): this;\n\n  /**\n   * @inheritdoc\n   * @override\n   */\n  digest(options?: IBaseHashOptions): Buffer;\n\n  /**\n   * Returns a digest of the hash with the given set of hash options.\n   */\n  digest(encoding: undefined, options: IBaseHashOptions): Buffer;\n\n  /**\n   * Returns a digest of the hash with the given encoding.\n   */\n  digest(encoding: BufferEncoding, options?: IBaseHashOptions): string;\n}\n\nclass BufferHash extends WasmHasher<Buffer> {\n  protected alloc(n: number): Buffer {\n    return Buffer.allocUnsafe(n);\n  }\n}\n\n/**\n * @inheritdoc\n */\nexport class NodeHash extends Transform implements IHasher<Buffer> {\n  private readonly hash: BufferHash;\n\n  constructor(wasmModule: any, hasher: HashRaw) {\n    super();\n    this.hash = new BufferHash(wasmModule, hasher);\n  }\n\n  /**\n   * @reader\n   */\n  public reader() {\n    return this.hash.reader();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public update(data: HashInput, encoding?: BufferEncoding): this {\n    this.hash.update(\n      encoding && typeof data === 'string' ? Buffer.from(data, encoding) : inputToArray(data),\n    );\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public dispose(): void {\n    this.hash.dispose();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public digest(encoding?: IBaseHashOptions): Buffer;\n  public digest(encoding: undefined, options: IBaseHashOptions): Buffer;\n  public digest(encoding: BufferEncoding, options?: IBaseHashOptions): string;\n  public digest(\n    encoding?: IBaseHashOptions | BufferEncoding,\n    options?: IBaseHashOptions,\n  ): string | Buffer {\n    let resolvedOpts: IBaseHashOptions | undefined;\n    let resolvedEnc: BufferEncoding | undefined;\n    if (encoding && typeof encoding === 'object') {\n      resolvedOpts = encoding;\n      resolvedEnc = undefined;\n    } else {\n      resolvedOpts = options;\n      resolvedEnc = encoding;\n    }\n\n    const result = this.hash.digest(resolvedOpts);\n    return resolvedEnc ? result.toString(resolvedEnc) : result;\n  }\n\n  /**\n   * @inheritdoc\n   * @hidden\n   */\n  override _transform(chunk: Buffer | string, encoding: string, callback: TransformCallback): void {\n    this.update(chunk, encoding as BufferEncoding);\n    callback();\n  }\n\n  /**\n   * @inheritdoc\n   * @hidden\n   */\n  override _flush(callback: TransformCallback): void {\n    callback(null, this.digest());\n  }\n}\n\n/**\n * A Node.js crypto-like createHash method.\n */\nexport const createHash = () => new NodeHash(getWasm(), HashRaw.default());\n\n/**\n * Construct a new Hasher for the keyed hash function.\n */\nexport const createKeyed = (key: HashInput) =>\n  new NodeHash(getWasm(), HashRaw.keyed(inputToArray(key)));\n\n/**\n * Construct a new Hasher for the key derivation function.\n */\nexport const createDeriveKey = (context: HashInput) =>\n  new NodeHash(getWasm(), HashRaw.derive(inputToArray(context)));\n"]}