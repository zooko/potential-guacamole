{"version":3,"file":"hash-instance.js","sourceRoot":"","sources":["../src/hash-instance.ts"],"names":[],"mappings":"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","sourcesContent":["import { defaultHashLength, HashInput, IBaseHashOptions, inputToArray } from './hash-fn.js';\nimport { IHashReader, maxHashBytes } from './hash-reader.js';\nimport { HashRaw, WasmModule } from './wasm-types.js';\n\n/**\n * A blake3 hash. Quite similar to Node's crypto hashing.\n *\n * Note that you must call {@link IHash#dispose} or {@link IHash#done} when\n * you're finished with it to free memory.\n */\nexport interface IHasher<T> {\n  /**\n   * Adds the given data to the hash.\n   * @throws {Error} if {@link IHash#digest} has already been called.\n   */\n  update(data: HashInput): this;\n\n  /**\n   * Returns a digest of the hash.\n   *\n   * If `dispose: false` is given in the options, the hash will not\n   * automatically be disposed of, allowing you to continue updating\n   * it after obtaining the current reader.\n   */\n  digest(options?: IBaseHashOptions): T;\n\n  /**\n   * Returns a {@link HashReader} for the current hash.\n   *\n   * If `dispose: false` is given in the options, the hash will not\n   * automatically be disposed of, allowing you to continue updating\n   * it after obtaining the current reader.\n   */\n  reader(): IHashReader<T>;\n\n  /**\n   * Frees memory associated with the hasher. As of 3.x, this is not\n   * required to be call since we do so in a finalizer. However, if hashing\n   * large amounts of data synchronously, it may be necessary.\n   */\n  dispose(): void;\n}\n\nexport abstract class WasmHasher<Binary extends Uint8Array> implements IHasher<Binary> {\n  private tookReader = false;\n\n  /** @inhernal */\n  constructor(private readonly wasmModule: WasmModule, private hash: HashRaw) {}\n\n  /**\n   * Allocates a new binary array of the return type.\n   */\n  protected abstract alloc(n: number): Binary;\n\n  /** @inheritdoc */\n  public update(data: HashInput): this {\n    // reuse of the hasher is allowed after digesting, but we don't want to\n    // change any readers that were already taken. So clone the hash if the\n    // user ends up doing this.\n    if (this.tookReader) {\n      this.hash = this.hash.clone();\n      this.tookReader = false;\n    }\n\n    const arr = inputToArray(data);\n    const saddr = this.hash.scratch.grow(arr.byteLength);\n    const step = this.hash.scratch.size;\n    for (let i = 0; i < arr.byteLength; i += step) {\n      this.wasmModule.HEAPU8.set(arr.subarray(i, Math.min(arr.length, i + step)), saddr);\n      this.hash.update(saddr, arr.byteLength);\n    }\n    return this;\n  }\n\n  /** @inheritdoc */\n  public digest({ length = defaultHashLength }: IBaseHashOptions = {}): Binary {\n    const out = this.alloc(length);\n    const saddr = this.hash.scratch.grow(length);\n    const step = this.hash.scratch.size;\n    for (let i = 0; i < length; i += step) {\n      const n = Math.min(length - i, step);\n      this.hash.read(0n, saddr, n);\n      out.set(this.wasmModule.HEAPU8.subarray(saddr, saddr + n), i);\n    }\n\n    return out;\n  }\n\n  /** @inheritdoc */\n  public reader(): IHashReader<Binary> {\n    const hash = this.hash;\n    this.tookReader = true;\n    let position = 0n;\n\n    const reader: IHashReader<Binary> = {\n      get position() {\n        return position;\n      },\n      set position(value) {\n        if (value > maxHashBytes || value < 0n) {\n          throw new RangeError(`Hash reader position must be within [0, ${maxHashBytes}]`);\n        }\n        position = value;\n      },\n      readInto: (target) => {\n        const remaining = Number(maxHashBytes - position);\n\n        const length = remaining > target.byteLength ? target.byteLength : remaining;\n        const saddr = this.hash.scratch.grow(length);\n        const step = this.hash.scratch.size;\n        for (let i = 0; i < length; i += step) {\n          const n = Math.min(length - i, step);\n          this.hash.read(position, saddr, n);\n          position += BigInt(n);\n          target.set(this.wasmModule.HEAPU8.subarray(saddr, saddr + n), i);\n        }\n\n        return length;\n      },\n      read: (bytes) => {\n        bytes = Math.min(bytes, Number(maxHashBytes - position));\n        const out = this.alloc(bytes);\n        const saddr = hash.scratch.grow(bytes);\n        const step = hash.scratch.size;\n        for (let i = 0; i < bytes; i += step) {\n          const n = Math.min(bytes - i, step);\n          hash.read(position, saddr, n);\n          position += BigInt(n);\n          out.set(this.wasmModule.HEAPU8.subarray(saddr, saddr + n), i);\n        }\n\n        return out;\n      },\n      view: (bytes) => {\n        bytes = Math.min(bytes, Number(maxHashBytes - position));\n        const saddr = hash.scratch.grow(bytes);\n        hash.read(position, saddr, Math.min(bytes, hash.scratch.size));\n        position += BigInt(bytes);\n        return this.wasmModule.HEAPU8.subarray(saddr, saddr + bytes);\n      },\n      *[Symbol.iterator]() {\n        const stepSize = 1024n;\n        while (position < maxHashBytes) {\n          const bytes = maxHashBytes - stepSize < stepSize ? maxHashBytes - stepSize : stepSize;\n          yield reader.view(Number(bytes));\n        }\n      },\n    };\n\n    return reader;\n  }\n\n  public dispose() {\n    this.hash.dispose();\n  }\n}\n"]}