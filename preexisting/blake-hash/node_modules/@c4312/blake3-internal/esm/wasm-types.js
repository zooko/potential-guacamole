let globalWasm;
export const setWasm = (m) => (globalWasm = m);
export const getWasm = () => {
    if (!globalWasm) {
        throw new Error(`Make sure to await blake3.load() before trying to use any functions`);
    }
    return globalWasm;
};
const memoryDeallocator = new FinalizationRegistry((v) => v.wasm._free(v.address));
export const MAX_SCRATCH_SIZE = 1024 * 1024;
class Scratch {
    constructor() {
        this.scratchSize = 32;
    }
    get size() {
        return this.scratchSize;
    }
    grow(n) {
        let grew = false;
        while (this.scratchSize < n && this.scratchSize < MAX_SCRATCH_SIZE) {
            this.scratchSize <<= 1;
            grew = true;
        }
        if (!grew && this.addr !== undefined) {
            return this.addr;
        }
        const wasm = getWasm();
        if (this.addr !== undefined) {
            memoryDeallocator.unregister(this);
            wasm._free(this.addr);
        }
        return (this.addr = wasm._malloc(this.scratchSize));
    }
}
export const scratch = new Scratch();
export class HashRaw {
    constructor(hasher) {
        this.hasher = hasher;
        this.scratch = scratch;
        this.addr = { wasm: getWasm(), address: hasher };
        memoryDeallocator.register(this, this.addr, this);
    }
    static default() {
        return new HashRaw(getWasm().ccall('hasher_init', 'number', [], []));
    }
    static keyed(key) {
        if (key.byteLength !== 32) {
            throw new RangeError(`BLAKE3 key must be exactly 32 bytes long`);
        }
        const wasm = getWasm();
        const saddr = scratch.grow(32);
        wasm.HEAPU8.set(key, saddr);
        return new HashRaw(wasm.ccall('hasher_init_keyed', 'number', ['number'], [saddr]));
    }
    static derive(key) {
        const wasm = getWasm();
        const saddr = scratch.grow(key.byteLength);
        wasm.HEAPU8.set(key, saddr);
        return new HashRaw(wasm.ccall('hasher_init_derive', 'number', ['number', 'number'], [saddr, key.byteLength]));
    }
    update(address, length) {
        if (!this.addr) {
            throw new Error('Cannot use a hash after disposing it');
        }
        this.addr.wasm.ccall('hasher_update', null, ['number', 'number', 'number'], [this.hasher, address, length]);
    }
    read(seek, address, length) {
        if (!this.addr) {
            throw new Error('Cannot use a hash after disposing it');
        }
        this.addr.wasm.ccall('hasher_read', null, ['number', 'number', 'number', 'number', 'number'], [this.hasher, Number(seek >> 32n), Number(seek & 0xffffffffn), address, length]);
    }
    clone() {
        if (!this.addr) {
            throw new Error('Cannot use a hash after disposing it');
        }
        const addr = this.addr.wasm.ccall('clone_hasher', null, ['number'], [this.hasher]);
        return new HashRaw(addr);
    }
    dispose() {
        if (this.addr) {
            memoryDeallocator.unregister(this);
            this.addr.wasm._free(this.addr.address);
            this.addr = undefined;
        }
    }
}
//# sourceMappingURL=wasm-types.js.map