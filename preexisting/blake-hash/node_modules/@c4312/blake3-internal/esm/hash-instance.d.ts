import { HashInput, IBaseHashOptions } from './hash-fn.js';
import { IHashReader } from './hash-reader.js';
import { HashRaw, WasmModule } from './wasm-types.js';
/**
 * A blake3 hash. Quite similar to Node's crypto hashing.
 *
 * Note that you must call {@link IHash#dispose} or {@link IHash#done} when
 * you're finished with it to free memory.
 */
export interface IHasher<T> {
    /**
     * Adds the given data to the hash.
     * @throws {Error} if {@link IHash#digest} has already been called.
     */
    update(data: HashInput): this;
    /**
     * Returns a digest of the hash.
     *
     * If `dispose: false` is given in the options, the hash will not
     * automatically be disposed of, allowing you to continue updating
     * it after obtaining the current reader.
     */
    digest(options?: IBaseHashOptions): T;
    /**
     * Returns a {@link HashReader} for the current hash.
     *
     * If `dispose: false` is given in the options, the hash will not
     * automatically be disposed of, allowing you to continue updating
     * it after obtaining the current reader.
     */
    reader(): IHashReader<T>;
    /**
     * Frees memory associated with the hasher. As of 3.x, this is not
     * required to be call since we do so in a finalizer. However, if hashing
     * large amounts of data synchronously, it may be necessary.
     */
    dispose(): void;
}
export declare abstract class WasmHasher<Binary extends Uint8Array> implements IHasher<Binary> {
    private readonly wasmModule;
    private hash;
    private tookReader;
    /** @inhernal */
    constructor(wasmModule: WasmModule, hash: HashRaw);
    /**
     * Allocates a new binary array of the return type.
     */
    protected abstract alloc(n: number): Binary;
    /** @inheritdoc */
    update(data: HashInput): this;
    /** @inheritdoc */
    digest({ length }?: IBaseHashOptions): Binary;
    /** @inheritdoc */
    reader(): IHashReader<Binary>;
    dispose(): void;
}
