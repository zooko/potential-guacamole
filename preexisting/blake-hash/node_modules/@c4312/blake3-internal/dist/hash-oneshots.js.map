{"version":3,"file":"hash-oneshots.js","sourceRoot":"","sources":["../src/hash-oneshots.ts"],"names":[],"mappings":";;;AAAA,mDAAqE;AAE9D,MAAM,WAAW,GAAG,CAAC,KAAiB,EAAE,UAAkB,EAAE,EAAE;IACnE,uBAAO,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,UAAU,CAAC,CAAC;IACxC,MAAM,IAAI,GAAG,IAAA,uBAAO,GAAE,CAAC;IAEvB,MAAM,eAAe,GAAG,UAAU,IAAI,gCAAgB,CAAC;IACvD,MAAM,gBAAgB,GAAG,UAAU,GAAG,KAAK,CAAC,MAAM,IAAI,gCAAgB,CAAC;IACvE,MAAM,WAAW,GAAG,uBAAO,CAAC,IAAI,CAC9B,CAAC,eAAe,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3E,CAAC;IAEF,MAAM,QAAQ,GAAG,eAAe,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC1E,MAAM,SAAS,GAAG,gBAAgB;QAChC,CAAC,CAAC,eAAe;YACf,CAAC,CAAC,WAAW,GAAG,UAAU;YAC1B,CAAC,CAAC,WAAW;QACf,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAE/B,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;IAElC,IAAI,CAAC,KAAK,CACR,cAAc,EACd,IAAI,EACJ,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,EACxC,CAAC,SAAS,EAAE,KAAK,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,CAAC,CAChD,CAAC;IAEF,IAAI,CAAC,gBAAgB,EAAE;QACrB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;KACvB;IACD,IAAI,CAAC,eAAe,EAAE;QACpB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;KACtB;IAED,wEAAwE;IACxE,4BAA4B;IAC5B,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,GAAG,UAAU,CAAC,CAAC;AAC/D,CAAC,CAAC;AApCW,QAAA,WAAW,eAoCtB","sourcesContent":["import { getWasm, MAX_SCRATCH_SIZE, scratch } from './wasm-types.js';\n\nexport const hashOneShot = (input: Uint8Array, hashLength: number) => {\n  scratch.grow(input.length + hashLength);\n  const wasm = getWasm();\n\n  const hashIsInScratch = hashLength <= MAX_SCRATCH_SIZE;\n  const inputIsInScratch = hashLength + input.length <= MAX_SCRATCH_SIZE;\n  const scratchAddr = scratch.grow(\n    (hashIsInScratch ? hashLength : 0) + (inputIsInScratch ? input.length : 0),\n  );\n\n  const hashAddr = hashIsInScratch ? scratchAddr : wasm._malloc(hashLength);\n  const inputAddr = inputIsInScratch\n    ? hashIsInScratch\n      ? scratchAddr + hashLength\n      : scratchAddr\n    : wasm._malloc(input.length);\n\n  wasm.HEAPU8.set(input, inputAddr);\n\n  wasm.ccall(\n    'hash_oneshot',\n    null,\n    ['number', 'number', 'number', 'number'],\n    [inputAddr, input.length, hashAddr, hashLength],\n  );\n\n  if (!inputIsInScratch) {\n    wasm._free(inputAddr);\n  }\n  if (!hashIsInScratch) {\n    wasm._free(hashAddr);\n  }\n\n  // kinda use after free, but as long as we (internal caller) consumes it\n  // synchronously, it's fine.\n  return wasm.HEAPU8.subarray(hashAddr, hashAddr + hashLength);\n};\n"]}