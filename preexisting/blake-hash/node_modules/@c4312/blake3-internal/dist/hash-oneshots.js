"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashOneShot = void 0;
const wasm_types_js_1 = require("./wasm-types.js");
const hashOneShot = (input, hashLength) => {
    wasm_types_js_1.scratch.grow(input.length + hashLength);
    const wasm = (0, wasm_types_js_1.getWasm)();
    const hashIsInScratch = hashLength <= wasm_types_js_1.MAX_SCRATCH_SIZE;
    const inputIsInScratch = hashLength + input.length <= wasm_types_js_1.MAX_SCRATCH_SIZE;
    const scratchAddr = wasm_types_js_1.scratch.grow((hashIsInScratch ? hashLength : 0) + (inputIsInScratch ? input.length : 0));
    const hashAddr = hashIsInScratch ? scratchAddr : wasm._malloc(hashLength);
    const inputAddr = inputIsInScratch
        ? hashIsInScratch
            ? scratchAddr + hashLength
            : scratchAddr
        : wasm._malloc(input.length);
    wasm.HEAPU8.set(input, inputAddr);
    wasm.ccall('hash_oneshot', null, ['number', 'number', 'number', 'number'], [inputAddr, input.length, hashAddr, hashLength]);
    if (!inputIsInScratch) {
        wasm._free(inputAddr);
    }
    if (!hashIsInScratch) {
        wasm._free(hashAddr);
    }
    // kinda use after free, but as long as we (internal caller) consumes it
    // synchronously, it's fine.
    return wasm.HEAPU8.subarray(hashAddr, hashAddr + hashLength);
};
exports.hashOneShot = hashOneShot;
//# sourceMappingURL=hash-oneshots.js.map